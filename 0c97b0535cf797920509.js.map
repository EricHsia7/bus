{"version":3,"file":"0c97b0535cf797920509.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,MAAO,GAAIH,GACQ,iBAAZC,QACdA,QAAa,IAAID,IAEjBD,EAAU,IAAIC,GACf,CATD,CASGK,MAAM,I,khCCTT,IAAIC,EAAY,GAQZC,GAAwB,EAE5B,GAAI,cAAeF,KACjBA,KAAKG,UAAY,SAAUC,GACzB,IAAMC,EAAOD,EAAEE,MAAM,GAErBD,EAAKE,UAAY,SAAUC,GACzB,IAAAC,EAAAC,EAA6BF,EAAMG,KAAI,GAAhCC,EAAUH,EAAA,GAAEI,EAAMJ,EAAA,GACzBR,EAAUa,KAAK,CAAEF,WAAAA,EAAYC,OAAAA,EAAQR,KAAAA,IACrCU,GACF,CACF,MACK,CACL,IAAMV,EAAOL,KAEbA,KAAKO,UAAY,SAAUC,GACzB,IAAAQ,EAAAN,EAA6BF,EAAMG,KAAI,GAAhCC,EAAUI,EAAA,GAAEH,EAAMG,EAAA,GACzBf,EAAUa,KAAK,CAAEF,WAAAA,EAAYC,OAAAA,EAAQR,KAAAA,IACrCU,GACF,CACF,CAEA,SAASA,IACP,IAAIb,GAAqC,IAArBD,EAAUgB,OAA9B,CAEAf,GAAe,EACf,IAGIgB,EAG8BC,EANlCC,EAAqCnB,EAAUoB,QAAvCT,EAAUQ,EAAVR,WAAYC,EAAMO,EAANP,OAAQR,EAAIe,EAAJf,KAIxBiB,EAA2B,EAC3BC,EAAsB,EAAEC,E,goBAAAC,CACJb,GAAU,IAAlC,IAAAY,EAAAE,MAAAP,EAAAK,EAAAG,KAAAC,MAAoC,KAAzBC,EAASV,EAAAW,OACdD,EAAUE,MAAMC,aAAe,IAAOH,EAAUE,MAAQ,MAC1DT,GAAoBO,EAAUE,MAAMC,YAAcH,EAAUE,MAAMd,OAClEM,GAAeM,EAAUE,MAAMd,OAEnC,CAAC,OAAAgB,GAAAT,EAAApB,EAAA6B,EAAA,SAAAT,EAAAU,GAAA,CACDhB,EAAkBI,EAAmBC,EAErC,IAAMY,EAASC,MAAMlB,GAAmB,GAAMmB,KAAKC,IAAIpB,GAGvDb,EAAKkC,YAAY,CAACJ,EAAQtB,IAE1BX,GAAe,EACfa,GAvBkD,CAwBpD,C","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/./src/data/analytics/update-rate/getUpdateRate_worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","let taskQueue = [];\n\n/*: Array<{\n  dataGroups: Array<UpdateRateDataGroup>;\n  taskID: string;\n  port: any;\n}>*/\n\nlet isProcessing: boolean = false;\n\nif ('onconnect' in self) {\n  self.onconnect = function (e) {\n    const port = e.ports[0];\n\n    port.onmessage = function (event) {\n      const [dataGroups, taskID] = event.data;\n      taskQueue.push({ dataGroups, taskID, port });\n      getUpdateRate_worker();\n    };\n  };\n} else {\n  const port = self;\n\n  self.onmessage = function (event) {\n    const [dataGroups, taskID] = event.data;\n    taskQueue.push({ dataGroups, taskID, port });\n    getUpdateRate_worker();\n  };\n}\n\nfunction getUpdateRate_worker(): void {\n  if (isProcessing || taskQueue.length === 0) return;\n\n  isProcessing = true;\n  const { dataGroups, taskID, port } = taskQueue.shift();\n\n  // Perform the calculation\n  let weightedAverage: number = 0;\n  let totalCorrelation: number = 0;\n  let totalWeight: number = 0;\n  for (const dataGroup of dataGroups) {\n    if (dataGroup.stats.correlation < -0.2 || dataGroup.stats > 0.2) {\n      totalCorrelation += dataGroup.stats.correlation * dataGroup.stats.length;\n      totalWeight += dataGroup.stats.length;\n    }\n  }\n  weightedAverage = totalCorrelation / totalWeight;\n\n  const result = isNaN(weightedAverage) ? 0.8 : Math.abs(weightedAverage);\n\n  // Send the result back to the main thread\n  port.postMessage([result, taskID]);\n\n  isProcessing = false;\n  getUpdateRate_worker(); // Process next task in queue, if any\n}\n"],"names":["root","factory","exports","module","define","amd","self","taskQueue","isProcessing","onconnect","e","port","ports","onmessage","event","_event$data","_slicedToArray","data","dataGroups","taskID","push","getUpdateRate_worker","_event$data2","length","weightedAverage","_step","_taskQueue$shift","shift","totalCorrelation","totalWeight","_iterator","_createForOfIteratorHelper","s","n","done","dataGroup","value","stats","correlation","err","f","result","isNaN","Math","abs","postMessage"],"sourceRoot":""}