{"version":3,"file":"f3929653fe200e9b281c.js","mappings":"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","sources":["webpack://bus/./src/data/apis/getProvider/index.ts","webpack://bus/./src/data/apis/getStop/index.ts","webpack://bus/./src/data/apis/getSegmentBuffers/index.ts","webpack://bus/./src/data/apis/index.ts","webpack://bus/./src/data/apis/getRoute/index.ts","webpack://bus/./src/data/apis/loader.ts","webpack://bus/./src/data/apis/getSemiTimeTable/index.ts","webpack://bus/./src/data/apis/getTimeTable/index.ts"],"sourcesContent":["import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface ProviderItem {\n  id: number;\n  nameZn: string; // name in Chinese (Zhōngwén)\n  nameEn: string; // name in English\n  email: string;\n  phoneInfo: string;\n  stationId: string;\n  stationNameZn: string;\n  stationNameEn: string;\n  type: '0' | '1' | '2' | '3' | '4' | '5'; // 0: city bus station, 1: coach bus station, 2: MRT station, 3: train station, 4: airport, 5: port\n}\n\nexport type Provider = Array<ProviderItem>;\n\nlet ProviderAPIVariableCache_available: boolean = false;\nlet ProviderAPIVariableCache_data: object = {};\n\nexport async function getProvider(requestID: string): Promise<Provider> {\n  async function getData() {\n    const apis = [\n      [0, 9],\n      [1, 9]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getProvider_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 60 * 1000;\n  const cacheKey = 'bus_provider_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(result));\n    if (!ProviderAPIVariableCache_available) {\n      ProviderAPIVariableCache_available = true;\n      ProviderAPIVariableCache_data = result;\n    }\n    return result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(result));\n      return result;\n    } else {\n      if (!ProviderAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        ProviderAPIVariableCache_available = true;\n        ProviderAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getProvider_0', 0, true);\n      setDataReceivingProgress(requestID, 'getProvider_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return ProviderAPIVariableCache_data;\n    }\n  }\n}\n","import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface StopItem {\n  Id: number; // StopID\n  routeId: number; // RouteID\n  nameZh: string; // name in Chinese\n  nameEn: string; // name in English\n  seqNo: number; // sequence on the route\n  pgp: string; // pgp (-1: get off, 0: get on and off, 1: get on)\n  goBack: '0' | '1' | '2'; // GoBack (0: go, 1: back, 2: unknown)\n  longitude: string; // number in string\n  latitude: string; // number in string\n  address: string;\n  stopLocationId: number; // LocationID\n  showLon: string; // number in string\n  showLat: string; // number in string\n  vector: string;\n}\n\nexport type Stop = Array<StopItem>;\n\nexport interface SimplifiedStopItem {\n  seqNo: number;\n  goBack: '0' | '1' | '2'; // GoBack (0: go, 1: back, 2: unknown)\n  stopLocationId: number;\n}\n\nexport type SimplifiedStop = { [key: string]: SimplifiedStopItem };\n\nlet StopAPIVariableCache_available: boolean = false;\nlet StopAPIVariableCache_data: SimplifiedStop = {};\n\nasync function simplifyStop(array: Stop): Promise<SimplifiedStop> {\n  const worker = new Worker(new URL('./simplifyStop-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(array); // Send data to the worker\n  });\n\n  return result;\n}\n\nexport async function getStop(requestID: string): Promise<SimplifiedStop> {\n  async function getData() {\n    const apis = [\n      [0, 11],\n      [1, 11]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getStop_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 45 * 1000;\n  const cacheKey = 'bus_stop_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    const simplified_result = await simplifyStop(result);\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(simplified_result));\n    if (!StopAPIVariableCache_available) {\n      StopAPIVariableCache_available = true;\n      StopAPIVariableCache_data = simplified_result;\n    }\n    return simplified_result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      const simplified_result = await simplifyStop(result);\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(simplified_result));\n      return simplified_result;\n    } else {\n      if (!StopAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        StopAPIVariableCache_available = true;\n        StopAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getStop_0', 0, true);\n      setDataReceivingProgress(requestID, 'getStop_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return StopAPIVariableCache_data;\n    }\n  }\n}\n","import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface BufferZoneItem {\n  Direction: 0 | 1 | 2; // (goBack/GoBack)\n  OriginStopID: number;\n  DestinationStopID: number;\n}\n\nexport type BufferZones = Array<BufferZoneItem>;\n\nexport interface SegmentBufferItem {\n  RouteID: number;\n  BufferZones: BufferZones;\n}\n\nexport type SegmentBuffers = Array<SegmentBufferItem>;\n\nexport type SimplifiedSegmentBufferItem = { [key: string]: Array<BufferZoneItem> };\n\nexport type SimplifiedSegmentBuffer = { [key: string]: SimplifiedSegmentBufferItem };\n\nlet SegmentBuffersAPIVariableCache_available: boolean = false;\nlet SegmentBuffersAPIVariableCache_data: object = {};\n\nasync function extractSegmentBuffers(xml: string): Promise<SegmentBuffers> {\n  const worker = new Worker(new URL('./extractSegmentBuffers-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(xml); // Send data to the worker\n  });\n\n  return result;\n}\n\nasync function simplifySegmentBuffers(array: SegmentBuffers): Promise<SimplifiedSegmentBuffer> {\n  const worker = new Worker(new URL('./simplifySegmentBuffers-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(array); // Send data to the worker\n  });\n\n  return result;\n}\n\nexport async function getSegmentBuffers(requestID: string): Promise<SimplifiedSegmentBuffer> {\n  async function getData() {\n    const apis = [\n      [0, 15],\n      [1, 15]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = '';\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getSegmentBuffers_${api.e[0]}`, 'xml');\n      result += data;\n      setDataUpdateTime(requestID, -1);\n    }\n    return result;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 30 * 1000;\n  const cacheKey = 'bus_segment_buffers_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    const extractedResult = await extractSegmentBuffers(result);\n    const simplifiedResult = await simplifySegmentBuffers(extractedResult);\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(simplifiedResult));\n    if (!SegmentBuffersAPIVariableCache_available) {\n      SegmentBuffersAPIVariableCache_available = true;\n      SegmentBuffersAPIVariableCache_data = simplifiedResult;\n    }\n    return simplifiedResult;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      const extractedResult = await extractSegmentBuffers(result);\n      const simplifiedResult = await simplifySegmentBuffers(extractedResult);\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(simplifiedResult));\n      return simplifiedResult;\n    } else {\n      if (!SegmentBuffersAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        SegmentBuffersAPIVariableCache_available = true;\n        SegmentBuffersAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getSegmentBuffers_0', 0, true);\n      setDataReceivingProgress(requestID, 'getSegmentBuffers_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return SegmentBuffersAPIVariableCache_data;\n    }\n  }\n}\n","import { formatTime } from '../../tools/time';\nimport { BusData, BusDataItem } from './getBusData/index';\nimport { BusEvent, BusEventItem } from './getBusEvent/index';\nimport { SimplifiedRoute } from './getRoute/index';\n\nexport interface EstimateTimeStatus {\n  code: 0 | 0.5 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8; // 8: loading\n  text: string;\n  time: number;\n}\n\nexport function parseEstimateTime(EstimateTime: string, mode: number): EstimateTimeStatus {\n  if (typeof EstimateTime === 'string') {\n    const time = parseInt(EstimateTime);\n    if (time === -3) {\n      return { code: 6, text: '末班駛離', time };\n    }\n    if (time === -4) {\n      return { code: 5, text: '今日停駛', time };\n    }\n    if (time === -2) {\n      return { code: 4, text: '交通管制', time };\n    }\n    if (time === -1) {\n      return { code: 3, text: '未發車', time };\n    }\n    if (0 <= time && time <= 10) {\n      return { code: 2, text: '進站中', time };\n    }\n    if (10 < time && time <= 180) {\n      return { code: 1, text: formatTime(time, mode), time };\n    }\n    if (180 < time && time <= 250) {\n      return { code: 0.5, text: formatTime(time, mode), time };\n    }\n    if (250 < time) {\n      return { code: 0, text: formatTime(time, mode), time };\n    }\n  }\n  return { code: 7, text: '發生錯誤', time: -5 };\n}\n\nexport interface TimeMoment {\n  type: 'moment';\n  hours: number;\n  minutes: number;\n}\n\nexport interface TimeRange {\n  type: 'range';\n  min: number;\n  max: number;\n}\n\n/**\n * parseTimeCode\n * @param code 0: hhmm/mm, 1: mmMM/mm\n * @param mode 0: moment, 1: range\n * @returns 0: TimeMoment, 1: TimeRange\n */\n\nexport function parseTimeCode(code: string, mode: 0 | 1): TimeMoment | TimeRange {\n  const codeLength = code.length;\n  if (mode === 0) {\n    let hours = 0;\n    let minutes = 0;\n    if (codeLength === 4) {\n      hours = parseInt(code.substring(0, 2));\n      minutes = parseInt(code.substring(2, 4));\n    }\n    if (codeLength === 2) {\n      minutes = parseInt(code);\n    }\n    return {\n      type: 'moment',\n      hours: hours,\n      minutes: minutes\n    };\n  }\n  if (mode === 1) {\n    let min = 0;\n    let max = 0;\n    if (codeLength === 4) {\n      const number1 = parseInt(code.substring(0, 2));\n      const number2 = parseInt(code.substring(2, 4));\n      min = Math.min(number1, number2);\n      max = Math.max(number1, number2);\n    }\n    if (codeLength === 2) {\n      const number = parseInt(code);\n      min = number;\n      max = number;\n    }\n    return {\n      type: 'range',\n      min: min,\n      max: max\n    };\n  }\n}\n\nexport interface BatchFoundBusPosition {\n  longitude: number;\n  latitude: number;\n}\n\nexport interface BatchFoundBus {\n  CarType: BusEventItem['CarType'];\n  BusStatus: BusEventItem['BusStatus'];\n  BusID: string;\n  CarOnStop: BusEventItem['CarOnStop'];\n  onThisRoute: boolean;\n  position: BatchFoundBusPosition;\n  RouteName: string;\n  RouteID: number;\n  index: number;\n}\n\nexport type BatchFoundBuses = { [key: string]: Array<BatchFoundBus> };\n\nexport function batchFindBusesForRoute(BusEvent: BusEvent, BusData: BusData, Route: SimplifiedRoute, RouteID: number, PathAttributeId: Array<number>): BatchFoundBuses {\n  const result = {} as BatchFoundBuses;\n  const BusDataObj: {\n    [key: string]: BusDataItem;\n  } = {};\n  for (const BusDataItem of BusData) {\n    const thisBusID = BusDataItem.BusID;\n    BusDataObj[thisBusID] = BusDataItem;\n  }\n\n  for (const BusEventItem of BusEvent) {\n    const processedItem = {} as BatchFoundBus;\n\n    // collect data from 'BusEvent'\n    processedItem.CarType = BusEventItem.CarType;\n    processedItem.BusStatus = BusEventItem.BusStatus;\n    processedItem.BusID = BusEventItem.BusID;\n    processedItem.CarOnStop = BusEventItem.CarOnStop;\n\n    // check whether this bus is on the route\n    const thisRouteID = parseInt(BusEventItem.RouteID);\n    const thisBusID = String(BusEventItem.BusID);\n    let isOnThisRoute: boolean = false;\n    let index: number = 0;\n    if (thisRouteID === RouteID || PathAttributeId.indexOf(thisRouteID) > -1 || thisRouteID === RouteID * 10) {\n      isOnThisRoute = true;\n      index = thisBusID.charCodeAt(0) * Math.pow(10, -5);\n    } else {\n      isOnThisRoute = false;\n      index = thisBusID.charCodeAt(0);\n    }\n    processedItem.onThisRoute = isOnThisRoute;\n    processedItem.index = index;\n\n    // collect data from 'BusData'\n    let thisBusData = {} as BusDataItem;\n    if (BusDataObj.hasOwnProperty(thisBusID)) {\n      thisBusData = BusDataObj[thisBusID];\n    } else {\n      continue;\n    }\n    processedItem.position = {\n      latitude: parseFloat(thisBusData.Latitude),\n      longitude: parseFloat(thisBusData.Longitude)\n    };\n\n    // search data from 'Route'\n    let searchedRoute = {};\n    let isRouteSearched = false;\n    for (const key in Route) {\n      const thisRouteItem = Route[key];\n      const pid = thisRouteItem.pid;\n      if (pid.indexOf(thisRouteID) > -1) {\n        searchedRoute = thisRouteItem;\n        isRouteSearched = true;\n        break;\n      }\n    }\n    processedItem.RouteName = isRouteSearched ? searchedRoute.n : '未知路線';\n    processedItem.RouteID = isRouteSearched ? searchedRoute.id : null;\n\n    const StopKey = `s_${BusEventItem.StopID}`;\n    if (!result.hasOwnProperty(StopKey)) {\n      result[StopKey] = [];\n    }\n    result[StopKey].push(processedItem);\n    // Handle multiple buses (of the same route) on a stop\n  }\n  return result;\n}\n\nexport function batchFindBusesForLocation(BusEvent: BusEvent, BusData: BusData, Route: SimplifiedRoute, StopIDList: Array<number>): BatchFoundBuses {\n  let result = {} as BatchFoundBuses;\n  let BusDataObj: {\n    [key: string]: BusDataItem;\n  } = {};\n  for (const BusDataItem of BusData) {\n    const thisBusID = BusDataItem.BusID;\n    BusDataObj[thisBusID] = BusDataItem;\n  }\n\n  for (let BusEventItem of BusEvent) {\n    let processedItem = {} as BatchFoundBus;\n\n    const thisStopID = parseInt(BusEventItem.StopID);\n    const thisRouteID = parseInt(BusEventItem.RouteID);\n    const thisBusID = String(BusEventItem.BusID);\n\n    // Check whether this bus is on one of the specified stops\n    if (StopIDList.indexOf(thisStopID) < 0) {\n      continue;\n    }\n\n    processedItem.index = thisBusID.charCodeAt(0);\n    processedItem.onThisRoute = true; // Every entry in Location is stop-route pair\n\n    // Collect data from 'BusEvent'\n    processedItem.CarType = BusEventItem.CarType;\n    processedItem.BusStatus = BusEventItem.BusStatus;\n    processedItem.BusID = BusEventItem.BusID;\n    processedItem.CarOnStop = BusEventItem.CarOnStop;\n\n    // Collect data from 'BusData'\n    let thisBusData = {} as BusDataItem;\n    if (BusDataObj.hasOwnProperty(thisBusID)) {\n      thisBusData = BusDataObj[thisBusID];\n    } else {\n      continue;\n    }\n    processedItem.position = {\n      latitude: parseFloat(thisBusData.Latitude),\n      longitude: parseFloat(thisBusData.Longitude)\n    };\n\n    // Search data from 'Route'\n    let searchedRoute = {};\n    let isRouteSearched = false;\n    for (const key in Route) {\n      const thisRouteItem = Route[key];\n      const pid = thisRouteItem.pid;\n      if (pid.indexOf(thisRouteID) > -1) {\n        searchedRoute = thisRouteItem;\n        isRouteSearched = true;\n        break;\n      }\n    }\n    processedItem.RouteName = isRouteSearched ? searchedRoute.n : '未知路線';\n    processedItem.RouteID = isRouteSearched ? searchedRoute.id : null;\n\n    const StopKey = `s_${thisStopID}`;\n    if (!result.hasOwnProperty(StopKey)) {\n      result[StopKey] = [];\n    }\n    result[StopKey].push(processedItem);\n  }\n  return result;\n}\n\ninterface FormattedBusStatus {\n  onStop: boolean;\n  situation: string;\n  text: string;\n}\n\ninterface FormattedBusPosition {\n  longitude: number;\n  latitude: number;\n}\n\nexport function parseCarType(CarType: '0' | '1' | '2' | '3'): '一般' | '低底盤' | '大復康巴士' | '狗狗友善專車' | '未知類型' {\n  let type = '';\n  switch (CarType) {\n    case '0':\n      type = '一般';\n      break;\n    case '1':\n      type = '低底盤';\n      break;\n    case '2':\n      type = '大復康巴士';\n      break;\n    case '3':\n      type = '狗狗友善專車';\n      break;\n    default:\n      type = '未知類型';\n  }\n  return type;\n}\n\nexport function parseCarOnStop(CarOnStop: '0' | '1'): string {\n  let onStop = '';\n  switch (CarOnStop) {\n    case '0':\n      onStop = '離站';\n      break;\n    case '1':\n      onStop = '進站';\n      break;\n    default:\n      onStop = '未知狀態'; // Handle unexpected values if necessary\n  }\n  return onStop;\n}\n\nexport function parseBusStatus(BusStatus: '0' | '1' | '2' | '3' | '4' | '5' | '99'): string {\n  let situation = '';\n  switch (BusStatus) {\n    case '0':\n      situation = '正常';\n      break;\n    case '1':\n      situation = '車禍';\n      break;\n    case '2':\n      situation = '故障';\n      break;\n    case '3':\n      situation = '塞車';\n      break;\n    case '4':\n      situation = '緊急求援';\n      break;\n    case '5':\n      situation = '加油';\n      break;\n    case '99':\n      situation = '非營運狀態';\n      break;\n    default:\n      situation = '未知狀態'; // Handle unexpected values if necessary\n  }\n  return situation;\n}\n\nexport interface FormattedBus {\n  type: '一般' | '低底盤' | '大復康巴士' | '狗狗友善專車' | '未知類型';\n  carNumber: string;\n  status: FormattedBusStatus;\n  RouteName: string;\n  onThisRoute: boolean;\n  index: number;\n  position: FormattedBusPosition;\n}\n\nexport function formatBus(batchFoundBus: BatchFoundBus): FormattedBus {\n  const result = {} as FormattedBus;\n\n  const CarType = batchFoundBus.CarType;\n  const type = parseCarType(CarType);\n  result.type = type;\n\n  const CarOnStop = batchFoundBus.CarOnStop;\n  const onStop = parseCarOnStop(CarOnStop);\n\n  const BusStatus = batchFoundBus.BusStatus;\n  const situation = parseBusStatus(BusStatus);\n\n  result.carNumber = batchFoundBus.BusID;\n  result.status = {\n    onStop: onStop,\n    situation: situation,\n    text: `${onStop} | ${situation}`\n  };\n  result.RouteName = batchFoundBus.RouteName;\n  result.onThisRoute = batchFoundBus.onThisRoute;\n  result.index = batchFoundBus.index;\n  result.position = batchFoundBus.position;\n  return result;\n}\n","import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface RouteItem {\n  providerId: number;\n  providerName: string;\n  nameZh: string; // name in Chinese\n  nameEn: string; // name in English\n  aliasName: string; // another name in Chinese\n  pathAttributeId: number;\n  pathAttributeNId: string;\n  pathAttributeName: string; // another name in Chinese\n  pathAttributeEname: string; // another name in English\n  buildPeriod: '1' | '2' | '3' | '9' | '10';\n  departureZh: string; // departure stop name in Chinese\n  destinationZh: string; // destination stop name in Chinese\n  departureEn: string; // departure stop name in English\n  destinationEn: string; // destination stop name in English\n  goFirstBusTime: string; // time code (hhmm)\n  goLastBusTime: string;\n  backFirstBusTime: string;\n  backLastBusTime: string;\n  offPeakHeadway: string; // time code (hhmm or mm)\n  busTimeDesc: string;\n  roadMapUrl: string;\n  headwayDesc: string;\n  holidayGoFirstBusTime: string;\n  holidayBackFirstBusTime: string;\n  holidayBackLastBusTime: string;\n  holidayGoLastBusTime: string;\n  holidayBusTimeDesc: string;\n  realSequence: string; // number in string\n  holidayHeadwayDesc: string;\n  holidayOffPeakHeadway: string;\n  holidayPeakHeadway: string;\n  segmentBufferEn: string;\n  ticketPriceDescriptionZh: string;\n  ticketPriceDescriptionEn: string;\n  peakHeadway: string;\n  ttiaPathId: string;\n  segmentBufferZh: string;\n  distance: string;\n  NId: string;\n  Id: number; // RouteID\n  routeType: string;\n}\n\nexport type Route = Array<RouteItem>;\n\nexport interface SimplifiedRouteItem {\n  pd: number;\n  n: string;\n  pid: Array<number>;\n  dep: string;\n  des: string;\n  id: number;\n}\n\nexport type SimplifiedRoute = { [key: string]: SimplifiedRouteItem };\n\nlet RouteAPIVariableCache_available: boolean = false;\nlet RouteAPIVariableCache_data: object = {};\n\nasync function simplifyRoute(Route: Route): Promise<SimplifiedRoute> {\n  const worker = new Worker(new URL('./simplifyRoute-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(Route); // Send data to the worker\n  });\n\n  return result;\n}\n\nexport async function getRoute(requestID: string, simplify: boolean = true): Promise<SimplifiedRoute | Route> {\n  async function getData() {\n    const apis = [\n      [0, 10],\n      [1, 10]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getRoute_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n  if (simplify === false) {\n    return await getData();\n  }\n  const cacheTimeToLive = 60 * 60 * 24 * 1 * 1000;\n  const cacheKey = 'bus_route_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    const simplified_result = await simplifyRoute(result);\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(simplified_result));\n    if (!RouteAPIVariableCache_available) {\n      RouteAPIVariableCache_available = true;\n      RouteAPIVariableCache_data = simplified_result;\n    }\n    return simplified_result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      const simplified_result = await simplifyRoute(result);\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(simplified_result));\n      if (!RouteAPIVariableCache_available) {\n        RouteAPIVariableCache_available = true;\n        RouteAPIVariableCache_data = simplified_result;\n      }\n      return simplified_result;\n    } else {\n      if (!RouteAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        RouteAPIVariableCache_available = true;\n        RouteAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getRoute_0', 0, true);\n      setDataReceivingProgress(requestID, 'getRoute_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return RouteAPIVariableCache_data;\n    }\n  }\n}\n","import { pakoInflate } from '../../tools/pako-inflate/index';\nimport { timeStampToNumber } from '../../tools/time';\nimport { recordDataUsage } from '../analytics/data-usage/index';\n\ntype FetchTaskRequest = [resolve: Function, reject: Function, requestID: string, tag: string];\n\ninterface FetchTask {\n  processing: boolean;\n  requests: Array<FetchTaskRequest>;\n  cached: boolean;\n  timestamp: number;\n  result: any;\n}\n\ntype FetchTasks = { [url: string]: FetchTask };\n\nconst tasks: FetchTasks = {};\nconst TTL = 5000;\n\nexport async function fetchData(url: string, requestID: string, tag: string, fileType: 'json' | 'xml'): Promise<object> {\n  discardExpiredFetchTasks();\n  const FetchError = new Error('FetchError');\n\n  // Check concurrency\n  if (tasks.hasOwnProperty(url)) {\n    if (tasks[url].processing) {\n      return await new Promise((resolve, reject) => {\n        tasks[url].requests.push([resolve, reject, requestID, tag]);\n      });\n    } else if (tasks[url].cached) {\n      if (new Date().getTime() - tasks[url].timestamp <= TTL) {\n        return tasks[url].result;\n      }\n    }\n  } else {\n    tasks[url] = {\n      processing: true,\n      requests: [],\n      cached: false,\n      timestamp: -1,\n      result: null\n    };\n  }\n\n  // Fetch data\n  const response = await fetch(url);\n  if (!response.ok) {\n    setDataReceivingProgress(requestID, tag, 0, true);\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  const contentLength = parseInt(String(response.headers.get('content-length')));\n  const reader = response.body.getReader();\n  const chunks = [];\n\n  // Loop to read chunks\n  let receivedLength = 0;\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    chunks.push(value);\n    receivedLength += value.length;\n    const progress = receivedLength / contentLength;\n    setDataReceivingProgress(requestID, tag, progress, false);\n    for (const request of tasks[url].requests) {\n      setDataReceivingProgress(request[2], request[3], progress, false);\n    }\n  }\n\n  // Concatenate all the chunks into a single Uint8Array\n  const uint8Array = new Uint8Array(receivedLength);\n  let position = 0;\n  for (const chunk of chunks) {\n    uint8Array.set(chunk, position);\n    position += chunk.length;\n  }\n\n  // Create a blob from the concatenated Uint8Array\n  const blob = new Blob([uint8Array], { type: 'application/gzip' });\n  const arrayBuffer = await blob.arrayBuffer();\n  const inflatedData = await pakoInflate(arrayBuffer);\n\n  let result;\n  switch (fileType) {\n    case 'json':\n      if (/^<!doctype html>/.test(inflatedData)) {\n        result = await fetchData(url.replace('https://tcgbusfs.blob.core.windows.net/', 'https://erichsia7.github.io/bus-alternative-static-apis/'), requestID, tag, fileType);\n      } else {\n        result = JSON.parse(inflatedData);\n      }\n      break;\n    case 'xml':\n      result = inflatedData;\n      break;\n    default:\n      break;\n  }\n  const now = new Date();\n  await recordDataUsage(contentLength, now);\n  if (result) {\n    tasks[url].result = result;\n    tasks[url].cached = true;\n    tasks[url].timestamp = now + TTL;\n    const progress = receivedLength / contentLength;\n    let request = tasks[url].requests.shift();\n    while (request) {\n      request[0](result);\n      setDataReceivingProgress(request[2], request[3], progress, false);\n      request = tasks[url].requests.shift();\n    }\n    tasks[url].processing = false;\n    return result;\n  } else {\n    let request = tasks[url].requests.shift();\n    while (request) {\n      request[1](FetchError);\n      setDataReceivingProgress(request[2], request[3], 0, true);\n      request = tasks[url].requests.shift();\n    }\n    tasks[url].processing = false;\n    throw FetchError;\n  }\n}\n\nfunction discardExpiredFetchTasks(): void {\n  const now = new Date().getTime();\n  for (const url in tasks) {\n    if (!tasks[url].processing) {\n      if (tasks[url].cached && now - tasks[url].timestamp > TTL) {\n        delete tasks[url];\n      } else if (tasks[url].timestamp === -1) {\n        delete tasks[url];\n      }\n    }\n  }\n}\n\nexport type DataReceivingProgress = {\n  [requestID: string]: {\n    [tag: string]: {\n      expel: boolean;\n      progress: number;\n      total: number;\n    };\n  };\n};\n\nconst dataReceivingProgress: DataReceivingProgress = {};\n\nexport function setDataReceivingProgress(requestID: string, tag: string, progress: number, expel: boolean): void {\n  if (!dataReceivingProgress.hasOwnProperty(requestID)) {\n    dataReceivingProgress[requestID] = {};\n  }\n  const tagKey = `t_${tag}`;\n  if (dataReceivingProgress[requestID].hasOwnProperty(tagKey)) {\n    if (expel) {\n      dataReceivingProgress[requestID][tagKey].expel = true;\n    } else {\n      dataReceivingProgress[requestID][tagKey].expel = false;\n      dataReceivingProgress[requestID][tagKey].progress = progress;\n    }\n    broadcastDataReceivingProgress(requestID, 'run');\n  } else {\n    dataReceivingProgress[requestID][tagKey] = { expel: false, progress: progress, total: 1 };\n    broadcastDataReceivingProgress(requestID, 'start');\n  }\n}\n\nexport function getDataReceivingProgress(requestID: string): number {\n  if (dataReceivingProgress.hasOwnProperty(requestID)) {\n    if (typeof dataReceivingProgress[requestID] === 'object') {\n      let total: number = 0;\n      let received: number = 0;\n      for (const key in dataReceivingProgress[requestID]) {\n        if (!dataReceivingProgress[requestID][key].expel) {\n          total += dataReceivingProgress[requestID][key].total;\n          received += dataReceivingProgress[requestID][key].progress;\n        }\n      }\n      const progress = Math.min(Math.max(received / total, 0), 1);\n      return progress === Infinity || isNaN(progress) ? 1 : progress;\n    }\n  }\n  return 1;\n}\n\nexport function deleteDataReceivingProgress(requestID: string): void {\n  if (dataReceivingProgress.hasOwnProperty(requestID)) {\n    delete dataReceivingProgress[requestID];\n    broadcastDataReceivingProgress(requestID, 'end');\n  }\n}\n\nexport interface DataReceivingProgressEventDict {\n  target: string;\n  stage: 'start' | 'run' | 'end';\n  progress: number;\n}\n\nexport type DataReceivingProgressEvent = CustomEvent<DataReceivingProgressEventDict>;\n\nexport function broadcastDataReceivingProgress(requestID: string, stage: DataReceivingProgressEventDict['stage']): void {\n  const eventDict: DataReceivingProgressEventDict = {\n    target: requestID,\n    stage: stage,\n    progress: getDataReceivingProgress(requestID)\n  };\n  const event = new CustomEvent(requestID, { detail: eventDict });\n  document.dispatchEvent(event);\n}\n\nexport type DataUpdateTime = { [key: string]: number };\n\nexport const dataUpdateTime: DataUpdateTime = {};\n\nexport function setDataUpdateTime(requestID: string, timeStamp: string | number): void {\n  if (!dataUpdateTime.hasOwnProperty(requestID)) {\n    dataUpdateTime[requestID] = 0;\n  }\n  let timeNumber = 0;\n  if (typeof timeStamp === 'string') {\n    timeNumber = timeStampToNumber(timeStamp);\n  }\n  if (timeNumber > dataUpdateTime[requestID]) {\n    dataUpdateTime[requestID] = timeNumber;\n  }\n}\n\nexport function getDataUpdateTime(requestID: string): number {\n  if (dataUpdateTime.hasOwnProperty(requestID)) {\n    return dataUpdateTime[requestID] * 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function deleteDataUpdateTime(requestID: string): void {\n  if (dataUpdateTime.hasOwnProperty(requestID)) {\n    delete dataUpdateTime[requestID];\n  }\n}\n","import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nlet SemiTimetableAPIVariableCache_available: boolean = false;\nlet SemiTimetableAPIVariableCache_data: object = {};\n\nexport async function getSemiTimeTable(requestID: string): Promise<object> {\n  async function getData() {\n    const apis = [\n      [0, 12],\n      [1, 12]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getSemiTimeTable_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 14 * 1000;\n  const cacheKey = 'bus_semi_timetable_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(result));\n    if (!SemiTimetableAPIVariableCache_available) {\n      SemiTimetableAPIVariableCache_available = true;\n      SemiTimetableAPIVariableCache_data = result;\n    }\n    return result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(result));\n      return result;\n    } else {\n      if (!SemiTimetableAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        SemiTimetableAPIVariableCache_available = true;\n        SemiTimetableAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getSemiTimeTable_0', 0, true);\n      setDataReceivingProgress(requestID, 'getSemiTimeTable_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return SemiTimetableAPIVariableCache_data;\n    }\n  }\n}\n","import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nlet TimetableAPIVariableCache_available: boolean = false;\nlet TimetableAPIVariableCache_data: object = {};\n\nexport async function getTimeTable(requestID: string): Promise<object> {\n  async function getData() {\n    const apis = [\n      [0, 14],\n      [1, 14]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getTimeTable_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 14 * 1000;\n  const cacheKey = 'bus_timetable_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(result));\n    if (!TimetableAPIVariableCache_available) {\n      TimetableAPIVariableCache_available = true;\n      TimetableAPIVariableCache_data = result;\n    }\n    return result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(result));\n      return result;\n    } else {\n      if (!TimetableAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        TimetableAPIVariableCache_available = true;\n        TimetableAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getTimeTable_0', 0, true);\n      setDataReceivingProgress(requestID, 'getTimeTable_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return TimetableAPIVariableCache_data;\n    }\n  }\n}\n"],"names":["ProviderAPIVariableCache_available","ProviderAPIVariableCache_data","getProvider","_x","_getProvider","apply","arguments","_asyncToGenerator","requestID","getData","_getData","_step","result","_iterator","_createForOfIteratorHelper","map","e","url","getAPIURL","s","n","done","api","value","data","fetchData","concat","BusInfo","setDataUpdateTime","EssentialInfo","UpdateTime","err","f","cacheKey","cacheTimestamp","lfGetItem","lfSetItem","Date","getTime","JSON","stringify","parseInt","cache","parse","setDataReceivingProgress","StopAPIVariableCache_available","StopAPIVariableCache_data","simplifyStop","_simplifyStop","array","worker","Worker","URL","Promise","resolve","reject","onmessage","terminate","onerror","message","postMessage","getStop","_x2","_getStop","simplified_result","SegmentBuffersAPIVariableCache_available","SegmentBuffersAPIVariableCache_data","extractSegmentBuffers","_extractSegmentBuffers","xml","simplifySegmentBuffers","_simplifySegmentBuffers","getSegmentBuffers","_x3","_getSegmentBuffers","extractedResult","simplifiedResult","parseEstimateTime","EstimateTime","mode","time","code","text","formatTime","parseTimeCode","codeLength","length","hours","minutes","substring","type","min","max","number1","number2","Math","number","batchFindBusesForRoute","BusEvent","BusData","Route","RouteID","PathAttributeId","BusDataObj","BusDataItem","BusID","_step2","_iterator2","BusEventItem","processedItem","CarType","BusStatus","CarOnStop","thisRouteID","thisBusID","String","isOnThisRoute","index","indexOf","charCodeAt","pow","onThisRoute","thisBusData","hasOwnProperty","position","latitude","parseFloat","Latitude","longitude","Longitude","searchedRoute","isRouteSearched","key","thisRouteItem","pid","RouteName","id","StopKey","StopID","push","batchFindBusesForLocation","StopIDList","_step3","_iterator3","_step4","_iterator4","thisStopID","parseCarType","parseCarOnStop","onStop","parseBusStatus","situation","formatBus","batchFoundBus","carNumber","status","RouteAPIVariableCache_available","RouteAPIVariableCache_data","simplifyRoute","_simplifyRoute","getRoute","_getRoute","undefined","tasks","TTL","_x4","_fetchData","tag","fileType","now","processing","cached","timestamp","discardExpiredFetchTasks","FetchError","Error","requests","response","fetch","ok","contentLength","headers","get","reader","body","getReader","chunks","receivedLength","_yield$reader$read","read","progress","request","uint8Array","Uint8Array","_i","_chunks","chunk","set","blob","Blob","arrayBuffer","inflatedData","pakoInflate","test","replace","recordDataUsage","shift","dataReceivingProgress","expel","tagKey","broadcastDataReceivingProgress","total","getDataReceivingProgress","_typeof","received","Infinity","isNaN","deleteDataReceivingProgress","stage","eventDict","target","event","CustomEvent","detail","document","dispatchEvent","dataUpdateTime","timeStamp","timeNumber","timeStampToNumber","getDataUpdateTime","deleteDataUpdateTime","SemiTimetableAPIVariableCache_available","SemiTimetableAPIVariableCache_data","getSemiTimeTable","_getSemiTimeTable","TimetableAPIVariableCache_available","TimetableAPIVariableCache_data","getTimeTable","_getTimeTable"],"ignoreList":[],"sourceRoot":""}