{"version":3,"file":"412f2532b92ce7f36bde.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,MAAO,GAAIH,GACQ,iBAAZC,QACdA,QAAa,IAAID,IAEjBD,EAAU,IAAIC,GACf,CATD,CASGK,KAAM,I,whCCPTA,KAAKC,UAAY,SAAUC,GACzB,IAAMC,EAIR,SAA2BC,GACzB,IAUIC,EAEoBC,EAZlBC,EAAmB,oBACnBC,EAAiB,sBACjBC,EAAc,yCAEdC,EAAQN,EAAIO,MAAM,OAElBR,EAAS,GACXS,GAAmB,EACnBC,GAAuB,EACvBC,EAAiB,GACJC,EAAAC,EAEEN,GAAK,IAAxB,IAAAK,EAAAE,MAAAX,EAAAS,EAAAG,KAAAC,MAA0B,KAAfC,EAAId,EAAAe,MACPC,EAAkBf,EAAiBgB,KAAKH,GACxCI,EAAgBhB,EAAee,KAAKH,GACpCK,EAAahB,EAAYc,KAAKH,GACpC,GAAIE,IAAoBG,IAAeD,EAIrC,OAFAV,EAAiBM,EAAKM,MAAMnB,GAAkB,GAC9CF,EAAe,KACPS,GAQN,IAAK,YACHX,EAAOwB,KAAK,CAAC,GACbf,IACA,MACF,IAAK,cACET,EAAOS,GAAiBgB,eAAe,iBAC1CzB,EAAOS,GAA8B,YAAI,GACzCC,GAAuB,GAEzB,MACF,IAAK,aACHV,EAAOS,GAA8B,YAAEe,KAAK,CAAC,GAC7Cd,IAOFS,GAAmBG,IAAeD,IAEpCV,EAAiBM,EAAKM,MAAMjB,GAAa,GACzCJ,EAAee,EAAKM,MAAMjB,GAAa,GAChB,YAAnBK,EACFX,EAAOS,GAA0B,QAAIiB,SAASxB,EAAc,IAChC,iBAAnBS,GAAwD,sBAAnBA,GAA6D,cAAnBA,IACxFX,EAAOS,GAA8B,YAAEC,GAAqBC,GAAkBe,SAASxB,EAAc,KAU3G,CAAC,OAAAyB,GAAAf,EAAAb,EAAA4B,EAAA,SAAAf,EAAAgB,GAAA,CAED,OAAO5B,CACT,CAxEiB6B,CAAkB9B,EAAE+B,MACnCjC,KAAKkC,YAAY/B,EACnB,E","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/./src/data/apis/getSegmentBuffers/extractSegmentBuffers-worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","import { SegmentBuffers } from './index';\n\nself.onmessage = function (e) {\n  const result = processWorkerTask(e.data);\n  self.postMessage(result); // Send the result back to the main thread\n};\n\nfunction processWorkerTask(xml: string): SegmentBuffers {\n  const startingTagRegex = /^\\s*<([a-z_]*)>/im;\n  const endingTagRegex = /^\\s*<\\/([a-z_]*)>/im;\n  const inlineRegex = /^\\s*<([a-z_]*)>([^<>]*)<\\/([a-z_]*)>/im;\n\n  const lines = xml.split(/\\n/m);\n\n  const result = [];\n  let resultLastIndex = -1;\n  let bufferZoneLastIndex = -1;\n  let currentTagName = '';\n  var currentValue;\n\n  for (const line of lines) {\n    const startingTagTest = startingTagRegex.test(line);\n    const endingTagTest = endingTagRegex.test(line);\n    const inlineTest = inlineRegex.test(line);\n    if (startingTagTest && !inlineTest && !endingTagTest) {\n      // starting tag\n      currentTagName = line.match(startingTagRegex)[1];\n      currentValue = null;\n      switch (currentTagName) {\n        // To prevent the second concatenated dataset erasing the first one, ignore RouteFares\n        /*\n        case 'RouteFares':\n          result = []; // [NOTE] L15: const\n          resultLastIndex = -1;\n          break;\n        */\n        case 'RouteFare':\n          result.push({});\n          resultLastIndex++;\n          break;\n        case 'BufferZones':\n          if (!result[resultLastIndex].hasOwnProperty('BufferZones')) {\n            result[resultLastIndex]['BufferZones'] = [];\n            bufferZoneLastIndex = -1;\n          }\n          break;\n        case 'BufferZone':\n          result[resultLastIndex]['BufferZones'].push({});\n          bufferZoneLastIndex++;\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (startingTagTest && inlineTest && !endingTagTest) {\n      // inline tag\n      currentTagName = line.match(inlineRegex)[1];\n      currentValue = line.match(inlineRegex)[2];\n      if (currentTagName === 'RouteID') {\n        result[resultLastIndex]['RouteID'] = parseInt(currentValue, 10);\n      } else if (currentTagName === 'OriginStopID' || currentTagName === 'DestinationStopID' || currentTagName === 'Direction') {\n        result[resultLastIndex]['BufferZones'][bufferZoneLastIndex][currentTagName] = parseInt(currentValue, 10);\n      }\n    }\n    /*\n    if (!startingTagTest && !inlineTest && endingTagTest) {\n      // ending tag\n      currentTagName = line.match(endingTagRegex)[1];\n      currentValue = null\n    }\n    */\n  }\n\n  return result;\n}\n"],"names":["root","factory","exports","module","define","amd","self","onmessage","e","result","xml","currentValue","_step","startingTagRegex","endingTagRegex","inlineRegex","lines","split","resultLastIndex","bufferZoneLastIndex","currentTagName","_iterator","_createForOfIteratorHelper","s","n","done","line","value","startingTagTest","test","endingTagTest","inlineTest","match","push","hasOwnProperty","parseInt","err","f","processWorkerTask","data","postMessage"],"ignoreList":[],"sourceRoot":""}