{"version":3,"file":"2d93b40fe2e789440e94.js","mappings":"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","sources":["webpack://bus/./src/tools/address.ts","webpack://bus/./src/tools/elements.ts","webpack://bus/./src/tools/graphic.ts","webpack://bus/./src/tools/convert.ts","webpack://bus/./src/tools/array.ts","webpack://bus/./src/tools/labels.ts","webpack://bus/./src/tools/cardinal-direction.ts","webpack://bus/./src/tools/index.ts","webpack://bus/./src/tools/levenshtein.ts"],"sourcesContent":["import { areItemsDifferent } from './array';\nimport { hasOwnProperty } from './index';\nimport { generateLetterLabels } from './labels';\n\ninterface AddressPart {\n  suffixes?: string;\n  key: keyof ParsedAddress;\n  process: (e: Array<string> | null) => Array<string> | Array<number> | null;\n  type: number;\n}\n\nexport interface ParsedAddress {\n  city: Array<string>;\n  district: Array<string>;\n  area: Array<string>;\n  road: Array<string>;\n  road_section: Array<number>;\n  alley: Array<number>;\n  alley_branch: Array<number>;\n  doorplate: Array<number>;\n  floornumber: Array<string>;\n  exit: Array<string>;\n  direction: Array<string>;\n  [key: string]: Array<string> | Array<number> | null;\n}\n\ninterface FeatureCounts {\n  [key: string]: { count: number; chars: string; index: number };\n}\n\nexport function mergeAddressesIntoOne(addresses: Array<string>): ParsedAddress | string {\n  const parts: Array<AddressPart> = [\n    {\n      suffixes: '市',\n      key: 'city',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '區',\n      key: 'district',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '鄉鎮村里',\n      key: 'area',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '路街道',\n      key: 'road',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.replaceAll(/[\\(\\)\\（\\）]/gim, '').trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '段',\n      key: 'road_section',\n      process: function (e) {\n        var toNumber = function (char) {\n          switch (char) {\n            case '一':\n              return 1;\n              break;\n            case '二':\n              return 2;\n              break;\n            case '三':\n              return 3;\n              break;\n            case '四':\n              return 4;\n              break;\n            case '五':\n              return 5;\n              break;\n            case '六':\n              return 6;\n              break;\n            case '七':\n              return 7;\n              break;\n            case '八':\n              return 8;\n              break;\n            case '九':\n              return 9;\n              break;\n            case '十':\n              return 10;\n              break;\n          }\n          if (!isNaN(parseInt(char))) {\n            return parseInt(char);\n          }\n          return 0;\n        };\n        var len = String(e).length;\n        var numbers = [];\n        for (let i = 0; i < len; i++) {\n          var p = toNumber(String(e).charAt(i));\n          if (p === 10) {\n            if (numbers.length > 0) {\n              numbers = [numbers.reduce((a, b) => a + b, 0) * 10];\n            }\n          } else {\n            numbers = [numbers.reduce((a, b) => a + b, 0) + p];\n          }\n        }\n        return numbers;\n      },\n      type: 0\n    },\n    {\n      suffixes: '巷',\n      key: 'alley',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return parseInt(t.trim().replaceAll(/[巷]/gim));\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '弄',\n      key: 'alley_branch',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return parseInt(t.trim().replaceAll(/[弄]/gim));\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '號',\n      key: 'doorplate',\n      process: function (e) {\n        var numbers = String(e).match(/[0-9]+/gim);\n        numbers =\n          numbers?.map((n) => {\n            if (n === null) {\n              return null;\n            } else {\n              return parseInt(n);\n            }\n          }) || null;\n        return numbers;\n      },\n      type: 0\n    },\n    {\n      suffixes: '樓',\n      key: 'floornumber',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      key: 'exit',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 2\n    },\n    {\n      key: 'direction',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim().replace(/[往向]/gim, '');\n          });\n        }\n      },\n      type: 1\n    }\n  ];\n\n  function parseAddress(address: string): object {\n    function regex(suffixes, type) {\n      if (type === 0) {\n        return new RegExp(`([^市區鄉鎮村里路段街道巷弄號樓與]+[${suffixes}])`, 'gmi');\n      }\n      if (type === 1) {\n        return new RegExp(`([往向]+[東南西北])`, 'gmi');\n      }\n      if (type === 2) {\n        return new RegExp(`([0-9]+[號]出口)`, 'gmi');\n      }\n    }\n    var result = {};\n    for (var part of parts) {\n      var r = regex(part?.suffixes, part.type);\n      result[part.key] = part.process(String(address).match(r));\n    }\n    return result;\n  }\n\n  function mergeAddresses(addresses: Array<string>): object {\n    var result = {};\n    for (var address of addresses) {\n      var parsedAddress = parseAddress(address);\n      for (var part of parts) {\n        if (!hasOwnProperty(result, part.key)) {\n          result[part.key] = [];\n        }\n        result[part.key] = result[part.key].concat(parsedAddress[part.key]);\n      }\n    }\n    for (var key in result) {\n      result[key] = Array.from(new Set(result[key]))\n        .filter((e) => (e ? true : false))\n        .sort(function (a, b) {\n          if (typeof a === 'number' && typeof b === 'number') {\n            return a - b;\n          } else {\n            return String(a).charCodeAt(0) - String(b).charCodeAt(0);\n          }\n        });\n    }\n    return result;\n  }\n  return mergeAddresses(addresses);\n}\n\nexport function addressToString(address: ParsedAddress): string {\n  return `${address.city.join('')}${address.district.join('')}${address.road.join('、')}${\n    address.road_section.sort(function (a, b) {\n      return a - b;\n    }).length > 0\n      ? address.road_section.join('、') + '段'\n      : ''\n  }${\n    address.alley.length > 0\n      ? address.alley\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '巷'\n      : ''\n  }${\n    address.alley_branch.length > 0\n      ? address.alley_branch\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '弄'\n      : ''\n  }${\n    address.doorplate.length > 0\n      ? address.doorplate\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '號'\n      : ''\n  }${address.floornumber.length > 0 ? address.floornumber.join('、') + '樓' : ''}${address.direction.length > 0 ? '（朝' + address.direction.join('、') + '）' : ''}`;\n}\n\nexport function extractCommonFeaturesFromAddresses(addresses: Array<string>): string {\n  // Create an object to store feature occurrences\n  const featureCounts: { [key: string]: { count: number; chars: string; index: number } } = {};\n\n  // Create a set to store unique simplified addresses\n  const simplifiedSet = new Set<string>();\n\n  // Iterate through each address\n  for (const address of addresses) {\n    // Extract common features by splitting the address\n    const features = String(address)\n      .split('')\n      .filter((feature) => feature.trim() !== '');\n\n    // Join the extracted features to create a simplified address\n    const simplifiedAddress = features.join('');\n\n    // Add the simplified address to the set\n    simplifiedSet.add(simplifiedAddress);\n\n    // Count occurrences of each feature\n    let index = 0;\n    for (const feature of features) {\n      // Check if the feature is a digit\n      if (!isNaN(parseInt(feature))) {\n        // Create a key for the digit feature\n        const digitKey = `digit_${index}_${feature.charCodeAt(0)}`;\n        featureCounts[digitKey] = {\n          count: (featureCounts[digitKey]?.count || 0) + 1,\n          chars: feature,\n          index: index\n        };\n      } else {\n        // Create a key for non-digit features\n        const featureKey = `chars_${index}_${feature.charCodeAt(0)}`;\n        featureCounts[featureKey] = {\n          count: (featureCounts[featureKey]?.count || 0) + 1,\n          chars: feature,\n          index: index\n        };\n      }\n      index += 1;\n    }\n  }\n\n  // Set threshold and limit for filtering features\n  const threshold = addresses.length * 0.6;\n  const limit = addresses.length * 1;\n\n  // Convert the feature counts object to an array of [feature, count] pairs\n  const sortedFeatures = Object.entries(featureCounts)\n    .filter((pair) => threshold <= pair[1].count && pair[1].count <= limit)\n    .sort((a, b) => a[1].index - b[1].index);\n\n  // Extract the features from the sorted array\n  const commonFeatures = sortedFeatures.map((pair) => pair[1].chars);\n\n  return commonFeatures.join('');\n}\n\nexport function generateLabelFromAddresses(addresses: Array<ParsedAddress>): Array<string> {\n  const result = [];\n  const filledProperties = {};\n  for (const address of addresses) {\n    for (const key in address) {\n      if (!hasOwnProperty(filledProperties, key)) {\n        filledProperties[key] = 0;\n      }\n      if (address[key].length > 0) {\n        filledProperties[key] = filledProperties[key] + 1;\n      }\n    }\n  }\n  let commonProperties = Object.entries(filledProperties)\n    .map((property) => {\n      return { key: property[0], value: property[1] };\n    })\n    .filter((e) => {\n      return e.value === addresses.length ? true : false;\n    })\n    .sort(function (a, b) {\n      return a.value - b.value;\n    });\n  if (commonProperties.length > 0) {\n    for (const commonProperty of commonProperties) {\n      let components = [];\n      let len = -Infinity;\n      for (const address of addresses) {\n        const component = address[commonProperty.key].join('');\n        components.push(component);\n        const componentLen = component.length;\n        if (componentLen > len) {\n          len = componentLen;\n        }\n      }\n      if (areItemsDifferent(components)) {\n        result.push({ components: components, len: len });\n      }\n    }\n  }\n\n  if (result.length > 0) {\n    result.sort(function (a, b) {\n      return a.len - b.len;\n    });\n    return result[0].components;\n  } else {\n    const addressesLength = addresses.length;\n    return generateLetterLabels(addressesLength);\n  }\n}\n","export function documentQuerySelector(selectorExpression: string): HTMLElement {\n  return document.querySelector(selectorExpression);\n}\n\nexport function documentQuerySelectorAll(selectorExpression: string): NodeListOf<HTMLElement> {\n  return document.querySelectorAll(selectorExpression);\n}\n\nexport function elementQuerySelector(element: HTMLElement, selectorExpression: string): HTMLElement {\n  return element.querySelector(selectorExpression);\n}\n\nexport function elementQuerySelectorAll(element: HTMLElement, selectorExpression: string): NodeListOf<HTMLElement> {\n  return element.querySelectorAll(selectorExpression);\n}\n\nexport function getElementsBelow(referenceElement: HTMLElement, className: string): Array<HTMLElement> {\n  const elements = [];\n  let sibling = referenceElement.nextElementSibling;\n\n  while (sibling) {\n    if (sibling.classList.contains(className)) {\n      elements.push(sibling);\n    }\n    sibling = sibling.nextElementSibling;\n  }\n\n  return elements;\n}\n\nexport function documentCreateDivElement(): HTMLDivElement {\n  return document.createElement('div');\n}\n","export function getTextWidth(text: string, weight: number, size: string, fontFamily: string): number {\n  const canvas: HTMLCanvasElement = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  const font: string = `${weight} ${size} ${fontFamily}`;\n  context.font = font;\n  return context.measureText(text).width;\n}\n\nexport function getTextHeight(text: string, weight: number, size: string, fontFamily: string): number {\n  const canvas: HTMLCanvasElement = getTextHeight.canvas || (getTextHeight.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  const font: string = `${weight} ${size} ${fontFamily}`;\n  context.font = font;\n  context.textBaseline = 'top';\n  return context.measureText(text).actualBoundingBoxDescent;\n}\n\nexport function getTextBoundingBox(text: string, weight: number, size: string, fontFamily: string): [topOffset: number, width: number, height: number] {\n  const canvas: HTMLCanvasElement = getTextBoundingBox.canvas || (getTextBoundingBox.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  const font: string = `${weight} ${size} ${fontFamily}`;\n  context.font = font;\n  const measurement = context.measureText(text);\n  const topOffset = Math.max(Math.abs(measurement.emHeightAscent || 0), Math.abs(measurement.hangingBaseline || 0), Math.abs(measurement.fontBoundingBoxAscent || 0), Math.abs(measurement.actualBoundingBoxAscent || 0));\n  return [topOffset, measurement.width, measurement.fontBoundingBoxAscent + measurement.fontBoundingBoxDescent];\n}\n\ninterface CornerRadius {\n  tl: number;\n  tr: number;\n  br: number;\n  bl: number;\n}\n\nexport function drawRoundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | CornerRadius, fill: string): void {\n  // If radius is a single value, treat it as the same for all corners\n  if (typeof radius === 'number') {\n    radius = { tl: radius, tr: radius, br: radius, bl: radius };\n  } else {\n    // Set defaults if individual radii are not provided\n    radius = {\n      tl: radius.tl || 0,\n      tr: radius.tr || 0,\n      br: radius.br || 0,\n      bl: radius.bl || 0\n    };\n  }\n\n  // Start path\n  ctx.beginPath();\n  // Move to the top-left corner, accounting for the top-left radius\n  ctx.moveTo(x + radius.tl, y);\n  // Draw the top line, rounding the top-right corner\n  ctx.lineTo(x + width - radius.tr, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n  // Draw the right side, rounding the bottom-right corner\n  ctx.lineTo(x + width, y + height - radius.br);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n  // Draw the bottom side, rounding the bottom-left corner\n  ctx.lineTo(x + radius.bl, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n  // Draw the left side, rounding the top-left corner\n  ctx.lineTo(x, y + radius.tl);\n  ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n  // Complete the path\n  ctx.closePath();\n\n  ctx.fillStyle = fill;\n  ctx.fill(); // To fill the shape\n}\n\nexport function generateRoundedRectPath(x: number, y: number, width: number, height: number, radius: number | CornerRadius, inverted: boolean): Array<string> {\n  // Normalize the radius object\n  if (typeof radius === 'number') {\n    radius = { tl: radius, tr: radius, br: radius, bl: radius };\n  } else {\n    radius = {\n      tl: radius.tl || 0,\n      tr: radius.tr || 0,\n      br: radius.br || 0,\n      bl: radius.bl || 0\n    };\n  }\n  const { tl, tr, br, bl } = radius;\n  const command = [];\n  if (inverted) {\n    if (tl !== 0) {\n      command.push(`M${x} ${y + tl}`, `Q${x} ${y} ${x + tl} ${y}`, `H${x}`, `V${y + tl}`);\n    }\n    if (tr !== 0) {\n      command.push(`M${x + width - tr} ${y}`, `Q${x + width} ${y} ${x + width} ${y + tr}`, `V${y}`, `H${x + width - tr}`);\n    }\n    if (br !== 0) {\n      command.push(`M${x + width} ${y + height - br}`, `Q${x + width} ${y + height} ${x + width - br} ${y + height}`, `H${x + width}`, `V${y + height - br}`);\n    }\n    if (bl !== 0) {\n      command.push(`M${x + bl} ${y + height}`, `Q${x} ${y + height} ${x} ${y + height - bl}`, `V${y + height}`, `H${x + bl}`);\n    }\n  } else {\n    command.push(`M${x + tl} ${y}`, `H${x + width - tr}`, `Q${x + width} ${y} ${x + width} ${y + tr}`, `V${y + height - br}`, `Q${x + width} ${y + height} ${x + width - br} ${y + height}`, `H${x + bl}`, `Q${x} ${y + height} ${x} ${y + height - bl}`, `V${y + tl}`, `Q${x} ${y} ${x + tl} ${y}`);\n  }\n  return command;\n}\n","export function convertPositionsToDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6378.137;\n  const dLat = (lat2 * Math.PI) / 180 - (lat1 * Math.PI) / 180;\n  const dLon = (lon2 * Math.PI) / 180 - (lon1 * Math.PI) / 180;\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const d = R * c;\n  return d * 1000; // measured in meters\n}\n\nexport function convertBytes(contentLength: number): string {\n  const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  let i = 0;\n\n  while (contentLength >= 1000 && i < units.length - 1) {\n    contentLength /= 1000;\n    i++;\n  }\n\n  return `${Math.floor(contentLength * 100) / 100} ${units[i]}`;\n}\n\nexport function convertNumberToLetters(number: number): string {\n  let result = '';\n  while (number > 0) {\n    let remainder = (number - 1) % 26; // Adjust for 1-based indexing\n    let letter = String.fromCharCode(remainder + 65); // A=65 in ASCII\n    result = letter + result;\n    number = Math.floor((number - 1) / 26); // Update number for next iteration\n  }\n  return result;\n}\n","// Function to split data based on delta\n\n/**\n * Splits data into groups based on delta between consecutive elements.\n *\n * @param {Array<[number, number]>} data - Array of tuples where each tuple contains two numbers.\n * @returns {Array<Array<[number, number]>>} - Array of groups, each containing arrays of tuples.\n */\n\nexport function splitDataByDelta(data: Array<[number, number]>): Array<Array<[number, number]>> {\n  const result: Array<Array<[number, number]>> = [];\n  let currentGroup: Array<[number, number]> = [];\n\n  for (let i = 0; i < data.length; i++) {\n    if (i === 0 || data[i][0] - data[i - 1][0] > 0) {\n      if (currentGroup.length > 0) {\n        result.push(currentGroup);\n      }\n      currentGroup = [data[i]];\n    } else {\n      currentGroup.push(data[i]);\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    result.push(currentGroup);\n  }\n\n  return result;\n}\n\nexport function areItemsDifferent(arr: Array): boolean {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) {\n        return false; // Found a duplicate\n      }\n    }\n  }\n  return true; // No duplicates found\n}\n\n/**\n * Get common items from the two arrays\n * @param arrayA - The first array\n * @param arrayB - The second array\n * @returns An array of the common items\n */\n\nexport function getIntersection(arrayA: Array, arrayB: Array): Array {\n  let result = [];\n  if (arrayA.length <= arrayB.length) {\n    for (const item of arrayA) {\n      if (arrayB.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  } else {\n    for (const item of arrayB) {\n      if (arrayA.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  }\n  return result;\n}\n","import { CardinalDirection } from './cardinal-direction';\nimport { convertNumberToLetters } from './convert';\n\nexport function generateLetterLabels(quantity: number): Array<string> {\n  let result: Array<string> = [];\n  for (let i = 0; i < quantity; i++) {\n    result.push(`地點${convertNumberToLetters(i + 1)}`);\n  }\n  return result;\n}\n\nexport function generateDirectionLabels(cardinalDirections: Array<CardinalDirection>): Array<string> {\n  const result: Array<string> = [];\n  for (const cardinalDirection of cardinalDirections) {\n    result.push(`向${cardinalDirection.name}${cardinalDirection.symbol}`);\n  }\n  return result;\n}\n","import { MaterialSymbols } from '../interface/icons/material-symbols-type';\nimport { normalizeVector } from './math';\n\nexport type CardinalDirectionVector = [number, number];\n\nexport interface CardinalDirection {\n  vector: CardinalDirectionVector;\n  id: number;\n  name: string;\n  symbol: string;\n  icon: MaterialSymbols;\n}\n\nexport const UnknownCardinalDirection: CardinalDirection = {\n  vector: [0, 0],\n  id: -1,\n  name: '未知',\n  symbol: '?',\n  icon: 'explore'\n};\n\n// cardinal directions\nexport const NorthCardinalDirection: CardinalDirection = {\n  vector: [0, 1], // 90 degress\n  id: 0,\n  name: '北',\n  symbol: '↑',\n  icon: 'north'\n};\n\nexport const WestCardinalDirection: CardinalDirection = {\n  vector: [1, 0], // 0 degres\n  id: 1,\n  name: '東',\n  symbol: '→',\n  icon: 'east'\n};\n\nexport const SouthCardinalDirection: CardinalDirection = {\n  vector: [0, -1], // 270 degress\n  id: 2,\n  name: '南',\n  symbol: '↓',\n  icon: 'south'\n};\n\nexport const EastCardinalDirection: CardinalDirection = {\n  vector: [-1, 0], // 180 degress\n  id: 3,\n  name: '西',\n  symbol: '←',\n  icon: 'west'\n};\n\n// intercardinal directions\nconst NorthEastCardinalDirection: CardinalDirection = {\n  vector: [Math.SQRT1_2, Math.SQRT1_2], // 45 degrees\n  id: 4,\n  name: '東北',\n  symbol: '↗',\n  icon: 'north_east'\n};\n\nconst SouthEastCardinalDirection: CardinalDirection = {\n  vector: [Math.SQRT1_2, -Math.SQRT1_2], // 135 degrees\n  id: 5,\n  name: '東南',\n  symbol: '↘',\n  icon: 'south_east'\n};\n\nexport const SouthWestCardinalDirection: CardinalDirection = {\n  vector: [-Math.SQRT1_2, -Math.SQRT1_2], // 225 degrees\n  id: 6,\n  name: '西南',\n  symbol: '↙',\n  icon: 'south_west'\n};\n\nexport const NorthWestCardinalDirection: CardinalDirection = {\n  vector: [-Math.SQRT1_2, Math.SQRT1_2], // 315 degrees\n  id: 7,\n  name: '西北',\n  symbol: '↖',\n  icon: 'north_west'\n};\n\nexport function getCardinalDirectionFromVector(vector: [number, number]): CardinalDirection {\n  const directions: Array<CardinalDirection> = [UnknownCardinalDirection, NorthCardinalDirection, EastCardinalDirection, SouthCardinalDirection, WestCardinalDirection, NorthEastCardinalDirection, SouthEastCardinalDirection, SouthWestCardinalDirection, NorthWestCardinalDirection];\n  const unitVector = normalizeVector(vector);\n  let maxDotProduct = -Infinity;\n  let bestMatch: CardinalDirection = directions[0];\n  for (const direction of directions) {\n    const dotProduct = direction.vector[0] * unitVector[0] + direction.vector[1] * unitVector[1];\n    if (dotProduct > maxDotProduct) {\n      maxDotProduct = dotProduct;\n      bestMatch = direction;\n    }\n  }\n  return bestMatch;\n}\n","import { promptMessage } from '../interface/prompt/index';\n\nexport const md5 = require('md5');\nexport const { sha512 } = require('js-sha512');\n\nexport function compareThings(a: any, b: any): boolean {\n  function anyToString(any: any): string {\n    return JSON.stringify({ e: any });\n  }\n  const ax = anyToString(a);\n  const bx = anyToString(b);\n  const length: number = 32;\n  const axLength: number = ax.length;\n  const bxLength: number = bx.length;\n  if (axLength === bxLength) {\n    if (axLength > length || bxLength > length) {\n      const hash_a: string = md5(ax);\n      const hash_b: string = md5(bx);\n\n      let equal: boolean = true;\n      for (let i = 0; i < 8; i++) {\n        const a_i: string = hash_a.charAt(i);\n        const b_i: string = hash_b.charAt(i);\n        if (a_i === b_i) {\n          continue;\n        } else {\n          equal = false;\n          break;\n        }\n      }\n      return equal;\n    } else {\n      if (ax === bx) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function generateIdentifier(): string {\n  const chars = [\n    [48, 10], // 0-9: 48 - 57\n    [97, 26], // a-z: 97 - 122\n    [65, 26] // A-Z: 65 - 90\n  ];\n\n  let randomNumber1 = Math.floor(Math.random() * 0x10000000);\n  let randomNumber2 = Math.floor(Math.random() * 0x10000000);\n\n  const result = new Uint8Array(17);\n  result[0] = 95;\n  for (let i = 16; i > 0; i--) {\n    const n = randomNumber2 % 3;\n    const range = chars[n];\n    const code = range[0] + (randomNumber1 % range[1]);\n    result[i] = code;\n    randomNumber1 >>>= 1;\n    randomNumber2 >>>= 1;\n  }\n\n  return String.fromCharCode.apply(null, result);\n}\n\nexport function getNoCacheParameter(interval: number): string {\n  const time = new Date().getTime();\n  const number = (time / interval) | 0;\n  const string = number.toString(16);\n  return string;\n}\n\nexport function downloadBlobFile(blob: Blob, fileName: string, timeout: number = 32 * 1000): string {\n  const blobURL = URL.createObjectURL(blob);\n  const downloadLink = document.createElement('a');\n  downloadLink.href = blobURL;\n  downloadLink.download = fileName;\n  document.body.appendChild(downloadLink);\n  downloadLink.click();\n  downloadLink.remove();\n  setTimeout(() => {\n    URL.revokeObjectURL(blobURL);\n  }, timeout);\n  return blobURL;\n}\n\nexport function releaseFile(content: string, type: string = 'application/json', fileName: string): void {\n  const blob = new Blob([content], { type: type });\n  const fileObj = new File([blob], fileName, { type: type });\n  if (navigator.canShare && navigator.canShare({ files: [fileObj] })) {\n    navigator\n      .share({\n        files: [fileObj]\n      })\n      .catch((error) => {\n        promptMessage('download', '下載資料', {\n          text: '下載',\n          action: function () {\n            downloadBlobFile(blob, fileName);\n          }\n        });\n      });\n  } else {\n    downloadBlobFile(blob, fileName);\n  }\n}\n\nexport function isRunningStandalone(): boolean {\n  return window.matchMedia('(display-mode: standalone)').matches;\n}\n\nexport function supportTouch(): boolean {\n  if ('ontouchstart' in window || navigator.maxTouchPoints) {\n    // Touch events are supported\n    return true;\n  } else {\n    // Touch events are not supported\n    return false;\n  }\n}\n\nexport function booleanToString(x: boolean): 'true' | 'false' | 'unsupported' {\n  if (typeof x === 'boolean') {\n    if (x) {\n      return 'true';\n    } else {\n      return 'false';\n    }\n  }\n  return 'unsupported';\n}\n\nexport function hasOwnProperty(x: any, property: string): boolean {\n  if (x === null || x === undefined || typeof x !== 'object' || Array.isArray(x)) {\n    return false;\n  }\n  return Object.prototype.hasOwnProperty.call(x, property);\n}\n\nexport function isValidURL(string: string): boolean {\n  try {\n    new URL(string);\n    return true; // If no error is thrown, it's a valid URL\n  } catch (_) {\n    return false; // Invalid URL\n  }\n}\n\nexport function nearestPowerOf2(x: number): number {\n  return 1 << (31 - Math.clz32(x));\n}\n","export const levenshtein = require('js-levenshtein');\n"],"names":["addressToString","address","city","join","district","road","road_section","sort","a","b","length","alley","alley_branch","doorplate","floornumber","direction","generateLabelFromAddresses","addresses","result","filledProperties","key","hasOwnProperty","commonProperties","Object","entries","map","property","value","filter","e","commonProperty","components","len","Infinity","component","push","componentLen","areItemsDifferent","addressesLength","generateLetterLabels","documentQuerySelector","selectorExpression","document","querySelector","documentQuerySelectorAll","querySelectorAll","elementQuerySelector","element","elementQuerySelectorAll","getElementsBelow","referenceElement","className","elements","sibling","nextElementSibling","classList","contains","documentCreateDivElement","createElement","getTextWidth","text","weight","size","fontFamily","context","canvas","getContext","font","measureText","width","getTextBoundingBox","measurement","Math","max","abs","emHeightAscent","hangingBaseline","fontBoundingBoxAscent","actualBoundingBoxAscent","fontBoundingBoxDescent","drawRoundedRect","ctx","x","y","height","radius","fill","tl","tr","br","bl","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fillStyle","generateRoundedRectPath","inverted","_radius","command","convertPositionsToDistance","lat1","lon1","lat2","lon2","dLat","PI","dLon","sin","cos","atan2","sqrt","convertBytes","contentLength","units","i","floor","convertNumberToLetters","number","remainder","String","fromCharCode","arr","j","getIntersection","arrayA","arrayB","item","indexOf","quantity","generateDirectionLabels","cardinalDirections","cardinalDirection","name","symbol","UnknownCardinalDirection","vector","id","icon","NorthCardinalDirection","WestCardinalDirection","SouthCardinalDirection","EastCardinalDirection","NorthEastCardinalDirection","SQRT1_2","SouthEastCardinalDirection","SouthWestCardinalDirection","NorthWestCardinalDirection","getCardinalDirectionFromVector","directions","unitVector","normalizeVector","maxDotProduct","bestMatch","dotProduct","md5","require","sha512","compareThings","anyToString","any","JSON","stringify","ax","bx","axLength","bxLength","hash_a","hash_b","equal","charAt","generateIdentifier","chars","randomNumber1","random","randomNumber2","Uint8Array","range","code","apply","getNoCacheParameter","interval","Date","getTime","toString","downloadBlobFile","blob","fileName","timeout","arguments","undefined","blobURL","URL","createObjectURL","downloadLink","href","download","body","appendChild","click","remove","setTimeout","revokeObjectURL","releaseFile","content","type","Blob","fileObj","File","navigator","canShare","files","share","error","promptMessage","action","isRunningStandalone","window","matchMedia","matches","supportTouch","maxTouchPoints","booleanToString","_typeof","Array","isArray","prototype","call","isValidURL","string","_","levenshtein"],"ignoreList":[],"sourceRoot":""}