{"version":3,"file":"a1c10542f26e6a3cf0d6.js","mappings":"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","sources":["webpack://bus/./src/data/analytics/bus-arrival-time/index.ts","webpack://bus/./src/data/analytics/data-usage/index.ts","webpack://bus/./src/data/analytics/storage-size.ts","webpack://bus/./src/data/analytics/update-rate/index.ts"],"sourcesContent":["import { generateIdentifier, hasOwnProperty } from '../../../tools/index';\nimport { findGlobalExtrema } from '../../../tools/math';\nimport { WeekDayIndex } from '../../../tools/time';\nimport { EstimateTime } from '../../apis/getEstimateTime/index';\nimport { listAllFolderContent } from '../../folder/index';\nimport { isInPersonalSchedule, listPersonalSchedules, PersonalSchedule } from '../../personal-schedule/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../../storage/index';\n\nconst busArrivalTimeData_writeAheadLog_maxDataLength: number = 32;\nlet busArrivalTimeData_writeAheadLog_id: string = '';\nlet busArrivalTimeData_writeAheadLog_tracking: boolean = false;\nlet busArrivalTimeData_trackedStops: Array<number> = [];\nlet busArrivalTimeData_writeAheadLog_group: BusArrivalTimeDataWriteAheadLog = {\n  data: {},\n  timestamp: 0,\n  id: ''\n};\nlet busArrivalTimeData_writeAheadLog_currentDataLength: number = 0;\n\nexport type BusArrivalTimeData = [estimateTime: number, timestamp: number]; // EstimateTime (seconds), timestamp (milliseconds)\n\nexport type BusArrivalTimeDataGroupStats = Array<number>;\n\nexport interface BusArrivalTimeDataGroup {\n  stats: BusArrivalTimeDataGroupStats;\n  day: WeekDayIndex;\n  max: number;\n  min: number;\n  timestamp: number;\n  id: number; // stop id\n}\n\nexport type BusArrivalTimeDataGroupArray = Array<BusArrivalTimeDataGroup>;\n\nexport interface BusArrivalTimeDataWriteAheadLog {\n  data: {\n    [key: string]: Array<BusArrivalTimeData>;\n  };\n  timestamp: number;\n  id: string;\n}\n\nexport interface BusArrivalTime {\n  personalSchedule: PersonalSchedule;\n  chart: string; // svg\n  day: WeekDayIndex;\n}\n\nexport interface BusArrivalTimes {\n  [stopKey: string]: Array<BusArrivalTime>;\n}\n\nconst getBusArrivalTimeDataStatsWorkerTasks = {};\nlet getBusArrivalTimeDataStatsPort;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getBusArrivalTimeDataStatsWorker = new SharedWorker(new URL('./getBusArrivalTimeDataStats-worker.ts', import.meta.url)); // Reusable shared worker\n  getBusArrivalTimeDataStatsPort = getBusArrivalTimeDataStatsWorker.port; // Access the port for communication\n  getBusArrivalTimeDataStatsPort.start(); // Start the port (required by some browsers)\n} else {\n  const getBusArrivalTimeDataStatsWorker = new Worker(new URL('./getBusArrivalTimeDataStats-worker.ts', import.meta.url)); // Fallback to standard worker\n  getBusArrivalTimeDataStatsPort = getBusArrivalTimeDataStatsWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\ngetBusArrivalTimeDataStatsPort.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getBusArrivalTimeDataStatsWorkerTasks[taskID]) {\n    getBusArrivalTimeDataStatsWorkerTasks[taskID](result); // resolve\n    delete getBusArrivalTimeDataStatsWorkerTasks[taskID];\n  }\n};\n\n// Handle errors\ngetBusArrivalTimeDataStatsPort.onerror = function (e) {\n  console.error(e.message);\n};\n\nasync function getBusArrivalTimeDataStats(data: Array<BusArrivalTimeData>): Promise<BusArrivalTimeDataGroupStats> {\n  const taskID = generateIdentifier();\n\n  const result = await new Promise((resolve, reject) => {\n    getBusArrivalTimeDataStatsWorkerTasks[taskID] = resolve; // Store the resolve function for this taskID\n    getBusArrivalTimeDataStatsPort.onerror = function (e) {\n      reject(e.message);\n    };\n    getBusArrivalTimeDataStatsPort.postMessage([data, taskID]); // Send the task to the worker\n  });\n  return result;\n}\n\nfunction mergeBusArrivalTimeDataStats(targetStats: BusArrivalTimeDataGroupStats, sourceStats: BusArrivalTimeDataGroupStats): BusArrivalTimeDataGroupStats {\n  const mergedArray = new Uint32Array(60 * 24);\n  for (let i = 60 * 24 - 1; i >= 0; i--) {\n    mergedArray[i] = targetStats[i] + sourceStats[i];\n  }\n  return Array.from(mergedArray);\n}\n\nexport async function collectBusArrivalTimeData(EstimateTime: EstimateTime) {\n  const now = new Date();\n  const currentTimestamp: number = now.getTime();\n  const currentDay = now.getDay();\n  let needToReset = false;\n  // Initialize\n  if (!busArrivalTimeData_writeAheadLog_tracking) {\n    busArrivalTimeData_writeAheadLog_tracking = true;\n    busArrivalTimeData_writeAheadLog_id = generateIdentifier();\n    busArrivalTimeData_writeAheadLog_group = {\n      id: busArrivalTimeData_writeAheadLog_id,\n      timestamp: currentTimestamp,\n      data: {}\n    };\n    busArrivalTimeData_writeAheadLog_currentDataLength = 0;\n    const allFolderContent = await listAllFolderContent(['stop']);\n    busArrivalTimeData_trackedStops = allFolderContent.map((e) => e.id);\n  }\n\n  // Record EstimateTime\n  if (isInPersonalSchedule(now)) {\n    for (const item of EstimateTime) {\n      const stopID = item.StopID;\n      const stopKey = `s_${stopID}_${currentDay}`;\n      if (busArrivalTimeData_trackedStops.indexOf(stopID) > -1) {\n        if (!hasOwnProperty(busArrivalTimeData_writeAheadLog_group.data, stopKey)) {\n          busArrivalTimeData_writeAheadLog_group.data[stopKey] = [];\n        }\n        busArrivalTimeData_writeAheadLog_group.data[stopKey].push([parseInt(item.EstimateTime), currentTimestamp]);\n      }\n    }\n\n    busArrivalTimeData_writeAheadLog_currentDataLength += 1;\n    if (busArrivalTimeData_writeAheadLog_currentDataLength > busArrivalTimeData_writeAheadLog_maxDataLength) {\n      needToReset = true;\n    }\n\n    if (needToReset || busArrivalTimeData_writeAheadLog_currentDataLength % 8 === 0) {\n      await lfSetItem(5, busArrivalTimeData_writeAheadLog_id, JSON.stringify(busArrivalTimeData_writeAheadLog_group));\n    }\n\n    if (needToReset) {\n      for (const stopID of busArrivalTimeData_trackedStops) {\n        const stopKey = `s_${stopID}_${currentDay}`;\n        const data = busArrivalTimeData_writeAheadLog_group.data[stopKey];\n        const dataGroup = {} as BusArrivalTimeDataGroup;\n        const existingData = await lfGetItem(6, stopKey);\n        if (existingData) {\n          const existingDataObject = JSON.parse(existingData) as BusArrivalTimeDataGroup;\n          const newStats = await getBusArrivalTimeDataStats(data);\n          const mergedStats = mergeBusArrivalTimeDataStats(existingDataObject.stats, newStats);\n          dataGroup.stats = mergedStats;\n          const mergedExtrema = findGlobalExtrema(mergedStats);\n          dataGroup.min = mergedExtrema[0];\n          dataGroup.max = mergedExtrema[1];\n          dataGroup.day = currentDay;\n          dataGroup.timestamp = existingDataObject.timestamp;\n          dataGroup.id = stopID;\n        } else {\n          const newStats = await getBusArrivalTimeDataStats(data);\n          dataGroup.stats = newStats;\n          const newExtrema = findGlobalExtrema(newStats);\n          dataGroup.min = newExtrema[0];\n          dataGroup.max = newExtrema[1];\n          dataGroup.day = currentDay;\n          dataGroup.timestamp = currentTimestamp;\n          dataGroup.id = stopID;\n        }\n        await lfSetItem(6, stopKey, JSON.stringify(dataGroup));\n        await lfRemoveItem(5, busArrivalTimeData_writeAheadLog_id);\n      }\n      busArrivalTimeData_writeAheadLog_tracking = false;\n    }\n  }\n}\n\nexport async function recoverBusArrivalTimeDataFromWriteAheadLog() {\n  const keys = await lfListItemKeys(5);\n  for (const key of keys) {\n    const json = await lfGetItem(5, key);\n    const object = JSON.parse(json) as BusArrivalTimeDataWriteAheadLog;\n    const thisID = object.id;\n    for (const stopKey in object.data) {\n      const thisStopData = object.data[stopKey];\n      const dataGroup = {} as BusArrivalTimeDataGroup;\n      const existingData = await lfGetItem(6, stopKey);\n      const stopKeyComponents = stopKey.split('_');\n      const stopID = parseInt(stopKeyComponents[1]);\n      const day = parseInt(stopKeyComponents[2]);\n      if (existingData) {\n        const existingDataObject = JSON.parse(existingData) as BusArrivalTimeDataGroup;\n        const newStats = await getBusArrivalTimeDataStats(thisStopData);\n        const mergedStats = mergeBusArrivalTimeDataStats(existingDataObject.stats, newStats);\n        dataGroup.stats = mergedStats;\n        const newExtremum = findGlobalExtrema(mergedStats);\n        dataGroup.min = newExtremum[0];\n        dataGroup.max = newExtremum[1];\n        dataGroup.day = existingDataObject.day;\n        dataGroup.timestamp = existingDataObject.timestamp;\n        dataGroup.id = stopID;\n      } else {\n        const newStats = await getBusArrivalTimeDataStats(thisStopData);\n        dataGroup.stats = newStats;\n        const newExtremum = findGlobalExtrema(newStats);\n        dataGroup.min = newExtremum[0];\n        dataGroup.max = newExtremum[1];\n        dataGroup.day = day;\n        dataGroup.timestamp = object.timestamp;\n        dataGroup.id = stopID;\n      }\n      await lfSetItem(6, stopKey, JSON.stringify(dataGroup));\n    }\n    await lfRemoveItem(5, thisID);\n  }\n}\n\nexport async function listBusArrivalTimeDataGroups(): Promise<BusArrivalTimeDataGroupArray> {\n  const keys = await lfListItemKeys(6);\n  const result: BusArrivalTimeDataGroupArray = [];\n  for (const key of keys) {\n    const json = await lfGetItem(6, key);\n    if (json) {\n      result.push(JSON.parse(json) as BusArrivalTimeDataGroup);\n    }\n  }\n  return result;\n}\n\nconst getBusArrivalTimesWorkerResponses = {};\nlet getBusArrivalTimesPort;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getUpdateRateSharedWorker = new SharedWorker(new URL('./getBusArrivalTimes-worker.ts', import.meta.url)); // Reusable shared worker\n  getBusArrivalTimesPort = getUpdateRateSharedWorker.port; // Access the port for communication\n  getBusArrivalTimesPort.start(); // Start the port (required by some browsers)\n} else {\n  const getUpdateRateWorker = new Worker(new URL('./getBusArrivalTimes-worker.ts', import.meta.url)); // Fallback to standard worker\n  getBusArrivalTimesPort = getUpdateRateWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\ngetBusArrivalTimesPort.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getBusArrivalTimesWorkerResponses[taskID]) {\n    getBusArrivalTimesWorkerResponses[taskID](result); // Resolve the correct promise\n    delete getBusArrivalTimesWorkerResponses[taskID]; // Clean up the response handler\n  }\n};\n\n// Handle errors\ngetBusArrivalTimesPort.onerror = function (e) {\n  console.error(e.message);\n};\n\nexport async function getBusArrivalTimes(chartWidth: number, chartHeight: number): Promise<BusArrivalTimes> {\n  const taskID = generateIdentifier();\n\n  const personalSchedules = await listPersonalSchedules();\n  const busArrivalTimeDataGroups = await listBusArrivalTimeDataGroups();\n\n  const result = await new Promise((resolve, reject) => {\n    getBusArrivalTimesWorkerResponses[taskID] = resolve; // Store the resolve function for this taskID\n    getBusArrivalTimesPort.onerror = function (e) {\n      reject(e.message);\n    };\n    getBusArrivalTimesPort.postMessage([personalSchedules, busArrivalTimeDataGroups, chartWidth, chartHeight, taskID]); // Send the task to the worker\n  });\n  return result;\n}\n","import { createDateObjectFromDate, dateToString, offsetDate, TimeStampPeriod } from '../../../tools/time';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../../storage/index';\n\nexport interface DataUsageStatsChunk {\n  date: [year: number, month: number, day: number];\n  data: Array<number>;\n  stats: {\n    sum: number;\n    max: number;\n    min: number;\n  };\n}\n\nexport type DataUsageStatsChunkArray = Array<DataUsageStatsChunk>;\n\nexport interface DataUsageStats {\n  stats: {\n    sum: number;\n    max: number;\n    min: number;\n  };\n  period: TimeStampPeriod;\n  chart: string;\n}\n\nexport const DataUsagePeriod = 7; // days\n\nexport async function recordDataUsage(contentLength: number, date: Date) {\n  const key = `d_${dateToString(date, 'YYYY_MM_DD')}`;\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const index = hours * 60 + minutes;\n  const existingDataUsageStatsChunkJSON = await lfGetItem(2, key);\n  if (existingDataUsageStatsChunkJSON) {\n    const existingDataUsageStatsChunkObject = JSON.parse(existingDataUsageStatsChunkJSON) as DataUsageStatsChunk;\n    existingDataUsageStatsChunkObject.stats.sum += contentLength;\n    existingDataUsageStatsChunkObject.data[index] += contentLength;\n    const changedData = existingDataUsageStatsChunkObject.data[index];\n    if (changedData > existingDataUsageStatsChunkObject.stats.max) {\n      existingDataUsageStatsChunkObject.stats.max = changedData;\n    }\n    if (changedData < existingDataUsageStatsChunkObject.stats.min) {\n      existingDataUsageStatsChunkObject.stats.min = changedData;\n    }\n    await lfSetItem(2, key, JSON.stringify(existingDataUsageStatsChunkObject));\n  } else {\n    const newDataUsageStatsChunk = {} as DataUsageStatsChunk;\n    const data = new Uint32Array(60 * 24);\n    data[index] += contentLength;\n    newDataUsageStatsChunk.data = Array.from(data);\n    newDataUsageStatsChunk.stats = {\n      sum: contentLength,\n      max: contentLength,\n      min: 0\n    };\n    newDataUsageStatsChunk.date = [date.getFullYear(), date.getMonth() + 1, date.getDate()];\n    await lfSetItem(2, key, JSON.stringify(newDataUsageStatsChunk));\n  }\n}\n\nexport async function listDataUsageStatsChunks(): Promise<DataUsageStatsChunkArray> {\n  const endDate = new Date();\n  endDate.setHours(0);\n  endDate.setMinutes(0);\n  endDate.setSeconds(0);\n  endDate.setMilliseconds(0);\n  const startDate = offsetDate(endDate, -1 * DataUsagePeriod, 0, 0);\n  const result: DataUsageStatsChunkArray = [];\n  for (let i = 1; i <= DataUsagePeriod; i++) {\n    const date = offsetDate(startDate, i, 0, 0);\n    const key = `d_${dateToString(date, 'YYYY_MM_DD')}`;\n    const existingDataUsageStatsChunkJSON = await lfGetItem(2, key);\n    if (existingDataUsageStatsChunkJSON) {\n      const existingDataUsageStatsChunkObject = JSON.parse(existingDataUsageStatsChunkJSON) as DataUsageStatsChunk;\n      result.push(existingDataUsageStatsChunkObject);\n    } else {\n      const blankDataUsageStatsChunk = {} as DataUsageStatsChunk;\n      const data = new Uint32Array(60 * 24);\n      blankDataUsageStatsChunk.data = Array.from(data);\n      blankDataUsageStatsChunk.stats = {\n        sum: 0,\n        max: 0,\n        min: 0\n      };\n      blankDataUsageStatsChunk.date = [date.getFullYear(), date.getMonth() + 1, date.getDate()];\n      result.push(blankDataUsageStatsChunk);\n    }\n  }\n  return result;\n}\n\nexport async function discardExpiredDataUsageStats() {\n  const millisecondsPerDay = 60 * 60 * 24 * 1000;\n  const expirationPeriod = millisecondsPerDay * DataUsagePeriod;\n  const now = new Date().getTime();\n  const keys = await lfListItemKeys(2);\n  for (const key of keys) {\n    const json = await lfGetItem(2, key);\n    const object = JSON.parse(json) as DataUsageStatsChunk;\n    const date = createDateObjectFromDate(object.date[0], object.date[1], object.date[2]);\n    if (now - date.getTime() > expirationPeriod) {\n      await lfRemoveItem(2, key);\n    }\n  }\n}\n\nexport async function getDataUsageStats(width: number, height: number, padding: number): Promise<DataUsageStats> {\n  const worker = new Worker(new URL('./getDataUsageStats-worker.ts', import.meta.url));\n  const dataUsageStatsChunks = await listDataUsageStatsChunks();\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n    worker.postMessage([dataUsageStatsChunks, width, height, padding]); // Send data to the worker\n  });\n  return result;\n}\n","import { convertBytes } from '../../tools/convert';\nimport { hasOwnProperty } from '../../tools/index';\nimport { getStoresLength, lfGetItem, lfListItemKeys } from '../storage/index';\n\ninterface StoreCategory {\n  name: string;\n  key: string;\n}\n\ninterface StoreSizeInBytes {\n  category: StoreCategory;\n  size: number;\n}\n\ntype CategorizedSizesInBytes = { [key: string]: StoreSizeInBytes };\n\nexport interface StoreSize {\n  category: StoreCategory;\n  size: string;\n}\n\nexport type CategorizedSizes = { [key: string]: StoreSize };\n\nexport interface StoreSizeStatistics {\n  categorizedSizes: CategorizedSizes;\n  totalSize: number;\n}\n\nfunction storeIndexToCategory(store: number): StoreCategory {\n  const [name, key] = [\n    ['快取', 'cache'],\n    ['設定', 'settings'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['個人化行程', 'personalSchedule'],\n    ['最近檢視', 'recentViews'],\n    ['通知', 'notification'],\n    ['通知', 'notification'],\n    ['資料夾', 'folders'],\n    ['資料夾', 'folders'],\n    ['資料夾', 'folders']\n  ][store] || ['其他', 'others'];\n  const result = {\n    name,\n    key\n  };\n  return result;\n}\n\nexport async function getStoresSizeStatistics(): Promise<StoreSizeStatistics> {\n  let totalSizeInBytes: number = 0;\n  const categorizedSizesInBytes: CategorizedSizesInBytes = {};\n  const storesLength = getStoresLength();\n\n  for (let i = 0; i < storesLength; i++) {\n    const keysInStore = await lfListItemKeys(i);\n    let thisStoreSizeInBytes: number = 0;\n    for (const itemKey of keysInStore) {\n      const item = await lfGetItem(i, itemKey);\n      const itemInString = String(item);\n      const itemLength = itemInString.length + itemKey.length;\n      totalSizeInBytes += itemLength;\n      thisStoreSizeInBytes += itemLength;\n    }\n    const thisCategory = storeIndexToCategory(i);\n    const thisCategoryKey = thisCategory.key;\n    if (!hasOwnProperty(categorizedSizesInBytes, thisCategoryKey)) {\n      categorizedSizesInBytes[thisCategoryKey] = {\n        category: thisCategory,\n        size: 0\n      };\n    }\n    categorizedSizesInBytes[thisCategory.key].size += thisStoreSizeInBytes;\n  }\n\n  const totalSize = convertBytes(totalSizeInBytes);\n\n  const categorizedSizes: CategorizedSizes = {};\n  for (const key in categorizedSizesInBytes) {\n    const thisCategory = categorizedSizesInBytes[key].category;\n    const thisCategorySize = categorizedSizesInBytes[key].size;\n    categorizedSizes[key] = {\n      category: thisCategory,\n      size: convertBytes(thisCategorySize)\n    };\n  }\n\n  const result: StoreSizeStatistics = {\n    totalSize,\n    categorizedSizes\n  };\n\n  return result;\n}\n","import { generateIdentifier, hasOwnProperty } from '../../../tools/index';\nimport { mergePearsonCorrelation, mergeStandardDeviation } from '../../../tools/math';\nimport { EstimateTime } from '../../apis/getEstimateTime/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../../storage/index';\n\nexport type UpdateRateData = [estimateTime: number, timestamp: number]; // EstimateTime (seconds), timestamp (seconds)\n\nexport interface UpdateRateDataGroupStats {\n  estimate_time: {\n    average: number;\n    stdev: number;\n  };\n  timestamp: {\n    average: number;\n    stdev: number;\n  };\n  correlation: number;\n  length: number;\n}\n\nexport interface UpdateRateDataGroup {\n  stats: UpdateRateDataGroupStats;\n  timestamp: number;\n  id: number; // stop id\n}\n\nexport type UpdateRateDataGroupArray = Array<UpdateRateDataGroup>;\n\nexport interface UpdateRateDataWriteAheadLogGroup {\n  data: Array<UpdateRateData>;\n  timestamp: number;\n  id: string;\n}\n\nconst updateRateData_sampleQuantity: number = 32;\nlet updateRateData_trackedStops: Array<number> = [];\nlet updateRateData_writeAheadLog_id: string = '';\nlet updateRateData_writeAheadLog_tracking: boolean = false;\nlet updateRateData_writeAheadLog_currentDataLength: number = 0;\nconst updateRateData_writeAheadLog_maxDataLength: number = 45;\nlet updateRateData_writeAheadLog_group: UpdateRateDataWriteAheadLogGroup = {\n  data: {},\n  timestamp: 0,\n  id: ''\n};\nconst updateRateData_groups: Array<UpdateRateDataGroup> = [];\nconst updateRateData_groupsIndex: { [key: string]: number } = {};\n\nfunction getUpdateRateDataStats(data: Array<UpdateRateData>): UpdateRateDataGroupStats {\n  let sumEstimateTime = 0;\n  let sumEstimateTimeSquared = 0;\n  let sumTimestamp = 0;\n  let sumTimestampSquared = 0;\n  let dataLength = 0;\n  for (const item of data) {\n    const estimateTime = item[0];\n    const timestamp = item[1];\n    dataLength += 1;\n    sumEstimateTime += estimateTime;\n    sumTimestamp += timestamp;\n    sumEstimateTimeSquared += Math.pow(estimateTime, 2);\n    sumTimestampSquared += Math.pow(timestamp, 2);\n  }\n\n  const averageEstimateTime = sumEstimateTime / dataLength;\n  const averageTimestamp = sumTimestamp / dataLength;\n\n  const estimateTimeVariance = sumEstimateTimeSquared / dataLength - Math.pow(averageEstimateTime, 2);\n  const timestampVariance = sumTimestampSquared / dataLength - Math.pow(averageTimestamp, 2);\n\n  const estimateTimeSTDEV = Math.sqrt(estimateTimeVariance);\n  const timestampSTDEV = Math.sqrt(timestampVariance);\n\n  let covariance = 0;\n  for (const item2 of data) {\n    const estimateTime = item2[0];\n    const timestamp = item2[1];\n    covariance += (estimateTime - averageEstimateTime) * (timestamp - averageTimestamp);\n  }\n  covariance /= dataLength;\n\n  const correlation = covariance / (estimateTimeSTDEV * timestampSTDEV);\n\n  const result: UpdateRateDataGroupStats = {\n    estimate_time: {\n      average: averageEstimateTime,\n      stdev: estimateTimeSTDEV\n    },\n    timestamp: {\n      average: averageTimestamp,\n      stdev: timestampSTDEV\n    },\n    length: dataLength,\n    correlation: correlation\n  };\n  return result;\n}\n\nfunction mergeUpdateRateDataStats(targetStats: UpdateRateDataGroupStats, sourceStats: UpdateRateDataGroupStats): UpdateRateDataGroupStats {\n  const mergedDataLength = targetStats.length + sourceStats.length;\n\n  const mergedAverageEstimateTime = (targetStats.estimate_time.average * targetStats.length + sourceStats.estimate_time.average * sourceStats.length) / mergedDataLength;\n  const mergedAverageTimestamp = (targetStats.timestamp.average * targetStats.length + sourceStats.timestamp.average * sourceStats.length) / mergedDataLength;\n\n  const mergedEstimateTimeSTDEV = mergeStandardDeviation(targetStats.estimate_time.average, targetStats.estimate_time.stdev, targetStats.length, sourceStats.estimate_time.average, sourceStats.estimate_time.stdev, sourceStats.length);\n  const mergedTimestampSTDEV = mergeStandardDeviation(targetStats.timestamp.average, targetStats.timestamp.stdev, targetStats.length, sourceStats.timestamp.average, sourceStats.timestamp.stdev, sourceStats.length);\n\n  const mergedCorrelation = mergePearsonCorrelation(targetStats.estimate_time.average, targetStats.timestamp.average, targetStats.estimate_time.stdev, targetStats.timestamp.stdev, targetStats.length, targetStats.correlation, sourceStats.estimate_time.average, sourceStats.timestamp.average, sourceStats.estimate_time.stdev, sourceStats.timestamp.stdev, sourceStats.length, sourceStats.correlation);\n\n  const result: UpdateRateDataGroupStats = {\n    estimate_time: {\n      average: mergedAverageEstimateTime,\n      stdev: mergedEstimateTimeSTDEV\n    },\n    timestamp: {\n      average: mergedAverageTimestamp,\n      stdev: mergedTimestampSTDEV\n    },\n    length: mergedDataLength,\n    correlation: mergedCorrelation\n  };\n  return result;\n}\n\nexport async function collectUpdateRateData(EstimateTime: EstimateTime) {\n  const now = new Date();\n  const currentTimestamp: number = now.getTime();\n  let needToReset = false;\n  // Initialize\n  if (!updateRateData_writeAheadLog_tracking) {\n    updateRateData_writeAheadLog_tracking = true;\n    updateRateData_trackedStops = [];\n    updateRateData_writeAheadLog_id = generateIdentifier();\n    updateRateData_writeAheadLog_group = {\n      data: {},\n      timestamp: currentTimestamp,\n      id: updateRateData_writeAheadLog_id\n    };\n    updateRateData_writeAheadLog_currentDataLength = 0;\n    const EstimateTimeLength1: number = EstimateTime.length - 1;\n    for (let i = 0; i < updateRateData_sampleQuantity; i++) {\n      const randomIndex: number = Math.floor(Math.random() * EstimateTimeLength1);\n      const randomItem = EstimateTime[randomIndex];\n      updateRateData_trackedStops.push(randomItem.StopID);\n    }\n  }\n\n  // Record EstimateTime\n  for (const item of EstimateTime) {\n    const stopID = item.StopID;\n    const stopKey = `s_${stopID}`;\n    if (updateRateData_trackedStops.indexOf(stopID) > -1) {\n      if (!hasOwnProperty(updateRateData_writeAheadLog_group.data, stopKey)) {\n        updateRateData_writeAheadLog_group.data[stopKey] = [];\n      }\n      updateRateData_writeAheadLog_group.data[stopKey].push([parseInt(item.EstimateTime), Math.floor((currentTimestamp - updateRateData_writeAheadLog_group.timestamp) / 1000)]);\n    }\n  }\n\n  updateRateData_writeAheadLog_currentDataLength += 1;\n  if (updateRateData_writeAheadLog_currentDataLength > updateRateData_writeAheadLog_maxDataLength) {\n    needToReset = true;\n  }\n\n  if (updateRateData_writeAheadLog_currentDataLength % 5 === 0) {\n    await lfSetItem(4, updateRateData_writeAheadLog_id, JSON.stringify(updateRateData_writeAheadLog_group));\n  }\n\n  if (needToReset) {\n    for (const stopID of updateRateData_trackedStops) {\n      const stopKey = `s_${stopID}`;\n      const data = updateRateData_writeAheadLog_group.data[stopKey];\n      const dataGroup = {} as UpdateRateDataGroup;\n      const existingData = await lfGetItem(3, stopKey);\n      if (existingData) {\n        const existingDataObject = JSON.parse(existingData) as UpdateRateDataGroup;\n        dataGroup.stats = mergeUpdateRateDataStats(existingDataObject.stats, getUpdateRateDataStats(data));\n        dataGroup.timestamp = existingDataObject.timestamp;\n        dataGroup.id = stopID;\n      } else {\n        dataGroup.stats = getUpdateRateDataStats(data);\n        dataGroup.timestamp = currentTimestamp;\n        dataGroup.id = stopID;\n      }\n      await lfSetItem(3, stopKey, JSON.stringify(dataGroup));\n      if (hasOwnProperty(updateRateData_groupsIndex, stopKey)) {\n        const existingIndex = updateRateData_groupsIndex[stopKey];\n        updateRateData_groups.splice(existingIndex, 1, dataGroup);\n      } else {\n        updateRateData_groups[stopKey] = updateRateData_groups.length;\n        updateRateData_groups.push(dataGroup);\n      }\n      await lfRemoveItem(4, updateRateData_writeAheadLog_id);\n    }\n\n    updateRateData_writeAheadLog_tracking = false;\n  }\n}\n\nexport async function recoverUpdateRateDataFromWriteAheadLog() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(4);\n  for (const key of keys) {\n    const json = await lfGetItem(4, key);\n    if (json) {\n      const object = JSON.parse(json) as UpdateRateDataWriteAheadLogGroup;\n      const thisTimestamp = object.timestamp;\n      const thisID = object.id;\n      if (thisTimestamp > oneWeekAgo) {\n        for (const stopKey in object.data) {\n          const thisStopData = object.data[stopKey];\n          const dataGroup = {} as UpdateRateDataGroup;\n          const existingData = await lfGetItem(3, stopKey);\n          if (existingData) {\n            const existingDataObject = JSON.parse(existingData) as UpdateRateDataGroup;\n            dataGroup.stats = mergeUpdateRateDataStats(existingDataObject.stats, getUpdateRateDataStats(thisStopData));\n            dataGroup.timestamp = existingDataObject.timestamp;\n            dataGroup.id = existingDataObject.id;\n          } else {\n            dataGroup.stats = getUpdateRateDataStats(thisStopData);\n            dataGroup.timestamp = thisTimestamp;\n            dataGroup.id = parseInt(stopKey.split('_')[1]);\n          }\n          await lfSetItem(3, stopKey, JSON.stringify(dataGroup));\n          if (hasOwnProperty(updateRateData_groupsIndex, stopKey)) {\n            const existingIndex = updateRateData_groupsIndex[stopKey];\n            updateRateData_groups.splice(existingIndex, 1, dataGroup);\n          } else {\n            updateRateData_groups[stopKey] = updateRateData_groups.length;\n            updateRateData_groups.push(dataGroup);\n          }\n        }\n      }\n      await lfRemoveItem(4, thisID);\n    }\n  }\n}\n\nexport async function initializeUpdateRateDataGroups() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(3);\n  let index: number = 0;\n  for (const key of keys) {\n    const json = await lfGetItem(3, key);\n    if (json) {\n      const object = JSON.parse(json) as UpdateRateDataGroup;\n      const thisTimestamp = object.timestamp;\n      if (thisTimestamp > oneWeekAgo) {\n        updateRateData_groups.push(object);\n        updateRateData_groupsIndex[key] = index;\n        index += 1;\n      }\n    }\n  }\n}\n\nexport function listUpdateRateDataGroups(): Array<UpdateRateDataGroup> {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const result: Array<UpdateRateDataGroup> = [];\n  for (const dataGroup of updateRateData_groups) {\n    if (dataGroup.timestamp > oneWeekAgo && typeof dataGroup.stats.correlation === 'number') {\n      result.push(dataGroup);\n    }\n  }\n  return result;\n}\n\nexport async function discardUpdateRateDataGroups() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(3);\n  for (const key of keys) {\n    const json = await lfGetItem(3, key);\n    const object = JSON.parse(json) as UpdateRateDataGroup;\n    const thisTimestamp = object.timestamp;\n    if (thisTimestamp <= oneWeekAgo || typeof object.stats.correlation !== 'number') {\n      await lfRemoveItem(3, key);\n    }\n  }\n}\n\nconst getUpdateRateWorkerResponses = {};\nlet port;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getUpdateRateSharedWorker = new SharedWorker(new URL('./getUpdateRate-worker.ts', import.meta.url)); // Reusable shared worker\n  port = getUpdateRateSharedWorker.port; // Access the port for communication\n  port.start(); // Start the port (required by some browsers)\n} else {\n  const getUpdateRateWorker = new Worker(new URL('./getUpdateRate-worker.ts', import.meta.url)); // Fallback to standard worker\n  port = getUpdateRateWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\nport.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getUpdateRateWorkerResponses[taskID]) {\n    getUpdateRateWorkerResponses[taskID](result); // Resolve the correct promise\n    delete getUpdateRateWorkerResponses[taskID]; // Clean up the response handler\n  }\n};\n\n// Handle errors\nport.onerror = function (e) {\n  console.error(e.message);\n};\n\nexport async function getUpdateRate(): Promise<number> {\n  const dataGroups = await listUpdateRateDataGroups();\n  const taskID = generateIdentifier();\n\n  const result = await new Promise((resolve, reject) => {\n    getUpdateRateWorkerResponses[taskID] = resolve; // Store the resolve function for this taskID\n\n    port.onerror = function (e) {\n      reject(e.message);\n    };\n\n    port.postMessage([dataGroups, taskID]); // Send the task to the worker\n  });\n\n  return result;\n}\n"],"names":["getBusArrivalTimeDataStatsPort","busArrivalTimeData_writeAheadLog_id","busArrivalTimeData_writeAheadLog_tracking","busArrivalTimeData_trackedStops","busArrivalTimeData_writeAheadLog_group","data","timestamp","id","busArrivalTimeData_writeAheadLog_currentDataLength","getBusArrivalTimeDataStatsWorkerTasks","SharedWorker","getBusArrivalTimeDataStatsWorker","URL","port","start","Worker","getBusArrivalTimeDataStats","_x","_getBusArrivalTimeDataStats","apply","arguments","_asyncToGenerator","taskID","generateIdentifier","Promise","resolve","reject","onerror","e","message","postMessage","mergeBusArrivalTimeDataStats","targetStats","sourceStats","mergedArray","Uint32Array","i","Array","from","collectBusArrivalTimeData","_x2","_collectBusArrivalTimeData","EstimateTime","now","Date","currentTimestamp","getTime","currentDay","getDay","needToReset","allFolderContent","listAllFolderContent","map","isInPersonalSchedule","item","stopID","StopID","stopKey","indexOf","hasOwnProperty","push","parseInt","lfSetItem","JSON","stringify","dataGroup","existingData","lfGetItem","existingDataObject","parse","newStats","mergedStats","stats","mergedExtrema","findGlobalExtrema","min","max","day","newExtrema","lfRemoveItem","recoverBusArrivalTimeDataFromWriteAheadLog","_recoverBusArrivalTimeDataFromWriteAheadLog","keys","lfListItemKeys","key","json","object","thisID","thisStopData","stopKeyComponents","split","newExtremum","_listBusArrivalTimeDataGroups","result","onmessage","_e$data","_slicedToArray","getBusArrivalTimesPort","getBusArrivalTimesWorkerResponses","getUpdateRateSharedWorker","getUpdateRateWorker","getBusArrivalTimes","_x3","_x4","_getBusArrivalTimes","chartWidth","chartHeight","personalSchedules","listPersonalSchedules","busArrivalTimeDataGroups","listBusArrivalTimeDataGroups","_e$data2","recordDataUsage","_recordDataUsage","contentLength","date","dateToString","index","getHours","getMinutes","existingDataUsageStatsChunkJSON","existingDataUsageStatsChunkObject","sum","changedData","newDataUsageStatsChunk","getFullYear","getMonth","getDate","_listDataUsageStatsChunks","endDate","setHours","setMinutes","setSeconds","setMilliseconds","startDate","offsetDate","blankDataUsageStatsChunk","discardExpiredDataUsageStats","_discardExpiredDataUsageStats","createDateObjectFromDate","millisecondsPerDay","getDataUsageStats","_x5","_getDataUsageStats","width","height","padding","worker","dataUsageStatsChunks","listDataUsageStatsChunks","terminate","storeIndexToCategory","store","_ref","_ref2","name","getStoresSizeStatistics","_getStoresSizeStatistics","totalSizeInBytes","categorizedSizesInBytes","storesLength","getStoresLength","keysInStore","thisStoreSizeInBytes","itemKey","itemLength","String","length","thisCategory","thisCategoryKey","category","size","totalSize","convertBytes","categorizedSizes","thisCategorySize","updateRateData_trackedStops","updateRateData_writeAheadLog_id","updateRateData_writeAheadLog_tracking","updateRateData_writeAheadLog_currentDataLength","updateRateData_writeAheadLog_group","updateRateData_groups","updateRateData_groupsIndex","getUpdateRateDataStats","sumEstimateTime","sumEstimateTimeSquared","sumTimestamp","sumTimestampSquared","dataLength","estimateTime","Math","pow","averageEstimateTime","averageTimestamp","estimateTimeVariance","timestampVariance","estimateTimeSTDEV","sqrt","timestampSTDEV","covariance","item2","estimate_time","average","stdev","correlation","mergeUpdateRateDataStats","mergedDataLength","mergedAverageEstimateTime","mergedAverageTimestamp","mergeStandardDeviation","mergePearsonCorrelation","collectUpdateRateData","_collectUpdateRateData","EstimateTimeLength1","randomItem","floor","random","existingIndex","splice","recoverUpdateRateDataFromWriteAheadLog","_recoverUpdateRateDataFromWriteAheadLog","oneWeekAgo","thisTimestamp","initializeUpdateRateDataGroups","_initializeUpdateRateDataGroups","discardUpdateRateDataGroups","_discardUpdateRateDataGroups","getUpdateRateWorkerResponses","getUpdateRate","_getUpdateRate","dataGroups","listUpdateRateDataGroups"],"sourceRoot":""}