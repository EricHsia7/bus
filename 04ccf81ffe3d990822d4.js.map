{"version":3,"file":"04ccf81ffe3d990822d4.js","mappings":"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","sources":["webpack://bus/./src/data/apis/index.ts","webpack://bus/./src/data/apis/loader.ts","webpack://bus/./src/data/bus/index.ts","webpack://bus/./src/data/export/index.ts","webpack://bus/./src/data/folder/index.ts","webpack://bus/./src/data/import/index.ts","webpack://bus/./src/data/location/details.ts","webpack://bus/./src/data/location/index.ts"],"sourcesContent":["import { hasOwnProperty } from '../../tools/index';\nimport { clamp } from '../../tools/math';\nimport { formatTime } from '../../tools/time';\nimport { BusData, BusDataItem } from './getBusData/index';\nimport { BusEvent, BusEventItem } from './getBusEvent/index';\nimport { SimplifiedRoute } from './getRoute/index';\n\nexport interface EstimateTimeStatus {\n  code: 0 | 0.5 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8; // 8: loading\n  text: string;\n  time: number;\n}\n\nexport function parseEstimateTime(EstimateTime: string, mode: number): EstimateTimeStatus {\n  if (typeof EstimateTime === 'string') {\n    const time = parseInt(EstimateTime);\n    if (time === -3) {\n      return { code: 6, text: '末班駛離', time };\n    }\n    if (time === -4) {\n      return { code: 5, text: '今日停駛', time };\n    }\n    if (time === -2) {\n      return { code: 4, text: '交通管制', time };\n    }\n    if (time === -1) {\n      return { code: 3, text: '未發車', time };\n    }\n    if (0 <= time && time <= 10) {\n      return { code: 2, text: '進站中', time };\n    }\n    if (10 < time && time <= 180) {\n      return { code: 1, text: formatTime(time, mode), time };\n    }\n    if (180 < time && time <= 250) {\n      return { code: 0.5, text: formatTime(time, mode), time };\n    }\n    if (250 < time) {\n      return { code: 0, text: formatTime(time, mode), time };\n    }\n  }\n  return { code: 7, text: '發生錯誤', time: -5 };\n}\n\nexport interface TimeMoment {\n  type: 'moment';\n  hours: number;\n  minutes: number;\n}\n\nexport interface TimeRange {\n  type: 'range';\n  min: number;\n  max: number;\n}\n\n/**\n * parseTimeCode\n * @param code 0: hhmm/mm, 1: mmMM/mm\n * @param mode 0: moment, 1: range\n * @returns 0: TimeMoment, 1: TimeRange\n */\n\nexport function parseTimeCode(code: string, mode: 0 | 1): TimeMoment | TimeRange {\n  const codeLength = code.length;\n  if (mode === 0) {\n    let hours = 0;\n    let minutes = 0;\n    if (codeLength === 4) {\n      hours = parseInt(code.substring(0, 2));\n      minutes = parseInt(code.substring(2, 4));\n    }\n    if (codeLength === 2) {\n      minutes = parseInt(code);\n    }\n    return {\n      type: 'moment',\n      hours: hours,\n      minutes: minutes\n    };\n  }\n  if (mode === 1) {\n    let min = 0;\n    let max = 0;\n    if (codeLength === 4) {\n      const number1 = parseInt(code.substring(0, 2));\n      const number2 = parseInt(code.substring(2, 4));\n      min = Math.min(number1, number2);\n      max = Math.max(number1, number2);\n    }\n    if (codeLength === 2) {\n      const number = parseInt(code);\n      min = number;\n      max = number;\n    }\n    return {\n      type: 'range',\n      min: min,\n      max: max\n    };\n  }\n}\n\nexport interface BatchFoundBusPosition {\n  longitude: number;\n  latitude: number;\n}\n\nexport interface BatchFoundBus {\n  CarType: BusEventItem['CarType'];\n  BusStatus: BusEventItem['BusStatus'];\n  BusID: string;\n  CarOnStop: BusEventItem['CarOnStop'];\n  onThisRoute: boolean;\n  position: BatchFoundBusPosition;\n  RouteName: string;\n  RouteID: number;\n  index: number;\n}\n\nexport type BatchFoundBuses = { [key: string]: Array<BatchFoundBus> };\n\nexport function batchFindBusesForRoute(BusEvent: BusEvent, BusData: BusData, Route: SimplifiedRoute, RouteID: number, PathAttributeId: Array<number>): BatchFoundBuses {\n  const result = {} as BatchFoundBuses;\n  const BusDataObj: {\n    [key: string]: BusDataItem;\n  } = {};\n  for (const BusDataItem of BusData) {\n    const thisBusID = BusDataItem.BusID;\n    BusDataObj[thisBusID] = BusDataItem;\n  }\n\n  for (const BusEventItem of BusEvent) {\n    const processedItem = {} as BatchFoundBus;\n\n    // collect data from 'BusEvent'\n    processedItem.CarType = BusEventItem.CarType;\n    processedItem.BusStatus = BusEventItem.BusStatus;\n    processedItem.BusID = BusEventItem.BusID;\n    processedItem.CarOnStop = BusEventItem.CarOnStop;\n\n    // check whether this bus is on the route\n    const thisRouteID = parseInt(BusEventItem.RouteID);\n    const thisBusID = String(BusEventItem.BusID);\n    let isOnThisRoute: boolean = false;\n    let index: number = 0;\n    if (thisRouteID === RouteID || PathAttributeId.indexOf(thisRouteID) > -1 || thisRouteID === RouteID * 10) {\n      isOnThisRoute = true;\n      index = thisBusID.charCodeAt(0) * Math.pow(10, -5);\n    } else {\n      isOnThisRoute = false;\n      index = thisBusID.charCodeAt(0);\n    }\n    processedItem.onThisRoute = isOnThisRoute;\n    processedItem.index = index;\n\n    // collect data from 'BusData'\n    let thisBusData = {} as BusDataItem;\n    if (hasOwnProperty(BusDataObj, thisBusID)) {\n      thisBusData = BusDataObj[thisBusID];\n    } else {\n      continue;\n    }\n    processedItem.position = {\n      latitude: parseFloat(thisBusData.Latitude),\n      longitude: parseFloat(thisBusData.Longitude)\n    };\n\n    // search data from 'Route'\n    let searchedRoute = {};\n    let isRouteSearched = false;\n    for (const key in Route) {\n      const thisRouteItem = Route[key];\n      const pid = thisRouteItem.pid;\n      if (pid.indexOf(thisRouteID) > -1) {\n        searchedRoute = thisRouteItem;\n        isRouteSearched = true;\n        break;\n      }\n    }\n    processedItem.RouteName = isRouteSearched ? searchedRoute.n : '未知路線';\n    processedItem.RouteID = isRouteSearched ? searchedRoute.id : null;\n\n    const StopKey = `s_${BusEventItem.StopID}`;\n    if (!hasOwnProperty(result, StopKey)) {\n      result[StopKey] = [];\n    }\n    result[StopKey].push(processedItem);\n    // Handle multiple buses (of the same route) on a stop\n  }\n  return result;\n}\n\nexport function batchFindBusesForLocation(BusEvent: BusEvent, BusData: BusData, Route: SimplifiedRoute, StopIDList: Array<number>): BatchFoundBuses {\n  const result = {} as BatchFoundBuses;\n  const BusDataObj: {\n    [BusID: string]: BusDataItem;\n  } = {};\n  for (const BusDataItem of BusData) {\n    const thisBusID = BusDataItem.BusID;\n    BusDataObj[thisBusID] = BusDataItem;\n  }\n\n  for (const BusEventItem of BusEvent) {\n    const processedItem = {} as BatchFoundBus;\n\n    const thisStopID = parseInt(BusEventItem.StopID);\n    const thisRouteID = parseInt(BusEventItem.RouteID);\n    const thisBusID = String(BusEventItem.BusID);\n\n    // Check whether this bus is on one of the specified stops\n    if (StopIDList.indexOf(thisStopID) < 0) {\n      continue;\n    }\n\n    processedItem.index = thisBusID.charCodeAt(0);\n    processedItem.onThisRoute = true; // Every entry in Location is stop-route pair\n\n    // Collect data from 'BusEvent'\n    processedItem.CarType = BusEventItem.CarType;\n    processedItem.BusStatus = BusEventItem.BusStatus;\n    processedItem.BusID = BusEventItem.BusID;\n    processedItem.CarOnStop = BusEventItem.CarOnStop;\n\n    // Collect data from 'BusData'\n    let thisBusData = {} as BusDataItem;\n    if (hasOwnProperty(BusDataObj, thisBusID)) {\n      thisBusData = BusDataObj[thisBusID];\n    } else {\n      continue;\n    }\n    processedItem.position = {\n      latitude: parseFloat(thisBusData.Latitude),\n      longitude: parseFloat(thisBusData.Longitude)\n    };\n\n    // Search data from 'Route'\n    let searchedRoute = {};\n    let isRouteSearched = false;\n    for (const key in Route) {\n      const thisRouteItem = Route[key];\n      const pid = thisRouteItem.pid;\n      if (pid.indexOf(thisRouteID) > -1) {\n        searchedRoute = thisRouteItem;\n        isRouteSearched = true;\n        break;\n      }\n    }\n    processedItem.RouteName = isRouteSearched ? searchedRoute.n : '未知路線';\n    processedItem.RouteID = isRouteSearched ? searchedRoute.id : null;\n\n    const StopKey = `s_${thisStopID}`;\n    if (!hasOwnProperty(result, StopKey)) {\n      result[StopKey] = [];\n    }\n    result[StopKey].push(processedItem);\n  }\n  return result;\n}\n\ninterface FormattedBusStatus {\n  onStop: boolean;\n  situation: string;\n  text: string;\n}\n\ninterface FormattedBusPosition {\n  longitude: number;\n  latitude: number;\n}\n\nexport function parseCarType(CarType: '0' | '1' | '2' | '3'): '一般' | '低底盤' | '大復康巴士' | '狗狗友善專車' | '未知類型' {\n  let type = '';\n  switch (CarType) {\n    case '0':\n      type = '一般';\n      break;\n    case '1':\n      type = '低底盤';\n      break;\n    case '2':\n      type = '大復康巴士';\n      break;\n    case '3':\n      type = '狗狗友善專車';\n      break;\n    default:\n      type = '未知類型';\n  }\n  return type;\n}\n\nexport function parseCarOnStop(CarOnStop: '0' | '1'): string {\n  let onStop = '';\n  switch (CarOnStop) {\n    case '0':\n      onStop = '離站';\n      break;\n    case '1':\n      onStop = '進站';\n      break;\n    default:\n      onStop = '未知狀態'; // Handle unexpected values if necessary\n  }\n  return onStop;\n}\n\nexport function parseBusStatus(BusStatus: '0' | '1' | '2' | '3' | '4' | '5' | '99'): string {\n  let situation = '';\n  switch (BusStatus) {\n    case '0':\n      situation = '正常';\n      break;\n    case '1':\n      situation = '車禍';\n      break;\n    case '2':\n      situation = '故障';\n      break;\n    case '3':\n      situation = '塞車';\n      break;\n    case '4':\n      situation = '緊急求援';\n      break;\n    case '5':\n      situation = '加油';\n      break;\n    case '99':\n      situation = '非營運狀態';\n      break;\n    default:\n      situation = '未知狀態'; // Handle unexpected values if necessary\n  }\n  return situation;\n}\n\nexport interface FormattedBus {\n  type: '一般' | '低底盤' | '大復康巴士' | '狗狗友善專車' | '未知類型';\n  carNumber: string;\n  status: FormattedBusStatus;\n  RouteName: string;\n  onThisRoute: boolean;\n  index: number;\n  position: FormattedBusPosition;\n}\n\nexport function formatBus(batchFoundBus: BatchFoundBus): FormattedBus {\n  const result = {} as FormattedBus;\n\n  const CarType = batchFoundBus.CarType;\n  const type = parseCarType(CarType);\n  result.type = type;\n\n  const CarOnStop = batchFoundBus.CarOnStop;\n  const onStop = parseCarOnStop(CarOnStop);\n\n  const BusStatus = batchFoundBus.BusStatus;\n  const situation = parseBusStatus(BusStatus);\n\n  result.carNumber = batchFoundBus.BusID;\n  result.status = {\n    onStop: onStop,\n    situation: situation,\n    text: `${onStop} | ${situation}`\n  };\n  result.RouteName = batchFoundBus.RouteName;\n  result.onThisRoute = batchFoundBus.onThisRoute;\n  result.index = batchFoundBus.index;\n  result.position = batchFoundBus.position;\n  return result;\n}\n","import { hasOwnProperty } from '../../tools/index';\nimport { clamp } from '../../tools/math';\nimport { pakoInflate } from '../../tools/pako-inflate/index';\nimport { timeStampToNumber } from '../../tools/time';\nimport { recordDataUsage } from '../analytics/data-usage/index';\n\ntype FetchTaskRequest = [resolve: Function, reject: Function, requestID: string, tag: string];\n\ninterface FetchTask {\n  processing: boolean;\n  requests: Array<FetchTaskRequest>;\n  failed: boolean;\n  timestamp: number;\n  result: any;\n}\n\ntype FetchTasks = { [url: string]: FetchTask };\n\nconst tasks: FetchTasks = {};\n\nconst TTL = 30000;\nconst FetchError = new Error('FetchError');\n\nexport async function fetchData(url: string, requestID: string, tag: string, fileType: 'json' | 'xml'): Promise<object> {\n  // Check concurrency\n  if (hasOwnProperty(tasks, url)) {\n    if (tasks[url].processing) {\n      return await new Promise((resolve, reject) => {\n        tasks[url].requests.push([resolve, reject, requestID, tag]);\n      });\n    } else if (tasks[url].result !== null && new Date().getTime() <= tasks[url].timestamp) {\n      setDataReceivingProgress(requestID, tag, 0, true);\n      return tasks[url].result;\n    }\n  } else {\n    tasks[url] = {\n      processing: true,\n      requests: [],\n      failed: false,\n      timestamp: -1,\n      result: null\n    };\n  }\n\n  // Fetch data\n  const response = await fetch(url);\n  if (!response.ok) {\n    setDataReceivingProgress(requestID, tag, 0, true);\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  // Read chunks\n  const contentLength = parseInt(String(response.headers.get('content-length')));\n  const reader = response.body.getReader();\n  const chunks = [];\n  let receivedLength = 0;\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    chunks.push(value);\n    receivedLength += value.length;\n    const progress = receivedLength / contentLength;\n    setDataReceivingProgress(requestID, tag, progress, false);\n    if (hasOwnProperty(tasks, url)) {\n      for (const request of tasks[url].requests) {\n        setDataReceivingProgress(request[2], request[3], progress, false);\n      }\n    }\n  }\n\n  // Concatenate all the chunks into a single Uint8Array\n  const uint8Array = new Uint8Array(receivedLength);\n  let position = 0;\n  for (const chunk of chunks) {\n    uint8Array.set(chunk, position);\n    position += chunk.length;\n  }\n\n  // Create a blob from the concatenated Uint8Array\n  const blob = new Blob([uint8Array], { type: 'application/gzip' });\n  const arrayBuffer = await blob.arrayBuffer();\n  const inflatedData = await pakoInflate(arrayBuffer);\n\n  let result;\n  switch (fileType) {\n    case 'json':\n      if (/^<!doctype html>/.test(inflatedData)) {\n        result = await fetchData(url.replace('https://tcgbusfs.blob.core.windows.net/', 'https://erichsia7.github.io/bus-alternative-static-apis/'), requestID, tag, fileType);\n      } else {\n        result = JSON.parse(inflatedData);\n      }\n      break;\n    case 'xml':\n      result = inflatedData;\n      break;\n    default:\n      break;\n  }\n\n  // Record data usage\n  const now = new Date();\n  await recordDataUsage(contentLength, now);\n\n  if (result) {\n    // Resolve promises\n    if (hasOwnProperty(tasks, url)) {\n      const progress = receivedLength / contentLength;\n      let request = tasks[url].requests.shift();\n      while (request) {\n        request[0](result);\n        setDataReceivingProgress(request[2], request[3], progress, false);\n        request = tasks[url].requests.shift();\n      }\n      tasks[url].result = result;\n      tasks[url].timestamp = now.getTime() + TTL;\n      tasks[url].processing = false;\n    }\n    discardExpiredFetchTasks();\n    return result;\n  } else {\n    // Reject promises\n    if (hasOwnProperty(tasks, url)) {\n      let request = tasks[url].requests.shift();\n      while (request) {\n        request[1](FetchError);\n        setDataReceivingProgress(request[2], request[3], 0, true);\n        request = tasks[url].requests.shift();\n      }\n      tasks[url].failed = true;\n    }\n    discardExpiredFetchTasks();\n    throw FetchError;\n  }\n}\n\nfunction discardExpiredFetchTasks(): void {\n  const now = new Date().getTime();\n  for (const url in tasks) {\n    if (hasOwnProperty(tasks, url)) {\n      if (!tasks[url].processing) {\n        if (now > tasks[url].timestamp) {\n          delete tasks[url];\n          continue;\n        }\n      }\n      if (tasks[url].failed) {\n        delete tasks[url];\n        continue;\n      }\n    }\n  }\n}\n\nexport type DataReceivingProgress = {\n  [requestID: string]: {\n    [tag: string]: {\n      expel: boolean;\n      progress: number;\n      total: number;\n    };\n  };\n};\n\nconst dataReceivingProgress: DataReceivingProgress = {};\n\nexport function setDataReceivingProgress(requestID: string, tag: string, progress: number, expel: boolean): void {\n  if (!hasOwnProperty(dataReceivingProgress, requestID)) {\n    dataReceivingProgress[requestID] = {};\n  }\n  if (hasOwnProperty(dataReceivingProgress[requestID], tag)) {\n    if (expel) {\n      dataReceivingProgress[requestID][tag].expel = true;\n    } else {\n      dataReceivingProgress[requestID][tag].expel = false;\n      dataReceivingProgress[requestID][tag].progress = progress;\n    }\n    broadcastDataReceivingProgress(requestID, 'run');\n  } else {\n    dataReceivingProgress[requestID][tag] = { expel: false, progress: progress, total: 1 };\n    broadcastDataReceivingProgress(requestID, 'start');\n  }\n}\n\nexport function getDataReceivingProgress(requestID: string): number {\n  if (hasOwnProperty(dataReceivingProgress, requestID)) {\n    if (typeof dataReceivingProgress[requestID] === 'object') {\n      let total: number = 0;\n      let received: number = 0;\n      for (const key in dataReceivingProgress[requestID]) {\n        if (!dataReceivingProgress[requestID][key].expel) {\n          total += dataReceivingProgress[requestID][key].total;\n          received += dataReceivingProgress[requestID][key].progress;\n        }\n      }\n      const progress = clamp(received / total, 0, 1);\n      return progress === Infinity || isNaN(progress) ? 1 : progress;\n    }\n  }\n  return 1;\n}\n\nexport function deleteDataReceivingProgress(requestID: string): void {\n  if (hasOwnProperty(dataReceivingProgress, requestID)) {\n    delete dataReceivingProgress[requestID];\n    broadcastDataReceivingProgress(requestID, 'end');\n  }\n}\n\nexport interface DataReceivingProgressEventDict {\n  target: string;\n  stage: 'start' | 'run' | 'end';\n  progress: number;\n}\n\nexport type DataReceivingProgressEvent = CustomEvent<DataReceivingProgressEventDict>;\n\nexport function broadcastDataReceivingProgress(requestID: string, stage: DataReceivingProgressEventDict['stage']): void {\n  const eventDict: DataReceivingProgressEventDict = {\n    target: requestID,\n    stage: stage,\n    progress: getDataReceivingProgress(requestID)\n  };\n  const event = new CustomEvent(requestID, { detail: eventDict });\n  document.dispatchEvent(event);\n}\n\nexport type DataUpdateTime = { [key: string]: number };\n\nexport const dataUpdateTime: DataUpdateTime = {};\n\nexport function setDataUpdateTime(requestID: string, timestamp: string | number, timeZoneOffset: number): void {\n  if (!hasOwnProperty(dataUpdateTime, requestID)) {\n    dataUpdateTime[requestID] = 0;\n  }\n  let timeNumber = 0;\n  if (typeof timestamp === 'string') {\n    timeNumber = timeStampToNumber(timestamp, timeZoneOffset);\n  }\n  if (timeNumber > dataUpdateTime[requestID]) {\n    dataUpdateTime[requestID] = timeNumber;\n  }\n}\n\nexport function getDataUpdateTime(requestID: string): number {\n  if (hasOwnProperty(dataUpdateTime, requestID)) {\n    return dataUpdateTime[requestID] * 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function deleteDataUpdateTime(requestID: string): void {\n  if (hasOwnProperty(dataUpdateTime, requestID)) {\n    delete dataUpdateTime[requestID];\n  }\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { hasOwnProperty } from '../../tools/index';\nimport { BusData, getBusData } from '../apis/getBusData/index';\nimport { BusEvent, getBusEvent } from '../apis/getBusEvent/index';\nimport { CarInfoItem, getCarInfo, SimplifiedCarInfo } from '../apis/getCarInfo/index';\nimport { getLocation, SimplifiedLocation } from '../apis/getLocation/index';\nimport { getStop, SimplifiedStop } from '../apis/getStop/index';\nimport { parseBusStatus, parseCarOnStop, parseCarType } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime } from '../apis/loader';\nimport { searchRouteByPathAttributeId } from '../search/index';\n\nexport interface integratedBus {\n  properties: Array<{\n    key: string;\n    icon: MaterialSymbols;\n    value: string;\n  }>;\n  RouteID: number;\n  FullPathAttributeId: Array<number>;\n}\n\nexport async function integrateBus(id: CarInfoItem['BusId'], requestID: string): Promise<integratedBus> {\n  const carKey = `c_${id}`;\n  const [CarInfo, BusData, BusEvent] = (await Promise.all([getCarInfo(requestID, true), getBusData(requestID), getBusEvent(requestID)])) as [SimplifiedCarInfo, BusData, BusEvent];\n  const [Stop, Location] = (await Promise.all([getStop(requestID), getLocation(requestID, 0)])) as [SimplifiedStop, SimplifiedLocation];\n\n  let result: integratedBus = {\n    properties: [],\n    LocationName: ''\n  };\n\n  // Collect data from CarInfo\n  let thisCar = {};\n  if (hasOwnProperty(CarInfo, carKey)) {\n    thisCar = CarInfo[carKey];\n  } else {\n    return result;\n  }\n\n  const thisCarNumber = thisCar.CarNum;\n  result.properties.push({\n    key: 'car_number',\n    icon: 'tag',\n    value: thisCarNumber\n  });\n\n  const thisCarType = thisCar.CarType;\n  const type = parseCarType(thisCarType);\n  result.properties.push({\n    key: 'car_type',\n    icon: 'directions_bus',\n    value: type\n  });\n\n  // Collect data from BusData\n  let thisBusDataItem = {};\n  for (const BusDataItem of BusData) {\n    const thisBusDataItemBusID = BusDataItem.BusID;\n    if (thisBusDataItemBusID === thisCarNumber) {\n      thisBusDataItem = BusDataItem;\n      break;\n    }\n  }\n  const thisBusDataItemPathAttributeId = parseInt(thisBusDataItem.RouteID);\n  // result.PathAttributeId = thisBusDataItemPathAttributeId;\n  const thisBusDataItemBusStatus = thisBusDataItem.BusStatus;\n  const situation = parseBusStatus(thisBusDataItemBusStatus);\n  const thisBusDataItemGoBack = parseInt(thisBusDataItem.GoBack);\n\n  // Collect data from BusEvent\n  let thisBusEventItem = {};\n  for (const BusEventItem of BusEvent) {\n    const thisBusEventItemBusID = BusEventItem.BusID;\n    if (thisBusEventItemBusID === thisCarNumber) {\n      thisBusEventItem = BusEventItem;\n      break;\n    }\n  }\n\n  const thisBusEventItemCarOnStop = thisBusEventItem.CarOnStop;\n  const onStop = parseCarOnStop(thisBusEventItemCarOnStop);\n  result.properties.push({\n    key: 'status',\n    icon: 'vital_signs',\n    value: `${onStop} | ${situation}`\n  });\n  const thisBusEventItemStopID = thisBusEventItem.StopID;\n\n  // Search routes\n  const searchedRoutes = await searchRouteByPathAttributeId(thisBusDataItemPathAttributeId);\n  let searchedRoute = {};\n  if (searchedRoutes.length > 0) {\n    searchedRoute = searchedRoutes[0];\n  } else {\n    return result;\n  }\n  const thisRouteID = searchedRoute.id;\n  const thisRouteFullPathAttributeId = searchedRoute.pid;\n  const thisRouteName = searchedRoute.n;\n  const thisRouteDeparture = searchedRoute.dep;\n  const thisRouteDestination = searchedRoute.des;\n  const thisRouteDirection = [thisRouteDestination, thisRouteDeparture, ''][thisBusDataItemGoBack ? thisBusDataItemGoBack : 0];\n  result.properties.push({\n    key: 'route',\n    icon: 'route',\n    value: `${thisRouteName} - 往${thisRouteDirection}`\n  });\n\n  result.RouteID = thisRouteID;\n  result.FullPathAttributeId = thisRouteFullPathAttributeId;\n\n  // Collect data from Stop\n  const StopKey = `s_${thisBusEventItemStopID}`;\n  let thisStopItem = {};\n  if (hasOwnProperty(Stop, StopKey)) {\n    thisStopItem = Stop[StopKey];\n  } else {\n    return result;\n  }\n  const thisStopItemStopLocationId = thisStopItem.stopLocationId;\n\n  // Collect data drom Location\n  const LocationKey = `l_${thisStopItemStopLocationId}`;\n  const thisLocationItem = Location[LocationKey];\n  const thisLocationItemName = thisLocationItem.n;\n  result.properties.push({\n    key: 'location_name',\n    icon: 'location_on',\n    value: thisLocationItemName\n  });\n\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  return result;\n}\n","import { FolderWithContentArray, listFoldersWithContent } from '../folder/index';\nimport { listPersonalSchedules, PersonalScheduleArray } from '../personal-schedule/index';\nimport { listRecentViews, RecentViewArray } from '../recent-views/index';\nimport { listSettingsWithOptions, SettingsWithOptionsArray } from '../settings/index';\n\nexport interface ExportedDataVersion1 {\n  time: string;\n  version: 1;\n  folders: FolderWithContentArray;\n}\n\nexport interface ExportedDataVersion2 {\n  time: string;\n  version: 2;\n  folders: FolderWithContentArray;\n  settings: SettingsWithOptionsArray;\n}\n\nexport interface ExportedDataVersion3 {\n  time: string;\n  version: 3;\n  folders: FolderWithContentArray;\n  settings: SettingsWithOptionsArray;\n  personal_schedules: PersonalScheduleArray;\n}\n\nexport interface ExportedDataVersion4 {\n  time: string;\n  version: 4;\n  folders: FolderWithContentArray;\n  settings: SettingsWithOptionsArray;\n  personal_schedules: PersonalScheduleArray;\n  recent_views: RecentViewArray;\n}\n\nexport type ExportedData = ExportedDataVersion1 | ExportedDataVersion2 | ExportedDataVersion3 | ExportedDataVersion4;\n\nexport async function exportData(): Promise<string> {\n  const foldersWithContent = await listFoldersWithContent();\n  const settings = listSettingsWithOptions();\n  const personalSchedules = await listPersonalSchedules();\n  const RecentViews = await listRecentViews();\n  let result: ExportedDataVersion4 = {};\n  result.time = new Date().toISOString();\n  result.version = 4;\n  result.folders = foldersWithContent;\n  result.settings = settings;\n  result.personal_schedules = personalSchedules;\n  result.recent_views = RecentViews;\n  return JSON.stringify(result);\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\n// import { generateLabelFromAddresses } from '../../tools/address';\n// import { CardinalDirection, getCardinalDirectionFromVector } from '../../tools/cardinal-direction';\nimport { generateIdentifier, hasOwnProperty } from '../../tools/index';\n// import { generateDirectionLabels, generateLetterLabels } from '../../tools/labels';\n// import { normalizeVector } from '../../tools/math';\nimport { collectBusArrivalTimeData } from '../analytics/bus-arrival-time/index';\nimport { collectUpdateRateData } from '../analytics/update-rate/index';\nimport { EstimateTime, EstimateTimeItem, getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, MergedLocation, MergedLocationItem, SimplifiedLocation } from '../apis/getLocation/index';\nimport { getMaterialSymbolsSearchIndex } from '../apis/getMaterialSymbolsSearchIndex/index';\nimport { getRoute, SimplifiedRoute, SimplifiedRouteItem } from '../apis/getRoute/index';\nimport { getStop, SimplifiedStop } from '../apis/getStop/index';\nimport { EstimateTimeStatus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue, SettingSelectOptionRefreshIntervalValue } from '../settings/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\n\ninterface FolderContentRouteEndPoints {\n  departure: string;\n  destination: string;\n}\n\nexport interface FolderContentStopRoute {\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n  id: number;\n}\n\nexport interface FolderContentStop {\n  type: 'stop';\n  id: number;\n  timestamp: number;\n  name: string;\n  direction: number;\n  route: FolderContentStopRoute;\n}\n\nexport interface FolderContentRoute {\n  type: 'route';\n  id: number;\n  timestamp: number;\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n}\n\nexport interface FolderContentLocation {\n  type: 'location';\n  id: string; // hash\n  timestamp: number;\n  name: string;\n}\n\nexport interface FolderContentBus {\n  type: 'bus';\n  id: number; // CarID\n  timestamp: number;\n  busID: string; // BusID\n}\n\nexport interface FolderContentEmpty {\n  type: 'empty';\n  id: number;\n}\n\nexport type FolderContent = FolderContentStop | FolderContentRoute | FolderContentLocation | FolderContentBus | FolderContentEmpty;\n\nexport interface Folder {\n  name: string;\n  icon: MaterialSymbols;\n  id: string;\n  timestamp: number;\n}\n\nexport type FolderArray = Array<Folder>;\n\nexport interface FolderWithContent extends Folder {\n  content: Array<FolderContent>;\n  contentLength: number;\n}\n\nexport type FolderWithContentArray = Array<FolderWithContent>;\n\nexport interface FolderWithContentLength extends Folder {\n  contentLength: number;\n}\n\nexport type FolderWithContentLengthArray = Array<FolderWithContentLength>;\n\nconst FolderList: { [key: string]: Folder } = {};\n\nexport async function initializeFolderList() {\n  const folderKeys = await lfListItemKeys(11);\n  for (const folderKey of folderKeys) {\n    const thisFolderJSON = await lfGetItem(11, folderKey);\n    if (thisFolderJSON) {\n      const thisFolderObject = JSON.parse(thisFolderJSON) as Folder;\n      if (!hasOwnProperty(FolderList, folderKey)) {\n        FolderList[folderKey] = thisFolderObject;\n      }\n    }\n  }\n}\n\nexport async function createFolder(name: Folder['name'], icon: Folder['icon']): Promise<Folder['id'] | false> {\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!hasOwnProperty(materialSymbolsSearchIndex.symbols, icon)) return false;\n\n  // Check existence\n  const folderID = generateIdentifier();\n  const folderKey = `f_${folderID}`;\n  if (hasOwnProperty(FolderList, folderKey)) {\n    return false;\n  }\n  const existingFolder = await lfGetItem(11, folderKey);\n  if (existingFolder) {\n    return false;\n  }\n\n  // Generate folder\n  const nowTime = new Date().getTime();\n  let newFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: nowTime\n  };\n\n  // Save folder\n  FolderList[folderKey] = newFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(newFolder));\n  await lfSetItem(12, folderKey, JSON.stringify([]));\n  return folderID;\n}\n\nexport async function updateFolder(folderID: Folder['id'], name: Folder['name'], icon: Folder['icon']): Promise<boolean> {\n  const folderKey: string = `f_${folderID}`;\n\n  // Check existence\n  const existingFolderJSON = await lfGetItem(11, folderKey);\n  if (!existingFolderJSON) {\n    return false;\n  }\n  const existingFolderObject = JSON.parse(existingFolderJSON) as Folder;\n\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!hasOwnProperty(materialSymbolsSearchIndex.symbols, icon)) return false;\n\n  // Generate folder\n  const modifiedFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: existingFolderObject.timestamp\n  };\n\n  // Save folder\n  FolderList[folderKey] = modifiedFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(modifiedFolder));\n  return true;\n}\n\nexport function getFolder(folderID: Folder['id']): Folder | false {\n  const folderKey: string = `f_${folderID}`;\n  if (!hasOwnProperty(FolderList, folderKey)) {\n    return false;\n  }\n  const folderObject: Folder = {\n    name: FolderList[folderKey].name,\n    icon: FolderList[folderKey].icon,\n    id: FolderList[folderKey].id,\n    timestamp: FolderList[folderKey].timestamp\n  };\n  return folderObject;\n  // return cloneDeep(Folders[folderKey]);\n}\n\nexport function listFolders(): FolderArray {\n  const result = [];\n  for (const folderKey in FolderList) {\n    const folderObject: Folder = {\n      name: FolderList[folderKey].name,\n      icon: FolderList[folderKey].icon,\n      id: FolderList[folderKey].id,\n      timestamp: FolderList[folderKey].timestamp\n    };\n    result.push(folderObject);\n  }\n  result.sort(function (a, b) {\n    return a.timestamp - b.timestamp;\n  });\n  return result;\n}\n\nexport async function listFolderContent(folderID: Folder['id']): Promise<Array<FolderContent>> {\n  const result: Array<FolderContent> = [];\n\n  const folderKey: string = `f_${folderID}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return result;\n  }\n\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return result;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0) {\n    const emptyItem: FolderContentEmpty = {\n      type: 'empty',\n      id: 0\n    };\n    result.push(emptyItem);\n    return result;\n  }\n\n  for (const thisFolderContentKey of thisFolderContentIndexArray) {\n    const thisContentJSON = await lfGetItem(13, thisFolderContentKey);\n    if (thisContentJSON) {\n      const thisContentObject = JSON.parse(thisContentJSON) as FolderContent;\n      result.push(thisContentObject);\n    }\n  }\n  return result;\n}\n\nasync function getFolderContentLength(folderID: Folder['id']): Promise<number> {\n  const folderKey: string = `f_${folderID}`;\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return 0;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  return thisFolderContentIndexArray.length;\n}\n\nexport async function listFoldersWithContent(): Promise<FolderWithContentArray> {\n  const folders = listFolders();\n  const result: FolderWithContentArray = [];\n  for (const folder of folders) {\n    const folderContent = await listFolderContent(folder.id);\n    const folderContentLength = await getFolderContentLength(folder.id);\n    result.push({\n      name: folder.name,\n      icon: folder.icon,\n      id: folder.id,\n      timestamp: folder.timestamp,\n      content: folderContent,\n      contentLength: folderContentLength\n    });\n  }\n  return result;\n}\n\nexport async function listFoldersWithContentLength(): Promise<FolderWithContentLengthArray> {\n  const folders = listFolders();\n  const result: FolderWithContentLengthArray = [];\n  for (const folder of folders) {\n    const folderContentLength = await getFolderContentLength(folder.id);\n    result.push({\n      name: folder.name,\n      icon: folder.icon,\n      id: folder.id,\n      timestamp: folder.timestamp,\n      contentLength: folderContentLength\n    });\n  }\n  return result;\n}\n\nexport async function listAllFolderContent(types: Array<FolderContent['type']>): Promise<Array<FolderContent>> {\n  let useFilter: boolean = true;\n  if (typeof types !== 'object' || !Array.isArray(types)) {\n    useFilter = false;\n  }\n  const result: Array<FolderContent> = [];\n  const keys = await lfListItemKeys(13);\n  for (const key of keys) {\n    const json = await lfGetItem(13, key);\n    if (json) {\n      const object = JSON.parse(json) as FolderContent;\n      if (useFilter) {\n        if (types.indexOf(object.type) > -1) {\n          result.push(object);\n        }\n      } else {\n        result.push(object);\n      }\n    }\n  }\n  return result;\n}\n\nexport interface integratedFolderContentStopRoute extends FolderContentStopRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentStop extends FolderContentStop {\n  status: EstimateTimeStatus;\n  route: integratedFolderContentStopRoute;\n}\n\nexport interface integratedFolderContentRoute extends FolderContentRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentLocation extends FolderContentLocation {\n  // labels: string;\n}\n\nexport interface integratedFolderContentBus extends FolderContentBus {}\n\nexport interface integratedFolderContentEmpty extends FolderContentEmpty {}\n\nexport type integratedFolderContent = integratedFolderContentStop | integratedFolderContentRoute | integratedFolderContentLocation | integratedFolderContentBus | integratedFolderContentEmpty;\n\nexport interface integratedFolder extends Folder {\n  content: Array<integratedFolderContent>;\n  contentLength: number;\n}\n\nexport interface integratedFolders {\n  folders: Array<integratedFolder>;\n  dataUpdateTime: number;\n}\n\nexport async function integrateFolders(requestID: string): Promise<integratedFolders> {\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n\n  const [foldersWithContent, Route, EstimateTime] = (await Promise.all([listFoldersWithContent(), getRoute(requestID, true), getEstimateTime(requestID)])) as [FolderWithContentArray, SimplifiedRoute, EstimateTime];\n  // const Location = (await getLocation(requestID, 1)) as MergedLocation;\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode') as number;\n  // const location_labels = getSettingOptionValue('location_labels');\n  const power_saving = getSettingOptionValue('power_saving') as boolean;\n  const refresh_interval_setting = getSettingOptionValue('refresh_interval') as SettingSelectOptionRefreshIntervalValue;\n\n  const StopIDs: Array<FolderContentStop['id']> = [];\n  for (const folderWithContent1 of foldersWithContent) {\n    for (let i = 0, l = folderWithContent1.content.length; i < l; i++) {\n      if (folderWithContent1.content[i].type === 'stop') {\n        StopIDs.push(folderWithContent1.content[i].id as FolderContentStop['id']);\n      }\n    }\n  }\n\n  const batchFoundEstimateTime: { [key: string]: EstimateTimeItem } = {};\n  for (const EstimateTimeItem of EstimateTime) {\n    if (StopIDs.indexOf(EstimateTimeItem.StopID) > -1) {\n      const thisStopKey: string = `s_${EstimateTimeItem.StopID}`;\n      batchFoundEstimateTime[thisStopKey] = EstimateTimeItem;\n    }\n  }\n\n  const folders: integratedFolders['folders'] = [];\n\n  for (const folderWithContent2 of foldersWithContent) {\n    // Initialize integratedFolder\n    const integratedFolder: integratedFolder = {\n      name: folderWithContent2.name,\n      icon: folderWithContent2.icon,\n      id: folderWithContent2.id,\n      timestamp: folderWithContent2.timestamp,\n      content: [],\n      contentLength: folderWithContent2.contentLength\n    };\n\n    for (const item of folderWithContent2.content) {\n      const integratedItem = item as integratedFolderContent;\n      switch (integratedItem.type) {\n        case 'stop': {\n          const thisStopKey = `s_${integratedItem.id}`;\n          let thisEstimateTime = {} as EstimateTimeItem;\n          if (hasOwnProperty(batchFoundEstimateTime, thisStopKey)) {\n            thisEstimateTime = batchFoundEstimateTime[thisStopKey];\n          } else {\n            break;\n          }\n          integratedItem.status = parseEstimateTime(thisEstimateTime.EstimateTime, time_formatting_mode);\n          const thisRouteKey = `r_${integratedItem.route.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.route.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'route': {\n          const thisRouteKey = `r_${integratedItem.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'location': {\n          /*\n          const thisLocationKey = `ml_${integratedItem.id}`;\n          const thisLocation = Location[thisLocationKey] as MergedLocationItem;\n          let labels: Array<string> = [];\n          switch (location_labels) {\n            case 'address':\n              labels = generateLabelFromAddresses(thisLocation.a);\n              break;\n            case 'letters':\n              const stopLocationIds = thisLocation.id;\n              const stopLocationQuantity = stopLocationIds.length;\n              labels = generateLetterLabels(stopLocationQuantity);\n              break;\n            case 'directions':\n              const setsOfVectors = thisLocation.v;\n              const cardinalDirections: Array<CardinalDirection> = [];\n              for (const vectorSet of setsOfVectors) {\n                let x: number = 0;\n                let y: number = 0;\n                for (const vector of vectorSet) {\n                  x += vector[0];\n                  y += vector[1];\n                }\n                const meanVector = normalizeVector([x, y]) as [number, number];\n                const cardinalDirection = getCardinalDirectionFromVector(meanVector);\n                cardinalDirections.push(cardinalDirection);\n              }\n\n              labels = generateDirectionLabels(cardinalDirections);\n              break;\n            default:\n              break;\n          }\n          integratedItem.labels = labels.join(' - ');\n          */\n          break;\n        }\n        case 'bus':\n          break;\n        case 'empty':\n          break;\n        default:\n          break;\n      }\n      integratedFolder.content.push(integratedItem);\n    }\n    folders.push(integratedFolder);\n  }\n\n  const result: integratedFolders = {\n    folders: folders,\n    dataUpdateTime: getDataUpdateTime(requestID)\n  };\n\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n\n  if (!power_saving) {\n    if (refresh_interval_setting.dynamic) {\n      await collectUpdateRateData(EstimateTime);\n    }\n    await collectBusArrivalTimeData(EstimateTime);\n  }\n\n  return result;\n}\n\nexport async function saveToFolder(folderID: Folder['id'], content: FolderContent): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const contentKey = `${content.type}_${content.id}`;\n  const thisFolder = getFolder(folderID);\n\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0 || thisFolderContentIndexArray.indexOf(contentKey) < 0) {\n    thisFolderContentIndexArray.push(contentKey);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n    await lfSetItem(13, contentKey, JSON.stringify(content));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport async function isFolderContentSaved(type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderContentKeyToCheck = `${type}_${id}`;\n\n  const keys = await lfListItemKeys(12);\n  for (const key of keys) {\n    const thisFolderContentIndexJSON = (await lfGetItem(12, key)) as string;\n    if (!thisFolderContentIndexJSON) {\n      continue;\n    }\n    const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n    if (thisFolderContentIndexArray.indexOf(folderContentKeyToCheck) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport async function removeFromFolder(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n\n  // Check existence\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  // Remove reference from folder content index\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 0) {\n    thisFolderContentIndexArray.splice(index, 1);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n  }\n\n  // Remove content if there are no other references\n  const isSaved = await isFolderContentSaved(type, id);\n  if (isSaved === false) {\n    await lfRemoveItem(13, thisFolderContentKey);\n  }\n  return true;\n}\n\nexport async function saveStop(folderID: Folder['id'], StopID: number, RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Stop = (await getStop(requestID)) as SimplifiedStop;\n  const Location = (await getLocation(requestID, 0)) as SimplifiedLocation;\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n\n  const thisStop = Stop[`s_${StopID}`];\n  const thisStopDirection: number = parseInt(thisStop.goBack);\n  const thisLocation = Location[`l_${thisStop.stopLocationId}`];\n  const thisStopName: string = thisLocation.n;\n\n  const thisRoute = Route[`r_${RouteID}`];\n  const thisRouteName: string = thisRoute.n;\n  const thisRouteDeparture: string = thisRoute.dep;\n  const thisRouteDestination: string = thisRoute.des;\n\n  const newContent: FolderContentStop = {\n    type: 'stop',\n    id: StopID,\n    timestamp: new Date().getTime(),\n    name: thisStopName,\n    direction: thisStopDirection,\n    route: {\n      name: thisRouteName,\n      endPoints: {\n        departure: thisRouteDeparture,\n        destination: thisRouteDestination\n      },\n      id: RouteID\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveRoute(folderID: Folder['id'], RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisRouteKey = `r_${RouteID}`;\n  let thisRoute = {} as SimplifiedRouteItem;\n  if (hasOwnProperty(Route, thisRouteKey)) {\n    thisRoute = Route[thisRouteKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentRoute = {\n    type: 'route',\n    id: RouteID,\n    timestamp: new Date().getTime(),\n    name: thisRoute.n,\n    endPoints: {\n      departure: thisRoute.dep,\n      destination: thisRoute.des\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveLocation(folderID: Folder['id'], hash: string): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisLocationKey = `ml_${hash}`;\n  let thisLocation = {} as MergedLocationItem;\n  if (hasOwnProperty(Location, thisLocationKey)) {\n    thisLocation = Location[thisLocationKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentLocation = {\n    type: 'location',\n    id: hash,\n    timestamp: new Date().getTime(),\n    name: thisLocation.n\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\n// TODO: Save Bus\n\nexport async function updateFolderContentIndex(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id'], direction: 'up' | 'down'): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 1) {\n    let offset: number = 0;\n    switch (direction) {\n      case 'up':\n        offset = -1;\n        break;\n      case 'down':\n        offset = 1;\n        break;\n      default:\n        offset = 0;\n        break;\n    }\n    thisFolderContentIndexArray.splice(index, 1);\n    thisFolderContentIndexArray.splice(index + offset, 0, thisFolderContentKey);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n    return true;\n  } else {\n    return false;\n  }\n}\n","import { ExportedData } from '../export/index';\nimport { createFolder, FolderWithContentArray, saveToFolder, updateFolder } from '../folder/index';\nimport { createPersonalSchedule, getPersonalSchedule, PersonalScheduleArray, updatePersonalSchedule } from '../personal-schedule/index';\nimport { getRecentView, logRecentView, RecentViewArray } from '../recent-views/index';\nimport { changeSettingOption, getSetting, SettingsWithOptionsArray } from '../settings/index';\nimport { lfGetItem } from '../storage/index';\n\nexport async function importFolders(data: FolderWithContentArray): Promise<boolean> {\n  for (const FolderWithContent of data) {\n    const folder = FolderWithContent;\n    var update = false;\n    var creation = false;\n    const folderKey: string = `f_${folder.id}`;\n    const existingFolder: string = await lfGetItem(11, folderKey);\n    if (existingFolder) {\n      update = await updateFolder(folder.id, folder.name, folder.icon);\n    } else {\n      creation = await createFolder(folder.name, folder.icon);\n    }\n    if (update) {\n      for (const content of FolderWithContent.content) {\n        await saveToFolder(FolderWithContent.id, content);\n      }\n    }\n    if (creation) {\n      for (const content of FolderWithContent.content) {\n        await saveToFolder(creation, content);\n      }\n    }\n  }\n}\n\nexport async function importSettings(data: SettingsWithOptionsArray): Promise<boolean> {\n  for (const SettingWithOption of data) {\n    const existingSetting = getSetting(SettingWithOption.key);\n    if (existingSetting) {\n      if (existingSetting.type === 'select') {\n        await changeSettingOption(SettingWithOption.key, SettingWithOption.option);\n      }\n    }\n  }\n  return true;\n}\n\nexport async function importPersonalSchedules(data: PersonalScheduleArray): Promise<boolean> {\n  for (const PersonalSchedule of data) {\n    const existingPersonalSchedule = await getPersonalSchedule(PersonalSchedule.id);\n    if (existingPersonalSchedule) {\n      await updatePersonalSchedule(PersonalSchedule);\n    } else {\n      await createPersonalSchedule(PersonalSchedule.name, PersonalSchedule.period.start.hours, PersonalSchedule.period.start.minutes, PersonalSchedule.period.end.hours, PersonalSchedule.period.end.minutes, PersonalSchedule.days);\n    }\n  }\n  return true;\n}\n\nexport async function importRecentViews(data: RecentViewArray): Promise<boolean> {\n  for (const RecentView of data) {\n    switch (RecentView.type) {\n      case 'route': {\n        const existingRecentViewRoute = await getRecentView('route', RecentView.id);\n        if (!existingRecentViewRoute) {\n          await logRecentView(RecentView.type, RecentView.id);\n        }\n        break;\n      }\n      case 'location': {\n        const existingRecentViewLocation = await getRecentView('location', RecentView.hash);\n        if (!existingRecentViewLocation) {\n          await logRecentView(RecentView.type, RecentView.hash);\n        }\n        break;\n      }\n      case 'bus': {\n        const existingRecentViewBus = await getRecentView('bus', RecentView.id);\n        if (!existingRecentViewBus) {\n          await logRecentView(RecentView.type, RecentView.id);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  return true;\n}\n\nexport async function importData(data: string): Promise<boolean> {\n  const parsedData: ExportedData = JSON.parse(data);\n  switch (parsedData.version) {\n    case 1:\n      await importFolders(parsedData.folders);\n      return true;\n      break;\n    case 2:\n      await importFolders(parsedData.folders);\n      await importSettings(parsedData.settings);\n      return true;\n      break;\n    case 3:\n      await importFolders(parsedData.folders);\n      await importSettings(parsedData.settings);\n      await importPersonalSchedules(parsedData.personal_schedules);\n      return true;\n      break;\n    case 4:\n      await importFolders(parsedData.folders);\n      await importSettings(parsedData.settings);\n      await importPersonalSchedules(parsedData.personal_schedules);\n      await importRecentViews(parsedData.recent_views);\n      return true;\n      break;\n    default:\n      return false;\n      break;\n  }\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { shareLocationPermalink, showLocationPermalinkQRCode } from '../../interface/location-details/index';\nimport { openSaveToFolder } from '../../interface/save-to-folder/index';\nimport { hasOwnProperty } from '../../tools/index';\nimport { getLocation, MergedLocation } from '../apis/getLocation/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime } from '../apis/loader';\n\nexport interface IntegratedLocationDetailsAction {\n  icon: MaterialSymbols;\n  action: Function;\n  key: string;\n  name: string;\n}\n\nexport type IntegratedLocationDetailsActionArray = Array<IntegratedLocationDetailsAction>;\n\nexport interface IntegratedLocationDetails {\n  actions: IntegratedLocationDetailsActionArray;\n  actionsQuantity: number;\n  hash: string;\n}\n\nexport async function integrateLocationDetails(hash: string, requestID: string): Promise<IntegratedLocationDetails> {\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisLocationKey = `ml_${hash}`;\n  if (!hasOwnProperty(Location, thisLocationKey)) {\n    return {\n      actions: [],\n      actionsQuantity: 0,\n      hash: hash\n    };\n  }\n  const actions: IntegratedLocationDetailsActionArray = [\n    {\n      icon: 'folder',\n      name: '儲存',\n      key: 'save-to-folder',\n      action: function () {\n        openSaveToFolder('location', [hash], null);\n      }\n    },\n    {\n      icon: 'ios_share',\n      name: '分享',\n      key: 'permalink',\n      action: function () {\n        shareLocationPermalink(hash);\n      }\n    },\n    {\n      icon: 'qr_code_2',\n      name: '二維條碼',\n      key: 'permalink-qr-code',\n      action: function () {\n        showLocationPermalinkQRCode(hash);\n      }\n    }\n  ];\n  const result: IntegratedLocationDetails = {\n    actions: actions,\n    actionsQuantity: actions.length,\n    hash: hash\n  };\n  return result;\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { addressToString, generateLabelFromAddresses } from '../../tools/address';\nimport { CardinalDirection, getCardinalDirectionFromVector } from '../../tools/cardinal-direction';\nimport { hasOwnProperty } from '../../tools/index';\nimport { generateDirectionLabels, generateLetterLabels } from '../../tools/labels';\nimport { normalizeVector } from '../../tools/math';\nimport { BusArrivalTime, getBusArrivalTimes } from '../analytics/bus-arrival-time/index';\nimport { getBusData } from '../apis/getBusData/index';\nimport { getBusEvent } from '../apis/getBusEvent/index';\nimport { EstimateTime, EstimateTimeItem, getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, MergedLocation } from '../apis/getLocation/index';\nimport { getRoute, SimplifiedRoute } from '../apis/getRoute/index';\nimport { getStop, SimplifiedStop } from '../apis/getStop/index';\nimport { batchFindBusesForLocation, EstimateTimeStatus, formatBus, FormattedBus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue } from '../settings/index';\nimport { getUserOrientation } from '../user-orientation/index';\n\ninterface BatchFoundEstimateTimeItem extends EstimateTimeItem {}\n\ntype BatchFoundEstimateTime = {\n  [key: string]: BatchFoundEstimateTimeItem;\n};\n\nfunction batchFindEstimateTime(EstimateTime: EstimateTime, StopIDList: Array<number>): BatchFoundEstimateTime {\n  const result = {};\n  for (const item of EstimateTime) {\n    if (StopIDList.indexOf(item.StopID) > -1) {\n      const thisStopKey: string = `s_${item.StopID}`;\n      result[thisStopKey] = item;\n    }\n  }\n  return result;\n}\n\ntype BatchFoundEstimateTimeRanking = {\n  [key: string]: IntegratedLocationItemRanking;\n};\n\nfunction rankBatchFoundEstimateTime(batchFoundEstimateTime: BatchFoundEstimateTime, StopIDList: Array<number>): BatchFoundEstimateTimeRanking {\n  // StopIDList act as a secondary filter\n  const result: BatchFoundEstimateTimeRanking = {};\n  const rankingArray: Array<[number, number]> = []; // StopID, EstimateTime\n  for (const thisStopKey in batchFoundEstimateTime) {\n    const thisBatchFoundEstimateTimeItem = batchFoundEstimateTime[thisStopKey];\n    const thisStopID = thisBatchFoundEstimateTimeItem.StopID;\n    const thisEstimateTime = parseInt(thisBatchFoundEstimateTimeItem.EstimateTime);\n    if (thisEstimateTime >= 0 && StopIDList.indexOf(thisStopID) > -1) {\n      rankingArray.push([thisStopID, thisEstimateTime]);\n    }\n  }\n  const rankingArrayLength = rankingArray.length;\n  rankingArray.sort(function (a, b) {\n    return a[1] - b[1];\n  });\n  let index = 1;\n  for (const rankingItem of rankingArray) {\n    // Classify into 4 groups and give a code\n    const rankingRatio = index / rankingArrayLength;\n    const rankingCode = (rankingRatio - (rankingRatio % 0.25)) / 0.25;\n    const thisStopID = rankingItem[0];\n    const thisStopKey = `s_${thisStopID}`;\n    result[thisStopKey] = {\n      number: index,\n      text: index.toString(),\n      code: rankingCode\n    };\n    index += 1;\n  }\n  return result;\n}\n\nexport interface LocationGroupProperty {\n  key: string;\n  icon: MaterialSymbols;\n  value: string;\n}\n\nexport interface LocationGroup {\n  name: string;\n  properties: Array<LocationGroupProperty>;\n}\n\nexport interface IntegratedLocationItemRanking {\n  number: number;\n  text: '--' | string;\n  code: -1 | 0 | 1 | 2 | 3 | 4; // -1: not applicable, 0: 0-25%, 1: 25-50%, 2: 50-75%, 3: 75-100%, 4: 100%\n}\n\nexport interface IntegratedLocationItem {\n  route_name: string;\n  route_direction: string;\n  routeId: number;\n  stopId: number;\n  status: EstimateTimeStatus;\n  ranking: IntegratedLocationItemRanking;\n  buses: Array<FormattedBus>;\n  busArrivalTimes: Array<BusArrivalTime>;\n}\n\nexport interface IntegratedLocation {\n  groupedItems: {\n    [g_index: string]: Array<IntegratedLocationItem>;\n  };\n  groups: {\n    [g_index: string]: LocationGroup;\n  };\n  groupQuantity: number;\n  itemQuantity: {\n    [g_index: string]: number;\n  };\n  LocationName: string;\n  dataUpdateTime: number;\n  hash: string;\n}\n\nexport async function integrateLocation(hash: string, chartWidth: number, chartHeight: number, requestID: string): Promise<IntegratedLocation> {\n  setDataReceivingProgress(requestID, 'getLocation_0', 0, false);\n  setDataReceivingProgress(requestID, 'getLocation_1', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_0', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_1', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_0', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_1', 0, false);\n  setDataReceivingProgress(requestID, 'getBusData_0', 0, false);\n  setDataReceivingProgress(requestID, 'getBusData_1', 0, false);\n\n  const [Route, Stop, Location] = (await Promise.all([await getRoute(requestID, true), await getStop(requestID), await getLocation(requestID, 1)])) as [SimplifiedRoute, SimplifiedStop, MergedLocation];\n  const [EstimateTime, BusEvent, BusData, BusArrivalTimes] = await Promise.all([getEstimateTime(requestID), getBusEvent(requestID), getBusData(requestID), getBusArrivalTimes(chartWidth, chartHeight)]);\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode');\n  const location_labels = getSettingOptionValue('location_labels');\n  const display_user_orientation = getSettingOptionValue('display_user_orientation');\n\n  const groupedItems = {} as IntegratedLocation['groupedItems'];\n  const itemQuantity = {} as IntegratedLocation['itemQuantity'];\n  const groups = {} as IntegratedLocation['groups'];\n\n  const userOrientation = getUserOrientation();\n\n  const thisLocationKey = `ml_${hash}`;\n  const thisLocation = Location[thisLocationKey];\n  const thisLocationName = thisLocation.n;\n  const stopLocationIds = thisLocation.id;\n  const setsOfVectors = thisLocation.v;\n\n  const StopIDs: Array<number> = [];\n  const RouteIDs: Array<number> = [];\n  const stopLocationQuantity = stopLocationIds.length;\n\n  for (let i = 0; i < stopLocationQuantity; i++) {\n    for (let j = 0, l = thisLocation.s[i].length; j < l; j++) {\n      StopIDs.push(thisLocation.s[i][j]);\n      RouteIDs.push(thisLocation.r[i][j]);\n    }\n  }\n\n  const batchFoundEstimateTime = batchFindEstimateTime(EstimateTime, StopIDs);\n  const batchFoundBuses = batchFindBusesForLocation(BusEvent, BusData, Route, StopIDs);\n\n  const cardinalDirections: Array<CardinalDirection> = [];\n  for (const vectorSet of setsOfVectors) {\n    let x: number = 0;\n    let y: number = 0;\n    for (const vector of vectorSet) {\n      x += vector[0];\n      y += vector[1];\n    }\n    const meanVector = normalizeVector([x, y]);\n    const cardinalDirection = getCardinalDirectionFromVector(meanVector);\n    cardinalDirections.push(cardinalDirection);\n  }\n\n  let labels: Array<string> = [];\n  switch (location_labels) {\n    case 'address':\n      labels = generateLabelFromAddresses(thisLocation.a);\n      break;\n    case 'letters':\n      labels = generateLetterLabels(stopLocationQuantity);\n      break;\n    case 'directions':\n      labels = generateDirectionLabels(cardinalDirections);\n      break;\n    default:\n      break;\n  }\n\n  for (let i = 0; i < stopLocationQuantity; i++) {\n    const groupKey = `g_${i}`;\n    groupedItems[groupKey] = [];\n    itemQuantity[groupKey] = 0;\n    groups[groupKey] = {\n      name: labels[i],\n      properties: [\n        {\n          key: 'address',\n          icon: 'personal_places',\n          value: addressToString(thisLocation.a[i])\n        },\n        {\n          key: 'exact_position',\n          icon: 'location_on',\n          value: `${thisLocation.la[i].toFixed(5)}, ${thisLocation.lo[i].toFixed(5)}`\n        },\n        {\n          key: 'cardinal_direction',\n          icon: cardinalDirections[i].icon,\n          value: `${cardinalDirections[i].name}${display_user_orientation && userOrientation.cardinalDirection.id !== -1 && userOrientation.cardinalDirection.id === cardinalDirections[i].id ? '（目前指向）' : ''}`\n        }\n      ]\n    };\n\n    const thisGroupStops = thisLocation.s[i];\n    const stopQuantity = thisGroupStops.length;\n    const thisGroupRanking = rankBatchFoundEstimateTime(batchFoundEstimateTime, thisGroupStops);\n\n    for (let o = 0; o < stopQuantity; o++) {\n      const integratedItem = {} as IntegratedLocationItem;\n      // Collect data from 'Stop'\n      const thisStopID = thisLocation.s[i][o];\n      const thisStopKey = `s_${thisStopID}`;\n      let thisStop: SimplifiedStopItem = {};\n      if (hasOwnProperty(Stop, thisStopKey)) {\n        thisStop = Stop[thisStopKey];\n      } else {\n        continue;\n      }\n      integratedItem.stopId = thisStopID;\n\n      // Collect data from 'thisGroupRanking'\n      let thisItemRanking = { number: 0, text: '--', code: -1 } as IntegratedLocationItemRanking;\n      if (hasOwnProperty(thisGroupRanking, thisStopKey)) {\n        thisItemRanking = thisGroupRanking[thisStopKey];\n      }\n      integratedItem.ranking = thisItemRanking;\n\n      // Collect data from 'Route'\n      const thisRouteID: number = thisLocation.r[i][o];\n      const thisRouteKey = `r_${thisRouteID}`;\n      let thisRoute: SimplifiedRouteItem = {};\n      if (hasOwnProperty(Route, thisRouteKey)) {\n        thisRoute = Route[thisRouteKey];\n      } else {\n        continue;\n      }\n      integratedItem.route_name = thisRoute.n;\n      integratedItem.route_direction = `往${[thisRoute.des, thisRoute.dep, ''][parseInt(thisStop.goBack)]}`;\n      integratedItem.routeId = thisRouteID;\n\n      // Collect data from 'batchFoundEstimateTime'\n      let thisEstimateTime = {} as EstimateTimeItem;\n      if (hasOwnProperty(batchFoundEstimateTime, thisStopKey)) {\n        thisEstimateTime = batchFoundEstimateTime[thisStopKey];\n      } else {\n        continue;\n      }\n      const parsedEstimateTime = parseEstimateTime(thisEstimateTime.EstimateTime, time_formatting_mode);\n      integratedItem.status = parsedEstimateTime;\n\n      // Collect data from 'batchFoundBuses'\n      let buses = [];\n      if (hasOwnProperty(batchFoundBuses, thisStopKey)) {\n        buses = batchFoundBuses[thisStopKey].map((e) => formatBus(e));\n      }\n      integratedItem.buses = buses;\n\n      // Collect data from 'BusArrivalTimes'\n      let thisBusArrivalTimes = [];\n      if (hasOwnProperty(BusArrivalTimes, thisStopKey)) {\n        thisBusArrivalTimes = BusArrivalTimes[thisStopKey];\n      }\n      integratedItem.busArrivalTimes = thisBusArrivalTimes;\n\n      groupedItems[groupKey].push(integratedItem);\n      itemQuantity[groupKey] += 1;\n    }\n  }\n\n  for (const key in groupedItems) {\n    groupedItems[key].sort(function (a, b) {\n      return a.routeId - b.routeId;\n    });\n    /*\n      .map((item: IntegratedLocationItem) => {\n        // accessing ranking[key] inside map callback will cause constant violations any way\n        return {\n          route_name: item.route_name,\n          route_direction: item.route_direction,\n          routeId: item.routeId,\n          stopId: item.stopId,\n          status: item.status,\n          rank: {\n            number: thisRankingIndex + 1,\n            code: 0\n          },\n          buses: item.buses,\n          busArrivalTimes: item.busArrivalTimes\n        };\n      })*/\n  }\n  const result: IntegratedLocation = {\n    groupedItems: groupedItems,\n    groups: groups,\n    groupQuantity: stopLocationQuantity,\n    itemQuantity: itemQuantity,\n    LocationName: thisLocationName,\n    hash: hash,\n    dataUpdateTime: getDataUpdateTime(requestID)\n  };\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  //await recordEstimateTimeForUpdateRate(EstimateTime);\n  return result;\n}\n"],"names":["parseEstimateTime","EstimateTime","mode","time","parseInt","code","text","formatTime","parseTimeCode","codeLength","length","hours","minutes","substring","type","min","max","number1","number2","Math","number","batchFindBusesForRoute","BusEvent","BusData","Route","RouteID","PathAttributeId","result","BusDataObj","BusDataItem","BusID","BusEventItem","processedItem","CarType","BusStatus","CarOnStop","thisRouteID","thisBusID","String","isOnThisRoute","index","indexOf","charCodeAt","pow","onThisRoute","thisBusData","hasOwnProperty","position","latitude","parseFloat","Latitude","longitude","Longitude","searchedRoute","isRouteSearched","key","thisRouteItem","pid","RouteName","n","id","StopKey","StopID","push","batchFindBusesForLocation","StopIDList","thisStopID","parseCarType","parseCarOnStop","onStop","parseBusStatus","situation","formatBus","batchFoundBus","carNumber","status","tasks","FetchError","Error","fetchData","_x","_x2","_x3","_x4","_fetchData","apply","arguments","_asyncToGenerator","url","requestID","tag","fileType","processing","Promise","resolve","reject","requests","Date","getTime","timestamp","setDataReceivingProgress","failed","response","fetch","ok","contentLength","headers","get","reader","body","getReader","chunks","receivedLength","_yield$reader$read","read","done","value","progress","request","uint8Array","Uint8Array","chunk","set","blob","Blob","arrayBuffer","inflatedData","pakoInflate","test","replace","JSON","parse","now","recordDataUsage","shift","discardExpiredFetchTasks","dataReceivingProgress","expel","broadcastDataReceivingProgress","total","getDataReceivingProgress","_typeof","received","clamp","Infinity","isNaN","deleteDataReceivingProgress","stage","eventDict","target","event","CustomEvent","detail","document","dispatchEvent","dataUpdateTime","setDataUpdateTime","timeZoneOffset","timeNumber","timeStampToNumber","getDataUpdateTime","deleteDataUpdateTime","integrateBus","_integrateBus","carKey","_ref","all","getCarInfo","getBusData","getBusEvent","_ref2","_slicedToArray","CarInfo","_ref3","getStop","getLocation","_ref4","Stop","Location","properties","LocationName","thisCar","thisCarNumber","CarNum","icon","thisCarType","thisBusDataItem","thisBusDataItemPathAttributeId","thisBusDataItemBusStatus","thisBusDataItemGoBack","GoBack","thisBusEventItem","thisBusEventItemCarOnStop","thisBusEventItemStopID","searchedRoutes","searchRouteByPathAttributeId","thisRouteFullPathAttributeId","thisRouteName","thisRouteDeparture","dep","thisRouteDirection","des","FullPathAttributeId","thisLocationItemName","stopLocationId","exportData","_exportData","foldersWithContent","listFoldersWithContent","settings","listSettingsWithOptions","personalSchedules","listPersonalSchedules","RecentViews","listRecentViews","toISOString","version","folders","personal_schedules","recent_views","stringify","FolderList","initializeFolderList","_initializeFolderList","folderKeys","lfListItemKeys","folderKey","thisFolderJSON","lfGetItem","thisFolderObject","createFolder","_createFolder","name","generateIdentifier","materialSymbolsSearchIndex","getMaterialSymbolsSearchIndex","symbols","folderID","newFolder","lfSetItem","updateFolder","_x5","_updateFolder","existingFolderJSON","existingFolderObject","modifiedFolder","getFolder","listFolders","folderObject","sort","a","b","listFolderContent","_x6","_listFolderContent","thisFolder","thisFolderContentIndexJSON","thisFolderContentIndexArray","thisFolderContentKey","thisContentJSON","thisContentObject","getFolderContentLength","_x7","_getFolderContentLength","_listFoldersWithContent","folder","folderContent","folderContentLength","content","listFoldersWithContentLength","_listFoldersWithContentLength","listAllFolderContent","_x8","_listAllFolderContent","types","useFilter","Array","isArray","keys","json","object","integrateFolders","_x9","_integrateFolders","getRoute","getEstimateTime","time_formatting_mode","getSettingOptionValue","power_saving","refresh_interval_setting","StopIDs","folderWithContent1","i","l","batchFoundEstimateTime","EstimateTimeItem","folderWithContent2","integratedFolder","item","integratedItem","thisStopKey","thisEstimateTime","thisRoute","route","pathAttributeId","dynamic","collectUpdateRateData","collectBusArrivalTimeData","saveToFolder","_x0","_x1","_saveToFolder","contentKey","isFolderContentSaved","_x10","_x11","_isFolderContentSaved","folderContentKeyToCheck","removeFromFolder","_x12","_x13","_x14","_removeFromFolder","splice","lfRemoveItem","saveStop","_x15","_x16","_x17","_saveStop","thisStop","thisStopDirection","goBack","thisStopName","thisRouteDestination","newContent","direction","endPoints","departure","destination","saveRoute","_x18","_x19","_saveRoute","thisRouteKey","saveLocation","_x20","_x21","_saveLocation","hash","thisLocationKey","thisLocation","updateFolderContentIndex","_x22","_x23","_x24","_x25","_updateFolderContentIndex","offset","importFolders","_importFolders","data","FolderWithContent","update","creation","importSettings","_importSettings","SettingWithOption","existingSetting","getSetting","changeSettingOption","option","importPersonalSchedules","_importPersonalSchedules","PersonalSchedule","getPersonalSchedule","updatePersonalSchedule","createPersonalSchedule","period","start","end","days","_importRecentViews","RecentView","getRecentView","logRecentView","importData","_importData","parsedData","importRecentViews","integrateLocationDetails","_integrateLocationDetails","actions","actionsQuantity","action","openSaveToFolder","shareLocationPermalink","showLocationPermalinkQRCode","rankBatchFoundEstimateTime","rankingArray","thisBatchFoundEstimateTimeItem","rankingArrayLength","rankingItem","rankingRatio","rankingCode","toString","integrateLocation","_integrateLocation","chartWidth","chartHeight","_yield$Promise$all","getBusArrivalTimes","_yield$Promise$all2","BusArrivalTimes","location_labels","display_user_orientation","groupedItems","itemQuantity","groups","userOrientation","getUserOrientation","thisLocationName","stopLocationIds","setsOfVectors","v","RouteIDs","stopLocationQuantity","j","s","r","batchFindEstimateTime","batchFoundBuses","cardinalDirections","vectorSet","x","y","vector","meanVector","normalizeVector","cardinalDirection","getCardinalDirectionFromVector","labels","generateLabelFromAddresses","generateLetterLabels","generateDirectionLabels","groupKey","addressToString","la","toFixed","lo","thisGroupStops","stopQuantity","thisGroupRanking","o","stopId","thisItemRanking","ranking","route_name","route_direction","routeId","parsedEstimateTime","buses","map","e","thisBusArrivalTimes","busArrivalTimes","groupQuantity"],"sourceRoot":""}