{"version":3,"file":"cacdb17ad653677213f5.js","mappings":"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","sources":["webpack://bus/./node_modules/qrcode/lib/core/version-check.js","webpack://bus/./node_modules/qrcode/lib/core/numeric-data.js","webpack://bus/./node_modules/qrcode/lib/core/segments.js","webpack://bus/./node_modules/qrcode/lib/core/version.js","webpack://bus/./node_modules/qrcode/lib/core/utils.js","webpack://bus/./node_modules/qrcode/lib/core/polynomial.js","webpack://bus/./node_modules/qrcode/lib/core/regex.js","webpack://bus/./node_modules/qrcode/lib/core/reed-solomon-encoder.js","webpack://bus/./node_modules/qrcode/lib/core/qrcode.js"],"sourcesContent":["/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nexports.isValid = function isValid (version) {\n  return !isNaN(version) && version >= 1 && version <= 40\n}\n","const Mode = require('./mode')\n\nfunction NumericData (data) {\n  this.mode = Mode.NUMERIC\n  this.data = data.toString()\n}\n\nNumericData.getBitsLength = function getBitsLength (length) {\n  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)\n}\n\nNumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nNumericData.prototype.getBitsLength = function getBitsLength () {\n  return NumericData.getBitsLength(this.data.length)\n}\n\nNumericData.prototype.write = function write (bitBuffer) {\n  let i, group, value\n\n  // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, 10)\n  }\n\n  // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n  const remainingNum = this.data.length - i\n  if (remainingNum > 0) {\n    group = this.data.substr(i)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, remainingNum * 3 + 1)\n  }\n}\n\nmodule.exports = NumericData\n","const Mode = require('./mode')\nconst NumericData = require('./numeric-data')\nconst AlphanumericData = require('./alphanumeric-data')\nconst ByteData = require('./byte-data')\nconst KanjiData = require('./kanji-data')\nconst Regex = require('./regex')\nconst Utils = require('./utils')\nconst dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n","const Utils = require('./utils')\nconst ECCode = require('./error-correction-code')\nconst ECLevel = require('./error-correction-level')\nconst Mode = require('./mode')\nconst VersionCheck = require('./version-check')\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n","let toSJISFunction\nconst CODEWORDS_COUNT = [\n  0, // Not used\n  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n]\n\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nexports.getSymbolSize = function getSymbolSize (version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined')\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40')\n  return version * 4 + 17\n}\n\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nexports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {\n  return CODEWORDS_COUNT[version]\n}\n\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nexports.getBCHDigit = function (data) {\n  let digit = 0\n\n  while (data !== 0) {\n    digit++\n    data >>>= 1\n  }\n\n  return digit\n}\n\nexports.setToSJISFunction = function setToSJISFunction (f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.')\n  }\n\n  toSJISFunction = f\n}\n\nexports.isKanjiModeEnabled = function () {\n  return typeof toSJISFunction !== 'undefined'\n}\n\nexports.toSJIS = function toSJIS (kanji) {\n  return toSJISFunction(kanji)\n}\n","const GF = require('./galois-field')\n\n/**\n * Multiplies two polynomials inside Galois Field\n *\n * @param  {Uint8Array} p1 Polynomial\n * @param  {Uint8Array} p2 Polynomial\n * @return {Uint8Array}    Product of p1 and p2\n */\nexports.mul = function mul (p1, p2) {\n  const coeff = new Uint8Array(p1.length + p2.length - 1)\n\n  for (let i = 0; i < p1.length; i++) {\n    for (let j = 0; j < p2.length; j++) {\n      coeff[i + j] ^= GF.mul(p1[i], p2[j])\n    }\n  }\n\n  return coeff\n}\n\n/**\n * Calculate the remainder of polynomials division\n *\n * @param  {Uint8Array} divident Polynomial\n * @param  {Uint8Array} divisor  Polynomial\n * @return {Uint8Array}          Remainder\n */\nexports.mod = function mod (divident, divisor) {\n  let result = new Uint8Array(divident)\n\n  while ((result.length - divisor.length) >= 0) {\n    const coeff = result[0]\n\n    for (let i = 0; i < divisor.length; i++) {\n      result[i] ^= GF.mul(divisor[i], coeff)\n    }\n\n    // remove all zeros from buffer head\n    let offset = 0\n    while (offset < result.length && result[offset] === 0) offset++\n    result = result.slice(offset)\n  }\n\n  return result\n}\n\n/**\n * Generate an irreducible generator polynomial of specified degree\n * (used by Reed-Solomon encoder)\n *\n * @param  {Number} degree Degree of the generator polynomial\n * @return {Uint8Array}    Buffer containing polynomial coefficients\n */\nexports.generateECPolynomial = function generateECPolynomial (degree) {\n  let poly = new Uint8Array([1])\n  for (let i = 0; i < degree; i++) {\n    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))\n  }\n\n  return poly\n}\n","const numeric = '[0-9]+'\nconst alphanumeric = '[A-Z $%*+\\\\-./:]+'\nlet kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'\nkanji = kanji.replace(/u/g, '\\\\u')\n\nconst byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+'\n\nexports.KANJI = new RegExp(kanji, 'g')\nexports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g')\nexports.BYTE = new RegExp(byte, 'g')\nexports.NUMERIC = new RegExp(numeric, 'g')\nexports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')\n\nconst TEST_KANJI = new RegExp('^' + kanji + '$')\nconst TEST_NUMERIC = new RegExp('^' + numeric + '$')\nconst TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$')\n\nexports.testKanji = function testKanji (str) {\n  return TEST_KANJI.test(str)\n}\n\nexports.testNumeric = function testNumeric (str) {\n  return TEST_NUMERIC.test(str)\n}\n\nexports.testAlphanumeric = function testAlphanumeric (str) {\n  return TEST_ALPHANUMERIC.test(str)\n}\n","const Polynomial = require('./polynomial')\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Uint8Array} data Buffer containing input data\n * @return {Uint8Array}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  const paddedData = new Uint8Array(data.length + this.degree)\n  paddedData.set(data)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  const remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  const start = this.degree - remainder.length\n  if (start > 0) {\n    const buff = new Uint8Array(this.degree)\n    buff.set(remainder, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n","const Utils = require('./utils')\nconst ECLevel = require('./error-correction-level')\nconst BitBuffer = require('./bit-buffer')\nconst BitMatrix = require('./bit-matrix')\nconst AlignmentPattern = require('./alignment-pattern')\nconst FinderPattern = require('./finder-pattern')\nconst MaskPattern = require('./mask-pattern')\nconst ECCode = require('./error-correction-code')\nconst ReedSolomonEncoder = require('./reed-solomon-encoder')\nconst Version = require('./version')\nconst FormatInfo = require('./format-info')\nconst Mode = require('./mode')\nconst Segments = require('./segments')\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n"],"names":["exports","isValid","version","isNaN","Mode","NumericData","data","this","mode","NUMERIC","toString","getBitsLength","length","Math","floor","prototype","getLength","write","bitBuffer","i","group","value","substr","parseInt","put","remainingNum","module","AlphanumericData","ByteData","KanjiData","Regex","Utils","dijkstra","getStringByteLength","str","unescape","encodeURIComponent","getSegments","regex","segments","result","exec","push","index","getSegmentsFromString","dataStr","numSegs","alphaNumSegs","ALPHANUMERIC","byteSegs","kanjiSegs","isKanjiModeEnabled","BYTE","KANJI","BYTE_KANJI","concat","sort","s1","s2","map","obj","getSegmentBitsLength","buildSingleSegment","modesHint","bestMode","getBestModeForData","from","bit","Error","seg","acc","segs","nodes","table","graph","start","prevNodeIds","nodeGroup","currentNodeIds","j","node","key","lastCount","n","prevNodeId","getCharCountIndicator","end","reduce","curr","prevSeg","matrix","set","FinderPattern","row","r","col","c","size"],"ignoreList":[],"sourceRoot":""}