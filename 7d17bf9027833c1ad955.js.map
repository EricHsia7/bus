{"version":3,"file":"7d17bf9027833c1ad955.js","mappings":"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","sources":["webpack://bus/./src/data/route/index.ts","webpack://bus/./src/data/search/index.ts"],"sourcesContent":["import { convertPositionsToDistance } from '../../tools/convert';\nimport { BusArrivalTime, getBusArrivalTimes } from '../analytics/bus-arrival-time/index';\nimport { getBusData } from '../apis/getBusData/index';\nimport { getBusEvent } from '../apis/getBusEvent/index';\nimport { getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, IndexedLocation, IndexedLocationItem, MergedLocation, SimplifiedLocation, SimplifiedLocationItem } from '../apis/getLocation/index';\nimport { getRoute, SimplifiedRoute, SimplifiedRouteItem } from '../apis/getRoute/index';\nimport { getSegmentBuffers, SimplifiedSegmentBufferItem } from '../apis/getSegmentBuffers/index';\nimport { getStop, SimplifiedStopItem } from '../apis/getStop/index';\nimport { batchFindBusesForRoute, EstimateTimeStatus, formatBus, FormattedBus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue } from '../settings/index';\nimport { getNearestPosition } from '../user-position/index';\n\ninterface formattedOverlappingRoute {\n  name: string;\n  RouteEndPoints: {\n    RouteDeparture: string;\n    RouteDestination: string;\n    text: string;\n    html: string;\n  };\n  RouteID: number;\n  PathAttributeId: Array<number>;\n}\n\nexport interface integratedStopItemPosition {\n  longitude: number;\n  latitude: number;\n}\n\nexport interface integratedStopItemSegmentBuffer {\n  isSegmentBuffer: boolean;\n  isStartingPoint: boolean;\n  isEndingPoint: boolean;\n}\n\nexport interface integratedStopItemNearbyLocationItem {\n  name: string;\n  distance: number;\n  hash: string;\n}\n\nexport interface integratedStopItem {\n  name: string;\n  goBack: '0' | '1' | '2';\n  status: EstimateTimeStatus;\n  buses: Array<FormattedBus>;\n  overlappingRoutes: Array<formattedOverlappingRoute>;\n  busArrivalTimes: Array<BusArrivalTime>;\n  nearbyLocations: Array<integratedStopItemNearbyLocationItem>;\n  sequence: number;\n  position: integratedStopItemPosition;\n  nearest: boolean;\n  segmentBuffer: integratedStopItemSegmentBuffer;\n  progress: number;\n  id: number;\n}\n\nexport interface IntegratedRoute {\n  groupedItems: { [key: string]: Array<integratedStopItem> };\n  groupQuantity: number;\n  itemQuantity: { [key: string]: number };\n  RouteName: string;\n  RouteEndPoints: {\n    RouteDeparture: string;\n    RouteDestination: string;\n  };\n  dataUpdateTime: number;\n  RouteID: number;\n  PathAttributeId: Array<number>;\n}\n\nexport async function integrateRoute(RouteID: number, PathAttributeId: Array<number>, chartWidth: number, chartHeight: number, requestID: string): Promise<IntegratedRoute> {\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_0', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_1', 0, false);\n  setDataReceivingProgress(requestID, 'getLocation_0', 0, false);\n  setDataReceivingProgress(requestID, 'getLocation_1', 0, false);\n  setDataReceivingProgress(requestID, 'getSegmentBuffers_0', 0, false);\n  setDataReceivingProgress(requestID, 'getSegmentBuffers_1', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_0', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_1', 0, false);\n  setDataReceivingProgress(requestID, 'getBusData_0', 0, false);\n  setDataReceivingProgress(requestID, 'getBusData_1', 0, false);\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  const Stop = await getStop(requestID);\n  const SimplifiedLocation = (await getLocation(requestID, 0)) as SimplifiedLocation;\n  const MergedLocation = (await getLocation(requestID, 1)) as MergedLocation;\n  const IndexedLocation = (await getLocation(requestID, 2)) as IndexedLocation;\n  const SegmentBuffers = await getSegmentBuffers(requestID);\n  const EstimateTime = await getEstimateTime(requestID);\n  const BusEvent = await getBusEvent(requestID);\n  const BusData = await getBusData(requestID);\n  const BusArrivalTimes = await getBusArrivalTimes(chartWidth, chartHeight);\n\n  const batchFoundBuses = batchFindBusesForRoute(BusEvent, BusData, Route, RouteID, PathAttributeId);\n\n  let hasSegmentBuffers: boolean = false;\n  let thisSegmentBuffers: SimplifiedSegmentBufferItem = {};\n  if (SegmentBuffers.hasOwnProperty(`r_${RouteID}`)) {\n    hasSegmentBuffers = true;\n    thisSegmentBuffers = SegmentBuffers[`r_${RouteID}`];\n  }\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode') as number;\n\n  let result = [];\n  let positions = [];\n\n  for (const item of EstimateTime) {\n    let integratedStopItem = {} as integratedStopItem;\n\n    const thisRouteID = item.RouteID;\n\n    // Check whether this stop is on this route or not\n    if ([RouteID, RouteID * 10].includes(thisRouteID) || PathAttributeId.includes(thisRouteID)) {\n      // Parse estimate time\n      integratedStopItem.status = parseEstimateTime(item?.EstimateTime, time_formatting_mode);\n\n      // Collect data from 'Stop'\n      const thisStopKey = `s_${item.StopID}`;\n      let thisStop = {} as SimplifiedStopItem;\n      if (Stop.hasOwnProperty(thisStopKey)) {\n        thisStop = Stop[thisStopKey];\n      } else {\n        continue;\n      }\n      integratedStopItem.id = item.StopID;\n      integratedStopItem.sequence = thisStop.seqNo;\n      integratedStopItem.goBack = thisStop.goBack;\n\n      // Collect data from 'SimplifiedLocation'\n      const thisLocationKey = `l_${thisStop.stopLocationId}`;\n      let thisSimplifiedLocation = {} as SimplifiedLocationItem;\n      if (SimplifiedLocation.hasOwnProperty(thisLocationKey)) {\n        thisSimplifiedLocation = SimplifiedLocation[thisLocationKey];\n      } else {\n        continue;\n      }\n      integratedStopItem.name = thisSimplifiedLocation.n;\n      integratedStopItem.overlappingRoutes = thisSimplifiedLocation.r\n        .filter((id: number) => id !== RouteID)\n        .map((id: number) => {\n          const overlappingRouteKey = `r_${id}`;\n          if (Route.hasOwnProperty(overlappingRouteKey)) {\n            const overlappingRoute = Route[overlappingRouteKey] as SimplifiedRouteItem;\n            const formattedOverlappingRoute = {\n              name: overlappingRoute.n,\n              RouteEndPoints: {\n                RouteDeparture: overlappingRoute.dep,\n                RouteDestination: overlappingRoute.des,\n                text: `${overlappingRoute.dep} \\u2194 ${overlappingRoute.des}`, // u2194 -> 'â†”'\n                html: `<span>${overlappingRoute.dep}</span><span>\\u2194</span><span>${overlappingRoute.des}</span>`\n              },\n              RouteID: overlappingRoute.id,\n              PathAttributeId: overlappingRoute.pid\n            };\n            return formattedOverlappingRoute;\n          } else {\n            return null;\n          }\n        })\n        .filter((e) => {\n          return e !== null;\n        });\n      integratedStopItem.position = {\n        longitude: thisSimplifiedLocation.lo,\n        latitude: thisSimplifiedLocation.la\n      };\n      positions.push({\n        latitude: thisSimplifiedLocation.la,\n        longitude: thisSimplifiedLocation.lo,\n        id: item.StopID\n      });\n\n      // Collect data from 'IndexedLocation' and 'MergedLocation'\n      const thisSimplifiedLocationGeohash = thisSimplifiedLocation.g;\n      let thisIndexedLocationItem: Array<IndexedLocationItem> = [];\n      if (IndexedLocation.hasOwnProperty(thisSimplifiedLocationGeohash)) {\n        thisIndexedLocationItem = IndexedLocation[thisSimplifiedLocationGeohash];\n      }\n      let nearbyLocations: Array<integratedStopItemNearbyLocationItem> = [];\n      for (const item of thisIndexedLocationItem) {\n        const mergedLocationKey = `ml_${item.hash}`;\n        if (MergedLocation.hasOwnProperty(mergedLocationKey)) {\n          const thisMergedLocation = MergedLocation[mergedLocationKey];\n          const nearbyLocationItem: integratedStopItemNearbyLocationItem = {\n            name: thisMergedLocation.n,\n            distance: convertPositionsToDistance(thisMergedLocation.la[0], thisMergedLocation.lo[0], thisSimplifiedLocation.la, thisSimplifiedLocation.lo) | 0,\n            hash: thisMergedLocation.hash\n          };\n          nearbyLocations.push(nearbyLocationItem);\n        }\n      }\n      nearbyLocations.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n      integratedStopItem.nearbyLocations = nearbyLocations;\n\n      // Collect data from 'batchFoundBuses'\n      let buses = []; // as Array<FormattedBus>\n      for (const overlappingStopID of thisSimplifiedLocation.s) {\n        const overlappingStopKey = `s_${overlappingStopID}`;\n        if (batchFoundBuses.hasOwnProperty(overlappingStopKey)) {\n          buses.push(batchFoundBuses[overlappingStopKey].map((e) => formatBus(e)));\n        }\n      }\n      integratedStopItem.buses = buses.flat().sort(function (a, b) {\n        return a.index - b.index;\n      });\n\n      // Collect data from 'BusArrivalTimes'\n      let thisBusArrivalTimes = [];\n      if (BusArrivalTimes.hasOwnProperty(thisStopKey)) {\n        thisBusArrivalTimes = BusArrivalTimes[thisStopKey];\n      }\n      integratedStopItem.busArrivalTimes = thisBusArrivalTimes;\n\n      // Check whether this stop is segment buffer\n      let isSegmentBuffer: boolean = false;\n      let isStartingPoint: boolean = false;\n      let isEndingPoint: boolean = false;\n      let useReversed: boolean = false;\n      if (hasSegmentBuffers) {\n        const groupKey = `g_${integratedStopItem.goBack}`;\n        let segmentBufferGroup = [];\n\n        if (thisSegmentBuffers.hasOwnProperty(groupKey)) {\n          segmentBufferGroup = thisSegmentBuffers[groupKey];\n        } else {\n          if (integratedStopItem.goBack === '1') {\n            useReversed = true;\n            segmentBufferGroup = thisSegmentBuffers['g_0'];\n          }\n        }\n\n        for (const thisBufferZone of segmentBufferGroup) {\n          if (thisBufferZone.OriginStopID === item.StopID || thisBufferZone.DestinationStopID === item.StopID) {\n            isSegmentBuffer = true;\n          }\n          if (useReversed) {\n            if (thisBufferZone.OriginStopID === item.StopID) {\n              isEndingPoint = true;\n            }\n            if (thisBufferZone.DestinationStopID === item.StopID) {\n              isStartingPoint = true;\n            }\n          } else {\n            if (thisBufferZone.OriginStopID === item.StopID) {\n              isStartingPoint = true;\n            }\n            if (thisBufferZone.DestinationStopID === item.StopID) {\n              isEndingPoint = true;\n            }\n          }\n        }\n      }\n      integratedStopItem.segmentBuffer = {\n        isSegmentBuffer,\n        isStartingPoint,\n        isEndingPoint\n      };\n\n      result.push(integratedStopItem);\n    }\n  }\n\n  result.sort(function (a, b) {\n    return a.sequence - b.sequence;\n  });\n\n  const nearestPosition = getNearestPosition(positions, 450);\n\n  let isBufferZoneOpened: boolean = false;\n  let isBufferZoneClosed: boolean = false;\n\n  let groupedItems: { [key: string]: Array<integratedStopItem> } = {};\n  let groupQuantity: number = 0;\n  let itemQuantity: { [key: string]: number } = {};\n\n  const resultLength = result.length;\n\n  for (let index = 0; index < resultLength; index++) {\n    let item = result[index];\n    const nextItem = result[index + 1] || item;\n    let progress = 0;\n\n    if (item.buses.length > 0) {\n      if (item.buses[0].onThisRoute) {\n        const [x, y] = [item.buses[0].position.longitude, item.buses[0].position.latitude];\n        const [x1, y1] = [item.position.longitude, item.position.latitude];\n        const [x2, y2] = [nextItem.position.longitude, nextItem.position.latitude];\n        const dotProduct = (x - x1) * (x2 - x) + (y - y1) * (y2 - y);\n        if (dotProduct >= 0) {\n          // ensure that (x, y) is between (x1, y1) and (x2, y2)\n          const distance1 = Math.hypot(x - x1, y - y1);\n          const distance2 = Math.hypot(x - x2, y - y2);\n          progress = Math.max(0, Math.min(distance1 / (distance1 + distance2), 1));\n        }\n      }\n    }\n    item.progress = progress;\n\n    if (item.segmentBuffer.isStartingPoint) {\n      isBufferZoneOpened = true;\n    }\n\n    if (item.segmentBuffer.isEndingPoint) {\n      if (isBufferZoneOpened) {\n        isBufferZoneClosed = true;\n      }\n    }\n\n    if (isBufferZoneOpened && !isBufferZoneClosed) {\n      item.segmentBuffer.isSegmentBuffer = true;\n    }\n\n    if (isBufferZoneOpened && isBufferZoneClosed) {\n      isBufferZoneOpened = false;\n      isBufferZoneClosed = false;\n    }\n\n    let isNearest = false;\n    if (nearestPosition !== null) {\n      if (nearestPosition.id === item.id) {\n        isNearest = true;\n      }\n    }\n    item.nearest = isNearest;\n\n    const groupKey = `g_${item.goBack}` || 'g_0';\n\n    if (!groupedItems.hasOwnProperty(groupKey)) {\n      groupedItems[groupKey] = [];\n      itemQuantity[groupKey] = 0;\n      groupQuantity += 1;\n    }\n\n    groupedItems[groupKey].push(item);\n    itemQuantity[groupKey] += 1;\n  }\n\n  const thisRoute = Route[`r_${RouteID}`];\n  const thisRouteName = thisRoute.n;\n  const thisRouteDeparture = thisRoute.dep;\n  const thisRouteDestination = thisRoute.des;\n\n  const result2: IntegratedRoute = {\n    groupedItems: groupedItems,\n    groupQuantity: groupQuantity,\n    itemQuantity: itemQuantity,\n    RouteName: thisRouteName,\n    RouteEndPoints: {\n      RouteDeparture: thisRouteDeparture,\n      RouteDestination: thisRouteDestination\n    },\n    dataUpdateTime: getDataUpdateTime(requestID),\n    RouteID,\n    PathAttributeId\n  };\n\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  // await recordEstimateTimeForUpdateRate(EstimateTime);\n  return result2;\n}\n","import { getIntersection } from '../../tools/array';\nimport { generateIdentifier } from '../../tools/index';\nimport { getUnicodes } from '../../tools/text';\nimport { getCarInfo, SimplifiedCarInfo } from '../apis/getCarInfo/index';\nimport { getLocation, MergedLocation } from '../apis/getLocation/index';\nimport { getRoute, SimplifiedRoute, SimplifiedRouteItem } from '../apis/getRoute/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime } from '../apis/loader';\n\nexport async function searchRouteByName(query: string): Promise<Array<SimplifiedRouteItem>> {\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  let result: Array<SimplifiedRouteItem> = [];\n  for (const key in Route) {\n    const thisRoute = Route[key];\n    if (String(thisRoute.n).indexOf(query) > -1) {\n      result.push(thisRoute);\n    }\n  }\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  return result;\n}\n\nexport async function searchRouteByRouteID(RouteID: number): Promise<SimplifiedRouteItem | false> {\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  let result = {} as SimplifiedRouteItem;\n  const routeKey = `r_${RouteID}`;\n  if (!Route.hasOwnProperty(routeKey)) {\n    return false;\n  }\n  result = Route[routeKey];\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  return result;\n}\n\nexport async function searchRouteByPathAttributeId(PathAttributeId: number): Promise<Array<SimplifiedRouteItem>> {\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  let result: Array<SimplifiedRouteItem> = [];\n  for (const key in Route) {\n    const thisRoute = Route[key];\n    if (String(thisRoute.pid).indexOf(PathAttributeId) > -1) {\n      result.push(thisRoute);\n    }\n  }\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  return result;\n}\n\nexport interface SearchItem {\n  id: string | number | Array<number>;\n  pid: Array<number>;\n  dep: string;\n  des: string;\n  n: string;\n  hash: string;\n  lo: Array<number>;\n  la: Array<number>;\n  r: Array<Array<number>>;\n  s: Array<Array<number>>;\n  type: 0 | 1 | 2; // 0: route, 1: location, 2: car info\n}\n\nexport interface SearchResult {\n  item: SearchItem;\n  score: number;\n}\n\nexport type SearchIndex = { [unicodeKey: string]: Array<number> };\n\nlet searchIndex: SearchIndex = {};\nlet searchList: Array<SearchItem> = [];\nlet readyToSearch: boolean = false;\n\nexport async function prepareForSearch() {\n  if (readyToSearch) {\n    return;\n  }\n\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  const mergedLocation = (await getLocation(requestID, 1)) as MergedLocation;\n  const CarInfo = (await getCarInfo(requestID, true)) as SimplifiedCarInfo;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n\n  let index: SearchIndex = {};\n  let list: Array<SearchItem> = [];\n  let i: number = 0;\n  for (const key in Route) {\n    const thisRoute = Route[key];\n    const thisItem = {\n      id: thisRoute.id,\n      pid: thisRoute.pid,\n      dep: thisRoute.dep,\n      des: thisRoute.des,\n      n: thisRoute.n,\n      hash: '',\n      lo: '',\n      la: '',\n      r: '',\n      s: '',\n      type: 0\n    };\n    list.push(thisItem);\n    const unicodes = getUnicodes(`${thisItem.n.toLowerCase()}${thisItem.dep.toLowerCase()}${thisItem.des.toLowerCase()}`, true);\n    for (const unicode of unicodes) {\n      const key = `u_${unicode}`;\n      if (!index.hasOwnProperty(key)) {\n        index[key] = [];\n      }\n      index[key].push(i);\n    }\n    i += 1;\n  }\n  for (const key in mergedLocation) {\n    const thisLocation = mergedLocation[key];\n    const thisItem = {\n      id: thisLocation.id,\n      n: thisLocation.n,\n      lo: thisLocation.lo,\n      la: thisLocation.la,\n      r: thisLocation.r,\n      s: thisLocation.s,\n      hash: thisLocation.hash,\n      dep: '',\n      des: '',\n      pid: [],\n      type: 1\n    };\n    list.push(thisItem);\n    const unicodes = getUnicodes(thisItem.n.toLowerCase(), true);\n    for (const unicode of unicodes) {\n      const key = `u_${unicode}`;\n      if (!index.hasOwnProperty(key)) {\n        index[key] = [];\n      }\n      index[key].push(i);\n    }\n    i += 1;\n  }\n  for (const key in CarInfo) {\n    const thisCarInfo = CarInfo[key];\n    const thisItem = {\n      id: thisCarInfo.BusId,\n      pid: [],\n      dep: '',\n      des: '',\n      n: thisCarInfo.CarNum,\n      hash: '',\n      lo: '',\n      la: '',\n      r: '',\n      s: '',\n      type: 2\n    };\n    list.push(thisItem);\n    const unicodes = getUnicodes(thisItem.n.toLowerCase(), true);\n    for (const unicode of unicodes) {\n      const key = `u_${unicode}`;\n      if (!index.hasOwnProperty(key)) {\n        index[key] = [];\n      }\n      index[key].push(i);\n    }\n    i += 1;\n  }\n  searchIndex = index;\n  searchList = list;\n  readyToSearch = true;\n}\n\nfunction calculateSearchResultScore(queryUnicodes: Array<number>, resultUnicodes: Array<number>): number {\n  // 1. Index data by characters for entries well-differentiated in characters\n  // 2. The results are ranked by positional difference for relevance\n  // 3. Some entries are prioritized for exact matches\n  let score = 0;\n  let i = 0;\n  for (const unicode of resultUnicodes) {\n    const indexOfUnicode = queryUnicodes.indexOf(unicode, i);\n    score += indexOfUnicode - i;\n    i += 1;\n  }\n  if (queryUnicodes === resultUnicodes) {\n    score = Math.abs(score) * 10;\n  }\n  return score;\n}\n\nexport function searchFor(query: string, type: SearchItem['type'] | -1, limit: number): Array<SearchResult> {\n  if (!readyToSearch) {\n    return [];\n  }\n\n  const lowerCaseQuery = query.toLowerCase();\n  const queryUnicodes = getUnicodes(lowerCaseQuery, true);\n  const asIsQueryUnicodes = getUnicodes(lowerCaseQuery, false);\n  let unicodeGroups = [];\n\n  for (const unicode of queryUnicodes) {\n    const key = `u_${unicode}`;\n    if (searchIndex.hasOwnProperty(key)) {\n      unicodeGroups.push(searchIndex[key]);\n    }\n  }\n\n  unicodeGroups.sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  const unicodeGroupsLength1 = unicodeGroups.length - 1;\n  let intersection = [];\n\n  if (unicodeGroupsLength1 === 0) {\n    intersection = unicodeGroups[0];\n  }\n\n  if (unicodeGroupsLength1 > 0) {\n    for (let i = 0; i < unicodeGroupsLength1; i++) {\n      const currentGroup = unicodeGroups[i];\n      const nextGroup = unicodeGroups[i + 1];\n      if (i === 0) {\n        intersection = getIntersection(currentGroup, nextGroup);\n      } else {\n        intersection = getIntersection(intersection, nextGroup);\n      }\n    }\n  }\n\n  let result: Array<SearchResult> = [];\n  let quantity: number = 0;\n\n  const exactMatchIds = new Set(); // Track exact matches to avoid duplicates\n  if (type === -1 || type === 2) {\n    // Prioritize exact matches for buses\n    const exactMatches = searchList.filter((item) => item.n === lowerCaseQuery && item.type === 2);\n    for (const item of exactMatches) {\n      result.push({\n        item: item,\n        score: Infinity // Highest possible score for exact matches\n      });\n      exactMatchIds.add(item.id);\n      quantity += 1;\n      if (quantity >= limit) {\n        break;\n      }\n    }\n  }\n\n  if (quantity < limit) {\n    for (const j of intersection) {\n      let thisItem = searchList[j];\n\n      // Check if the item is of the type\n      if (type !== -1 && type !== thisItem.type) {\n        continue;\n      }\n\n      // Check if the item is not already an exact match\n      if (exactMatchIds.has(thisItem.id)) {\n        continue;\n      }\n\n      const score = calculateSearchResultScore(asIsQueryUnicodes, getUnicodes(thisItem.n, false));\n      if (quantity < limit) {\n        result.push({\n          item: thisItem,\n          score: score\n        });\n      } else {\n        break;\n      }\n      quantity += 1;\n    }\n  }\n\n  result.sort(function (a, b) {\n    return b.score - a.score;\n  });\n\n  return result;\n}\n"],"names":["integrateRoute","_x","_x2","_x3","_x4","_x5","_integrateRoute","apply","arguments","RouteID","PathAttributeId","chartWidth","chartHeight","requestID","setDataReceivingProgress","Route","getRoute","Stop","getStop","SimplifiedLocation","getLocation","MergedLocation","IndexedLocation","SegmentBuffers","getSegmentBuffers","EstimateTime","getEstimateTime","BusEvent","getBusEvent","BusData","getBusData","BusArrivalTimes","getBusArrivalTimes","batchFoundBuses","batchFindBusesForRoute","hasSegmentBuffers","thisSegmentBuffers","hasOwnProperty","_step","time_formatting_mode","getSettingOptionValue","result","positions","_iterator","_createForOfIteratorHelper","s","n","done","item","value","integratedStopItem","thisRouteID","includes","status","parseEstimateTime","thisStopKey","StopID","thisStop","id","sequence","seqNo","goBack","thisLocationKey","stopLocationId","thisSimplifiedLocation","name","overlappingRoutes","r","filter","map","overlappingRouteKey","overlappingRoute","RouteEndPoints","RouteDeparture","dep","RouteDestination","des","text","html","pid","e","position","longitude","lo","latitude","la","push","thisSimplifiedLocationGeohash","g","thisIndexedLocationItem","_step2","nearbyLocations","_iterator2","mergedLocationKey","hash","thisMergedLocation","nearbyLocationItem","distance","convertPositionsToDistance","err","f","sort","a","b","_step3","buses","_iterator3","overlappingStopKey","formatBus","flat","index","thisBusArrivalTimes","busArrivalTimes","isSegmentBuffer","isStartingPoint","isEndingPoint","useReversed","groupKey","segmentBufferGroup","_step4","_iterator4","thisBufferZone","OriginStopID","DestinationStopID","segmentBuffer","nearestPosition","getNearestPosition","isBufferZoneOpened","isBufferZoneClosed","groupedItems","groupQuantity","itemQuantity","resultLength","length","nextItem","progress","onThisRoute","_ref","x","y","_ref2","x1","y1","_ref3","x2","y2","distance1","Math","hypot","distance2","max","min","isNearest","nearest","thisRoute","result2","RouteName","dataUpdateTime","getDataUpdateTime","deleteDataReceivingProgress","deleteDataUpdateTime","searchRouteByName","_searchRouteByName","_asyncToGenerator","query","generateIdentifier","key","String","indexOf","searchRouteByRouteID","_searchRouteByRouteID","routeKey","searchRouteByPathAttributeId","_searchRouteByPathAttributeId","searchIndex","searchList","readyToSearch","prepareForSearch","_prepareForSearch","mergedLocation","CarInfo","getCarInfo","list","i","thisItem","type","_step5","_iterator5","getUnicodes","toLowerCase","thisLocation","_step6","_iterator6","thisCarInfo","BusId","CarNum","_step7","_iterator7","calculateSearchResultScore","queryUnicodes","resultUnicodes","score","unicode","abs","searchFor","limit","lowerCaseQuery","asIsQueryUnicodes","unicodeGroups","unicodeGroupsLength1","intersection","currentGroup","nextGroup","getIntersection","quantity","exactMatchIds","Set","exactMatches","Infinity","add","j","has"],"ignoreList":[],"sourceRoot":""}