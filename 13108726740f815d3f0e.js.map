{"version":3,"file":"13108726740f815d3f0e.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,MAAO,GAAIH,GACQ,iBAAZC,QACdA,QAAa,IAAID,IAEjBD,EAAU,IAAIC,GACf,CATD,CASGK,MAAM,I,ihCCqEF,SAASC,EAAoBC,GAClC,IAAIC,EAASC,KAAKC,MAAMH,GACpBI,EAAY,GAChB,GAAIH,EAAS,EAAG,CACd,IACsBI,EADlBC,EAAQ,EAAIL,EAAOM,EAAAC,EACPR,GAAM,IAAtB,IAAAO,EAAAE,MAAAJ,EAAAE,EAAAG,KAAAC,MAAwB,KAAbC,EAACP,EAAAQ,MACVT,EAAUU,KAAKF,EAAIN,EACrB,CAAC,OAAAS,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACD,OAAOb,CACT,CACE,OAAOJ,CAEX,C,4/BCvFAF,KAAKoB,UAAY,SAAUF,GACzB,IAAMG,EAIR,SAAiCC,GAC/B,IAC2Bf,EADvBgB,EAAmB,CAAC,EAAEd,EAAAC,EACPY,GAAQ,IAA3B,IAAAb,EAAAE,MAAAJ,EAAAE,EAAAG,KAAAC,MAA6B,KAAlBW,EAAIjB,EAAAQ,MACPU,EAAcD,EAAKE,QACnBC,EAAe,KAAHC,OAAQH,GACrBF,EAAiBM,eAAeF,KACnCJ,EAAiBI,GAAgB,IAEnCJ,EAAiBI,GAAcX,KAAKQ,EACtC,CAAC,OAAAP,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACD,IAAK,IAAMW,KAAOP,EAChBA,EAAiBO,GAAOP,EAAiBO,GAAKC,MAAK,SAAUC,EAAGC,GAC9D,OAAOD,EAAEE,MAAQD,EAAEC,KACrB,IAEF,IAC2BC,EADvBd,EAA6B,CAAC,EAAEe,EAAA1B,EACjBY,GAAQ,IAA3B,IAAAc,EAAAzB,MAAAwB,EAAAC,EAAAxB,KAAAC,MAA6B,CAK3B,IAL2B,IAAlBW,EAAIW,EAAApB,MACTb,EAAS,CAAC,EAAG,GACXmC,EAAuBd,EAAiB,KAADK,OAAMJ,EAAKE,UAClDY,EAA6BD,EAAqBlC,OACpDoC,EAAe,KACVC,EAAI,EAAGA,EAAIF,EAA4BE,IAC9C,GAAIH,EAAqBG,GAAGC,KAAOjB,EAAKiB,GAAI,CAC1C,IAAIC,EAAY,EACZF,EAAIF,EAA6B,IACnCI,EAAYF,EAAI,GAElBD,EAAeF,EAAqBK,EACtC,CAEF,GAAIH,EAGFrC,EAASD,EAAoB,CAFnB0C,WAAWJ,EAAaK,WAAaD,WAAWnB,EAAKoB,WACrDD,WAAWJ,EAAaM,UAAYF,WAAWnB,EAAKqB,YAIhE,IAAMf,EAAM,KAAHF,OAAQJ,EAAKsB,gBACtB,GAAKzB,EAAOQ,eAAeC,GAWnBT,EAAOS,GAAKiB,EAAEC,QAAQxB,EAAKE,UAAY,GAC3CL,EAAOS,GAAKiB,EAAE/B,KAAKQ,EAAKE,SAEpBL,EAAOS,GAAKnB,EAAEqC,QAAQxB,EAAKiB,KAAO,IACtCpB,EAAOS,GAAKnB,EAAEK,KAAKQ,EAAKiB,IACxBpB,EAAOS,GAAKmB,EAAEjC,KAAKd,IAErBmB,EAAOS,GAAKE,EAAEhB,KAAKQ,EAAK0B,aAlBO,CAC/B,IAAIC,EAAiB,CAAC,EACtBA,EAAevC,EAAIY,EAAK4B,OACxBD,EAAeE,GAAKV,WAAWnB,EAAKoB,WACpCO,EAAeG,GAAKX,WAAWnB,EAAKqB,UACpCM,EAAeJ,EAAI,CAACvB,EAAKE,SACzByB,EAAexC,EAAI,CAACa,EAAKiB,IACzBU,EAAeF,EAAI,CAAC/C,GACpBiD,EAAenB,EAAI,CAACR,EAAK0B,SACzB7B,EAAOS,GAAOqB,CAChB,CAUF,CAAC,OAAAlC,GAAAmB,EAAAlB,EAAAD,EAAA,SAAAmB,EAAAjB,GAAA,CACD,OAAOE,CACT,CA/DiBkC,CAAwBrC,EAAEsC,MACzCxD,KAAKyD,YAAYpC,EACnB,E","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/./src/tools/math.ts","webpack://bus/./src/data/apis/getLocation/simplifyLocation-worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\nexport function convertToUnitVector(vector: Array<number>): Array<number> {\n  let length = Math.hypot(vector);\n  let newVector = [];\n  if (length > 0) {\n    let scale = 1 / length;\n    for (const x of vector) {\n      newVector.push(x * scale);\n    }\n    return newVector;\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  let result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function aggregateNumbers(array: Array<number>, exponent: number): Array<number> {\n  const arrLength = array.length;\n\n  if (arrLength < 3) {\n    return array;\n  }\n\n  let sum: number = 0;\n  for (let i = 0; i < arrLength; i++) {\n    sum += array[i];\n  }\n  let average = sum / arrLength;\n\n  let SquaredDeviationSum: number = 0;\n  for (let j = 0; j < arrLength; j++) {\n    SquaredDeviationSum += Math.pow(array[j] - average, 2);\n  }\n  const standardDeviation = Math.sqrt(SquaredDeviationSum / arrLength);\n\n  let exponentials = [];\n  let exponentialSum = 0;\n  for (let k = 0; k < arrLength; k++) {\n    const exponential = Math.exp(array[k] / standardDeviation);\n    exponentialSum += exponential;\n    exponentials.push(exponential);\n  }\n\n  let P = Math.pow(arrLength, exponent);\n  let groupedNumbers = {};\n  for (let l = 0; l < arrLength; l++) {\n    const key = `k_${Math.floor((exponentials[l] / exponentialSum) * P)}`;\n    if (!groupedNumbers.hasOwnProperty(key)) {\n      groupedNumbers[key] = {\n        sum: 0,\n        len: 0\n      };\n    }\n    groupedNumbers[key].sum += array[l];\n    groupedNumbers[key].len += 1;\n  }\n\n  let result = [];\n  for (const key in groupedNumbers) {\n    const thisGroup = groupedNumbers[key];\n    result.push(Math.floor(thisGroup.sum / thisGroup.len));\n  }\n\n  result.sort((a, b) => a - b);\n  return result;\n}\n\nexport function findExtremum(array: Array<number>): [number, number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n","import { convertToUnitVector } from '../../../tools/math';\nimport { Location, SimplifiedLocation, SimplifiedLocationItem } from './index';\n\nself.onmessage = function (e) {\n  const result = simplifyLocation_worker(e.data);\n  self.postMessage(result); // Send the result back to the main thread\n};\n\nfunction simplifyLocation_worker(Location: Location): SimplifiedLocation {\n  let locationsByRoute = {};\n  for (const item of Location) {\n    const thisRouteID = item.routeId;\n    const thisRouteKey = `r_${thisRouteID}`;\n    if (!locationsByRoute.hasOwnProperty(thisRouteKey)) {\n      locationsByRoute[thisRouteKey] = [];\n    }\n    locationsByRoute[thisRouteKey].push(item);\n  }\n  for (const key in locationsByRoute) {\n    locationsByRoute[key] = locationsByRoute[key].sort(function (a, b) {\n      return a.seqNo - b.seqNo;\n    });\n  }\n  let result: SimplifiedLocation = {};\n  for (const item of Location) {\n    let vector = [0, 0];\n    const locationsOnThisRoute = locationsByRoute[`r_${item.routeId}`];\n    const locationsOnThisRouteLength = locationsOnThisRoute.length;\n    let nextLocation = null;\n    for (let i = 0; i < locationsOnThisRouteLength; i++) {\n      if (locationsOnThisRoute[i].Id === item.Id) {\n        let nextIndex = 0;\n        if (i < locationsOnThisRouteLength - 1) {\n          nextIndex = i + 1;\n        }\n        nextLocation = locationsOnThisRoute[nextIndex];\n      }\n    }\n    if (nextLocation) {\n      const x = parseFloat(nextLocation.longitude) - parseFloat(item.longitude);\n      const y = parseFloat(nextLocation.latitude) - parseFloat(item.latitude);\n      vector = convertToUnitVector([x, y]);\n    }\n\n    const key = `l_${item.stopLocationId}`;\n    if (!result.hasOwnProperty(key)) {\n      let simplifiedItem = {} as SimplifiedLocationItem;\n      simplifiedItem.n = item.nameZh;\n      simplifiedItem.lo = parseFloat(item.longitude);\n      simplifiedItem.la = parseFloat(item.latitude);\n      simplifiedItem.r = [item.routeId];\n      simplifiedItem.s = [item.Id];\n      simplifiedItem.v = [vector];\n      simplifiedItem.a = [item.address];\n      result[key] = simplifiedItem;\n    } else {\n      if (!(result[key].r.indexOf(item.routeId) > -1)) {\n        result[key].r.push(item.routeId);\n      }\n      if (!(result[key].s.indexOf(item.Id) > -1)) {\n        result[key].s.push(item.Id);\n        result[key].v.push(vector);\n      }\n      result[key].a.push(item.address);\n    }\n  }\n  return result;\n}\n"],"names":["root","factory","exports","module","define","amd","self","convertToUnitVector","vector","length","Math","hypot","newVector","_step","scale","_iterator","_createForOfIteratorHelper","s","n","done","x","value","push","err","e","f","onmessage","result","Location","locationsByRoute","item","thisRouteID","routeId","thisRouteKey","concat","hasOwnProperty","key","sort","a","b","seqNo","_step2","_iterator2","locationsOnThisRoute","locationsOnThisRouteLength","nextLocation","i","Id","nextIndex","parseFloat","longitude","latitude","stopLocationId","r","indexOf","v","address","simplifiedItem","nameZh","lo","la","simplifyLocation_worker","data","postMessage"],"sourceRoot":""}