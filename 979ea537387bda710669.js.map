{"version":3,"file":"979ea537387bda710669.js","mappings":"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","sources":["webpack://bus/./src/data/analytics/storage-size.ts","webpack://bus/./src/data/analytics/update-rate/index.ts","webpack://bus/./src/data/analytics/bus-arrival-time/index.ts","webpack://bus/./src/data/analytics/data-usage.ts"],"sourcesContent":["import { convertBytes } from '../../tools/convert';\nimport { getStoreKey, getStoresLength, lfGetItem, lfListItemKeys } from '../storage/index';\n\ninterface StoreCategory {\n  name: string;\n  key: string;\n}\n\ninterface StoreSizeInBytes {\n  category: StoreCategory;\n  size: number;\n}\n\ntype CategorizedSizesInBytes = { [key: string]: StoreSizeInBytes };\n\nexport interface StoreSize {\n  category: StoreCategory;\n  size: number;\n}\n\nexport type CategorizedSizes = { [key: string]: StoreSize };\n\nexport interface StoreSizeStatistics {\n  categorizedSizes: CategorizedSizes;\n  totalSize: number;\n}\n\nfunction storeIndexToCategory(store: number): StoreCategory {\n  const storeKey = getStoreKey(store);\n  let name = '';\n  let key = '';\n  switch (storeKey) {\n    case 'cacheStore':\n      name = '快取';\n      key = 'cache';\n      break;\n    case 'settingsStore':\n      name = '設定';\n      key = 'settings';\n      break;\n    case 'dataUsageRecordsStore':\n      name = '分析';\n      key = 'analytics';\n      break;\n    case 'updateRateDataStore':\n      name = '分析';\n      key = 'analytics';\n      break;\n    case 'updateRateDataWriteAheadLogStore':\n      name = '分析';\n      key = 'analytics';\n      break;\n    case 'busArrivalTimeDataWriteAheadLogStore':\n      name = '分析';\n      key = 'analytics';\n      break;\n    case 'busArrivalTimeDataStore':\n      name = '分析';\n      key = 'analytics';\n      break;\n    case 'personalScheduleStore':\n      name = '個人化行程';\n      key = 'personalSchedule';\n      break;\n    case 'recentViewsStore':\n      name = '最近檢視';\n      key = 'recentViews';\n      break;\n    case 'folderListStore':\n      name = '資料夾';\n      key = 'folders';\n      break;\n    case 'folderContentIndexStore':\n      name = '資料夾';\n      key = 'folders';\n      break;\n    case 'folderContentStore':\n      name = '資料夾';\n      key = 'folders';\n      break;\n    default:\n      name = '其他';\n      key = 'others';\n      break;\n  }\n  const result = {\n    name,\n    key\n  };\n  return result;\n}\n\nexport async function getStoresSizeStatistics(): Promise<StoreSizeStatistics> {\n  let totalSizeInBytes = 0;\n  let categorizedSizesInBytes: CategorizedSizesInBytes = {};\n  const storesLength = getStoresLength();\n\n  for (let i = 0; i < storesLength; i++) {\n    const keysInStore = await lfListItemKeys(i);\n    let thisStoreSizeInBytes = 0;\n    for (const itemKey of keysInStore) {\n      const item = await lfGetItem(i, itemKey);\n      const itemInString = String(item);\n      const itemLength = itemInString.length + itemKey.length;\n      totalSizeInBytes += itemLength;\n      thisStoreSizeInBytes += itemLength;\n    }\n    const thisCategory = storeIndexToCategory(i);\n    const thisCategoryKey = thisCategory.key;\n    if (!categorizedSizesInBytes.hasOwnProperty(thisCategoryKey)) {\n      categorizedSizesInBytes[thisCategoryKey] = {\n        category: thisCategory,\n        size: 0\n      };\n    }\n    categorizedSizesInBytes[thisCategory.key].size = categorizedSizesInBytes[thisCategory.key].size + thisStoreSizeInBytes;\n  }\n\n  const totalSize = convertBytes(totalSizeInBytes);\n\n  let categorizedSizes: CategorizedSizes = {};\n  for (const key in categorizedSizesInBytes) {\n    const thisCategory = categorizedSizesInBytes[key].category;\n    const thisCategorySize = categorizedSizesInBytes[key].size;\n    categorizedSizes[key] = {\n      category: thisCategory,\n      size: convertBytes(thisCategorySize)\n    };\n  }\n\n  const result: StoreSizeStatistics = {\n    totalSize,\n    categorizedSizes\n  };\n\n  return result;\n}\n","import { generateIdentifier } from '../../../tools/index';\nimport { lfSetItem, lfGetItem, lfListItemKeys, lfRemoveItem } from '../../storage/index';\nimport { EstimateTime } from '../../apis/getEstimateTime/index';\nimport { mergePearsonCorrelation, mergeStandardDeviation } from '../../../tools/math';\n\nexport type UpdateRateData = [estimateTime: number, timestamp: number]; // EstimateTime (seconds), timestamp (seconds)\n\nexport interface UpdateRateDataGroupStats {\n  estimate_time: {\n    average: number;\n    stdev: number;\n  };\n  timestamp: {\n    average: number;\n    stdev: number;\n  };\n  correlation: number;\n  length: number;\n}\n\nexport interface UpdateRateDataGroup {\n  stats: UpdateRateDataGroupStats;\n  timestamp: number;\n  id: number; // stop id\n}\n\nexport type UpdateRateDataGroupArray = Array<UpdateRateDataGroup>;\n\nexport interface UpdateRateDataWriteAheadLogGroup {\n  data: Array<UpdateRateData>;\n  timestamp: number;\n  id: string;\n}\n\nconst updateRateData_sampleQuantity: number = 16;\nlet updateRateData_trackedStops: Array<number> = [];\nlet updateRateData_writeAheadLog_id: string = '';\nlet updateRateData_writeAheadLog_tracking: boolean = false;\nlet updateRateData_writeAheadLog_currentDataLength: number = 0;\nconst updateRateData_writeAheadLog_maxDataLength: number = 90;\nlet updateRateData_writeAheadLog_group: UpdateRateDataWriteAheadLogGroup = {\n  data: {},\n  timestamp: 0,\n  id: ''\n};\nlet updateRateData_groups: Array<UpdateRateDataGroup> = [];\nlet updateRateData_groupsIndex: { [key: string]: number } = {};\n\nfunction getUpdateRateDataStats(data: Array<UpdateRateData>): UpdateRateDataGroupStats {\n  let sumEstimateTime = 0;\n  let sumEstimateTimeSquared = 0;\n  let sumTimestamp = 0;\n  let sumTimestampSquared = 0;\n  let dataLength = 0;\n  for (const item of data) {\n    const estimateTime = item[0];\n    const timestamp = item[1];\n    dataLength += 1;\n    sumEstimateTime += estimateTime;\n    sumTimestamp += timestamp;\n    sumEstimateTimeSquared += Math.pow(estimateTime, 2);\n    sumTimestampSquared += Math.pow(timestamp, 2);\n  }\n\n  const averageEstimateTime = sumEstimateTime / dataLength;\n  const averageTimestamp = sumTimestamp / dataLength;\n\n  const estimateTimeVariance = sumEstimateTimeSquared / dataLength - Math.pow(averageEstimateTime, 2);\n  const timestampVariance = sumTimestampSquared / dataLength - Math.pow(averageTimestamp, 2);\n\n  const estimateTimeSTDEV = Math.sqrt(estimateTimeVariance);\n  const timestampSTDEV = Math.sqrt(timestampVariance);\n\n  let covariance = 0;\n  for (const item2 of data) {\n    const estimateTime = item2[0];\n    const timestamp = item2[1];\n    covariance += (estimateTime - averageEstimateTime) * (timestamp - averageTimestamp);\n  }\n  covariance /= dataLength;\n\n  const correlation = covariance / (estimateTimeSTDEV * timestampSTDEV);\n\n  const result: UpdateRateDataGroupStats = {\n    estimate_time: {\n      average: averageEstimateTime,\n      stdev: estimateTimeSTDEV\n    },\n    timestamp: {\n      average: averageTimestamp,\n      stdev: timestampSTDEV\n    },\n    length: dataLength,\n    correlation: correlation\n  };\n  return result;\n}\n\nfunction mergeUpdateRateDataStats(targetStats: UpdateRateDataGroupStats, sourceStats: UpdateRateDataGroupStats): UpdateRateDataGroupStats {\n  const mergedDataLength = targetStats.length + sourceStats.length;\n\n  const mergedAverageEstimateTime = (targetStats.estimate_time.average * targetStats.length + sourceStats.estimate_time.average * sourceStats.length) / mergedDataLength;\n  const mergedAverageTimestamp = (targetStats.timestamp.average * targetStats.length + sourceStats.timestamp.average * sourceStats.length) / mergedDataLength;\n\n  const mergedEstimateTimeSTDEV = mergeStandardDeviation(targetStats.estimate_time.average, targetStats.estimate_time.stdev, targetStats.length, sourceStats.estimate_time.average, sourceStats.estimate_time.stdev, sourceStats.length);\n  const mergedTimestampSTDEV = mergeStandardDeviation(targetStats.timestamp.average, targetStats.timestamp.stdev, targetStats.length, sourceStats.timestamp.average, sourceStats.timestamp.stdev, sourceStats.length);\n\n  const mergedCorrelation = mergePearsonCorrelation(targetStats.estimate_time.average, targetStats.timestamp.average, targetStats.estimate_time.stdev, targetStats.timestamp.stdev, targetStats.length, targetStats.correlation, sourceStats.estimate_time.average, sourceStats.timestamp.average, sourceStats.estimate_time.stdev, sourceStats.timestamp.stdev, sourceStats.length, sourceStats.correlation);\n\n  const result: UpdateRateDataGroupStats = {\n    estimate_time: {\n      average: mergedAverageEstimateTime,\n      stdev: mergedEstimateTimeSTDEV\n    },\n    timestamp: {\n      average: mergedAverageTimestamp,\n      stdev: mergedTimestampSTDEV\n    },\n    length: mergedDataLength,\n    correlation: mergedCorrelation\n  };\n  return result;\n}\n\nexport async function collectUpdateRateData(EstimateTime: EstimateTime) {\n  const now = new Date();\n  const currentTimestamp: number = now.getTime();\n  let needToReset = false;\n  // Initialize\n  if (!updateRateData_writeAheadLog_tracking) {\n    updateRateData_writeAheadLog_tracking = true;\n    updateRateData_trackedStops = [];\n    updateRateData_writeAheadLog_id = generateIdentifier('u');\n    updateRateData_writeAheadLog_group = {\n      data: {},\n      timestamp: currentTimestamp,\n      id: updateRateData_writeAheadLog_id\n    };\n    updateRateData_writeAheadLog_currentDataLength = 0;\n    const EstimateTimeLength1: number = EstimateTime.length - 1;\n    for (let i = 0; i < updateRateData_sampleQuantity; i++) {\n      const randomIndex: number = Math.floor(Math.random() * EstimateTimeLength1);\n      const randomItem = EstimateTime[randomIndex];\n      updateRateData_trackedStops.push(randomItem.StopID);\n    }\n  }\n\n  // Record EstimateTime\n  for (const item of EstimateTime) {\n    const stopID = item.StopID;\n    const stopKey = `s_${stopID}`;\n    if (updateRateData_trackedStops.indexOf(stopID) > -1) {\n      if (!updateRateData_writeAheadLog_group.data.hasOwnProperty(stopKey)) {\n        updateRateData_writeAheadLog_group.data[stopKey] = [];\n      }\n      updateRateData_writeAheadLog_group.data[stopKey].push([parseInt(item.EstimateTime), Math.floor((currentTimestamp - updateRateData_writeAheadLog_group.timestamp) / 1000)]);\n      updateRateData_writeAheadLog_currentDataLength += 1;\n      if (updateRateData_writeAheadLog_currentDataLength > updateRateData_writeAheadLog_maxDataLength) {\n        needToReset = true;\n      }\n    }\n  }\n\n  if (updateRateData_writeAheadLog_currentDataLength % 15 === 0) {\n    await lfSetItem(4, updateRateData_writeAheadLog_id, JSON.stringify(updateRateData_writeAheadLog_group));\n  }\n\n  if (needToReset) {\n    for (const stopID of updateRateData_trackedStops) {\n      const stopKey = `s_${stopID}`;\n      const data = updateRateData_writeAheadLog_group.data[stopKey];\n      let dataGroup = {} as UpdateRateDataGroup;\n      const existingData = await lfGetItem(3, stopKey);\n      if (existingData) {\n        const existingDataObject = JSON.parse(existingData) as UpdateRateDataGroup;\n        dataGroup.stats = mergeUpdateRateDataStats(existingDataObject.stats, getUpdateRateDataStats(data));\n        dataGroup.timestamp = existingDataObject.timestamp;\n        dataGroup.id = stopID;\n      } else {\n        dataGroup.stats = getUpdateRateDataStats(data);\n        dataGroup.timestamp = currentTimestamp;\n        dataGroup.id = stopID;\n      }\n      await lfSetItem(3, stopKey, JSON.stringify(dataGroup));\n      if (updateRateData_groupsIndex.hasOwnProperty(stopKey)) {\n        const existingIndex = updateRateData_groupsIndex[stopKey];\n        updateRateData_groups.splice(existingIndex, 1, dataGroup);\n      } else {\n        updateRateData_groups[stopKey] = updateRateData_groups.length;\n        updateRateData_groups.push(dataGroup);\n      }\n      await lfRemoveItem(4, updateRateData_writeAheadLog_id);\n    }\n\n    updateRateData_writeAheadLog_tracking = false;\n  }\n}\n\nexport async function recoverUpdateRateDataFromWriteAheadLog() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(4);\n  for (const key of keys) {\n    const json = await lfGetItem(4, key);\n    const object = JSON.parse(json) as UpdateRateDataWriteAheadLogGroup;\n    const thisTimestamp = object.timestamp;\n    const thisID = object.id;\n    if (thisTimestamp > oneWeekAgo) {\n      for (const stopKey in object.data) {\n        const thisStopData = object[stopKey];\n        let dataGroup = {} as UpdateRateDataGroup;\n        const existingData = await lfGetItem(3, stopKey);\n        if (existingData) {\n          const existingDataObject = JSON.parse(existingData) as UpdateRateDataGroup;\n          dataGroup.stats = mergeUpdateRateDataStats(existingDataObject.stats, getUpdateRateDataStats(thisStopData));\n          dataGroup.timestamp = existingDataObject.timestamp;\n          dataGroup.id = stopID;\n        } else {\n          dataGroup.stats = getUpdateRateDataStats(thisStopData);\n          dataGroup.timestamp = currentTimestamp;\n          dataGroup.id = stopID;\n        }\n        await lfSetItem(3, stopKey, JSON.stringify(dataGroup));\n        if (updateRateData_groupsIndex.hasOwnProperty(stopKey)) {\n          const existingIndex = updateRateData_groupsIndex[stopKey];\n          updateRateData_groups.splice(existingIndex, 1, dataGroup);\n        } else {\n          updateRateData_groups[stopKey] = updateRateData_groups.length;\n          updateRateData_groups.push(dataGroup);\n        }\n        await lfRemoveItem(4, thisID);\n      }\n    }\n  }\n}\n\nexport async function initializeUpdateRateDataGroups() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(3);\n  let index: number = 0;\n  for (const key of keys) {\n    const json = await lfGetItem(3, key);\n    if (json) {\n      const object = JSON.parse(json) as UpdateRateDataGroup;\n      const thisTimestamp = object.timestamp;\n      if (thisTimestamp > oneWeekAgo) {\n        updateRateData_groups.push(object);\n        updateRateData_groupsIndex[key] = index;\n        index += 1;\n      }\n    }\n  }\n}\n\nexport function listUpdateRateDataGroups(): Array<UpdateRateDataGroup> {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  return updateRateData_groups.filter((item) => item.timestamp > oneWeekAgo);\n}\n\nexport async function discardExpiredUpdateRateDataGroups() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(3);\n  for (const key of keys) {\n    const json = await lfGetItem(3, key);\n    const object = JSON.parse(json) as UpdateRateDataGroup;\n    const thisTimestamp = object.timestamp;\n    if (thisTimestamp <= oneWeekAgo) {\n      await lfRemoveItem(3, key);\n    }\n  }\n}\n\nlet getUpdateRateWorkerResponses = {};\nvar port;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getUpdateRateSharedWorker = new SharedWorker(new URL('./getUpdateRate-worker.ts', import.meta.url)); // Reusable shared worker\n  port = getUpdateRateSharedWorker.port; // Access the port for communication\n  port.start(); // Start the port (required by some browsers)\n} else {\n  const getUpdateRateWorker = new Worker(new URL('./getUpdateRate-worker.ts', import.meta.url)); // Fallback to standard worker\n  port = getUpdateRateWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\nport.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getUpdateRateWorkerResponses[taskID]) {\n    getUpdateRateWorkerResponses[taskID](result); // Resolve the correct promise\n    delete getUpdateRateWorkerResponses[taskID]; // Clean up the response handler\n  }\n};\n\n// Handle errors\nport.onerror = function (e) {\n  console.error(e.message);\n};\n\nexport async function getUpdateRate(): Promise<number> {\n  const dataGroups = await listUpdateRateDataGroups();\n  const taskID = generateIdentifier('t');\n\n  const result = await new Promise((resolve, reject) => {\n    getUpdateRateWorkerResponses[taskID] = resolve; // Store the resolve function for this taskID\n\n    port.onerror = function (e) {\n      reject(e.message);\n    };\n\n    port.postMessage([dataGroups, taskID]); // Send the task to the worker\n  });\n\n  return result;\n}\n\n/*\nexport async function getUpdateRateInTime(): Promise<string> {\n  let totalWeight: number = 0;\n  let totalAverageChange: number = 0;\n  let weightedAverageChange: number = 0;\n  const dataGroup = await listUpdateRateDataGroups();\n  for (const dataSet of dataGroup) {\n    const groups = splitDataByDelta(dataSet);\n    for (const group of groups) {\n      const firstColumn: Array<number> = group.map((item) => item[0]);\n      const secondColumn: Array<number> = group.map((item) => item[1]);\n      const rowCount: number = firstColumn.length;\n      let timeStampUponChanges: Array<number> = [];\n      for (let i = 1; i < rowCount; i++) {\n        const change: number = Math.abs(firstColumn[i] - firstColumn[i - 1]);\n        if (change > 0) {\n          timeStampUponChanges.push(secondColumn[i]);\n        }\n      }\n      const timeStampUponChangesLength: number = timeStampUponChanges.length;\n      let totalChange: number = 0;\n      let average: number = 0;\n      for (let i = 1; i < timeStampUponChangesLength; i++) {\n        const change: number = Math.abs(timeStampUponChanges[i] - timeStampUponChanges[i - 1]); // measured in seconds\n        totalChange += change;\n      }\n      average = totalChange / (timeStampUponChangesLength - 1);\n      totalAverageChange += isNaN(average) ? 0 : average * rowCount;\n      totalWeight += isNaN(average) ? 0 : rowCount;\n    }\n  }\n  weightedAverageChange = totalAverageChange / totalWeight;\n  return isNaN(weightedAverageChange) ? '!' : formatTime(weightedAverageChange, 0);\n}\n*/\n","import { generateIdentifier } from '../../../tools/index';\nimport { findExtremum } from '../../../tools/math';\nimport { WeekDayIndex } from '../../../tools/time';\nimport { EstimateTime } from '../../apis/getEstimateTime/index';\nimport { listAllFolderContent } from '../../folder/index';\nimport { isInPersonalSchedule, listPersonalSchedules } from '../../personal-schedule/index';\nimport { PersonalSchedule } from '../../personal-schedule/index';\nimport { lfGetItem, lfListItemKeys, lfSetItem, lfRemoveItem } from '../../storage/index';\n\nconst busArrivalTimeData_writeAheadLog_maxDataLength: number = 32;\nlet busArrivalTimeData_writeAheadLog_id: string = '';\nlet busArrivalTimeData_writeAheadLog_tracking: boolean = false;\nlet busArrivalTimeData_trackedStops: Array<number> = [];\nlet busArrivalTimeData_writeAheadLog_group: BusArrivalTimeDataWriteAheadLog = {\n  data: {},\n  timestamp: 0,\n  id: ''\n};\nlet busArrivalTimeData_writeAheadLog_currentDataLength: number = 0;\n\nexport type BusArrivalTimeData = [estimateTime: number, timestamp: number]; // EstimateTime (seconds), timestamp (milliseconds)\n\nexport type BusArrivalTimeDataGroupStats = Array<number>;\n\nexport interface BusArrivalTimeDataGroup {\n  stats: BusArrivalTimeDataGroupStats;\n  day: WeekDayIndex;\n  max: number;\n  min: number;\n  timestamp: number;\n  id: number; // stop id\n}\n\nexport type BusArrivalTimeDataGroupArray = Array<BusArrivalTimeDataGroup>;\n\nexport interface BusArrivalTimeDataWriteAheadLog {\n  data: {\n    [key: string]: Array<BusArrivalTimeData>;\n  };\n  timestamp: number;\n  id: string;\n}\n\nexport interface BusArrivalTime {\n  personalSchedule: PersonalSchedule;\n  chart: string; // svg\n  day: WeekDayIndex;\n}\n\nexport interface BusArrivalTimes {\n  [stopKey: string]: Array<BusArrivalTime>;\n}\n\nfunction getBusArrivalTimeDataStats(data: Array<BusArrivalTimeData>): BusArrivalTimeDataGroupStats {\n  const statsArray = new Uint32Array(60 * 24); // one day in minutes\n  const dataLength = data.length;\n  for (let i = dataLength - 1; i >= 0; i--) {\n    const item = data[i];\n    let time = 0;\n    let offset = 0;\n    if (item[0] >= 0) {\n      time = item[1] + item[0] * 1000;\n      offset = 1;\n    } else {\n      time = item[1];\n      offset = 0;\n    }\n    const date = new Date(time);\n    const index = date.getHours() * 60 + date.getMinutes();\n    statsArray[index] += offset;\n  }\n  return Array.from(statsArray);\n}\n\nfunction mergeBusArrivalTimeDataStats(targetStats: BusArrivalTimeDataGroupStats, sourceStats: BusArrivalTimeDataGroupStats): BusArrivalTimeDataGroupStats {\n  const mergedArray = new Uint32Array(60 * 24);\n  for (let i = 60 * 24 - 1; i >= 0; i--) {\n    mergedArray[i] = targetStats[i] + sourceStats[i];\n  }\n  return Array.from(mergedArray);\n}\n\nexport async function collectBusArrivalTimeData(EstimateTime: EstimateTime) {\n  const now = new Date();\n  const currentTimestamp: number = now.getTime();\n  const currentDay = now.getDay();\n  let needToReset = false;\n  // Initialize\n  if (!busArrivalTimeData_writeAheadLog_tracking) {\n    busArrivalTimeData_writeAheadLog_tracking = true;\n    busArrivalTimeData_writeAheadLog_id = generateIdentifier('b');\n    busArrivalTimeData_writeAheadLog_group = {\n      id: busArrivalTimeData_writeAheadLog_id,\n      timestamp: currentTimestamp,\n      data: {}\n    };\n    busArrivalTimeData_writeAheadLog_currentDataLength = 0;\n    const allFolderContent = await listAllFolderContent(['stop']);\n    busArrivalTimeData_trackedStops = allFolderContent.map((e) => e.id);\n  }\n\n  // Record EstimateTime\n  if (isInPersonalSchedule(now)) {\n    for (const item of EstimateTime) {\n      const stopID = item.StopID;\n      const stopKey = `s_${stopID}_${currentDay}`;\n      if (busArrivalTimeData_trackedStops.indexOf(stopID) > -1) {\n        if (!busArrivalTimeData_writeAheadLog_group.data.hasOwnProperty(stopKey)) {\n          busArrivalTimeData_writeAheadLog_group.data[stopKey] = [];\n        }\n        busArrivalTimeData_writeAheadLog_group.data[stopKey].push([parseInt(item.EstimateTime), currentTimestamp]);\n        busArrivalTimeData_writeAheadLog_currentDataLength += 1;\n        if (busArrivalTimeData_writeAheadLog_currentDataLength > busArrivalTimeData_writeAheadLog_maxDataLength) {\n          needToReset = true;\n        }\n      }\n    }\n    if (needToReset || busArrivalTimeData_writeAheadLog_currentDataLength % 8 === 0) {\n      await lfSetItem(5, busArrivalTimeData_writeAheadLog_id, JSON.stringify(busArrivalTimeData_writeAheadLog_group));\n    }\n    if (needToReset) {\n      for (const stopID of busArrivalTimeData_trackedStops) {\n        const stopKey = `s_${stopID}_${currentDay}`;\n        const data = busArrivalTimeData_writeAheadLog_group.data[stopKey];\n        let dataGroup = {} as BusArrivalTimeDataGroup;\n        const existingData = await lfGetItem(6, stopKey);\n        if (existingData) {\n          const existingDataObject = JSON.parse(existingData) as BusArrivalTimeDataGroup;\n          const newStats = getBusArrivalTimeDataStats(data);\n          const mergedStats = mergeBusArrivalTimeDataStats(existingDataObject.stats, newStats);\n          dataGroup.stats = mergedStats;\n          const newExtremum = findExtremum(mergedStats);\n          dataGroup.min = newExtremum[0];\n          dataGroup.max = newExtremum[1];\n          dataGroup.day = currentDay;\n          dataGroup.timestamp = existingDataObject.timestamp;\n          dataGroup.id = stopID;\n        } else {\n          const newStats = getBusArrivalTimeDataStats(data);\n          dataGroup.stats = newStats;\n          const newExtremum = findExtremum(newStats);\n          dataGroup.min = newExtremum[0];\n          dataGroup.max = newExtremum[1];\n          dataGroup.day = currentDay;\n          dataGroup.timestamp = currentTimestamp;\n          dataGroup.id = stopID;\n        }\n        await lfSetItem(6, stopKey, JSON.stringify(dataGroup));\n        await lfRemoveItem(5, busArrivalTimeData_writeAheadLog_id);\n      }\n      busArrivalTimeData_writeAheadLog_tracking = false;\n    }\n  }\n}\n\nexport async function recoverBusArrivalTimeDataFromWriteAheadLog() {\n  const now = new Date();\n  const currentTimestamp = now.getTime();\n  const currentDay = now.getDay();\n  const keys = await lfListItemKeys(5);\n  for (const key of keys) {\n    const json = await lfGetItem(5, key);\n    const object = JSON.parse(json) as BusArrivalTimeDataWriteAheadLog;\n    const thisID = object.id;\n    for (const stopKey in object.data) {\n      const thisStopData = object[stopKey];\n      let dataGroup = {} as BusArrivalTimeDataGroup;\n      const existingData = await lfGetItem(6, stopKey);\n      if (existingData) {\n        const existingDataObject = JSON.parse(existingData) as BusArrivalTimeDataGroup;\n        const newStats = getBusArrivalTimeDataStats(thisStopData);\n        dataGroup.stats = mergeBusArrivalTimeDataStats(existingDataObject.stats, newStats);\n        const newExtremum = findExtremum(newStats.concat(existingDataObject.max, existingDataObject.min));\n        dataGroup.min = newExtremum[0];\n        dataGroup.max = newExtremum[1];\n        dataGroup.day = existingDataObject.day;\n        dataGroup.timestamp = existingDataObject.timestamp;\n        dataGroup.id = stopID;\n      } else {\n        const newStats = getBusArrivalTimeDataStats(thisStopData);\n        dataGroup.stats = newStats;\n        const newExtremum = findExtremum(newStats);\n        dataGroup.min = newExtremum[0];\n        dataGroup.max = newExtremum[1];\n        dataGroup.day = currentDay;\n        dataGroup.timestamp = currentTimestamp;\n        dataGroup.id = stopID;\n      }\n      await lfSetItem(6, stopKey, JSON.stringify(dataGroup));\n      await lfRemoveItem(5, thisID);\n    }\n  }\n}\n\nexport async function listBusArrivalTimeDataGroups(): Promise<BusArrivalTimeDataGroupArray> {\n  const keys = await lfListItemKeys(6);\n  let result: BusArrivalTimeDataGroupArray = [];\n  for (const key of keys) {\n    const json = await lfGetItem(6, key);\n    if (json) {\n      const object = JSON.parse(json) as BusArrivalTimeDataGroup;\n      result.push(object);\n    }\n  }\n  return result;\n}\n\nlet getBusArrivalTimesWorkerResponses = {};\nvar port;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getUpdateRateSharedWorker = new SharedWorker(new URL('./getBusArrivalTimes-worker.ts', import.meta.url)); // Reusable shared worker\n  port = getUpdateRateSharedWorker.port; // Access the port for communication\n  port.start(); // Start the port (required by some browsers)\n} else {\n  const getUpdateRateWorker = new Worker(new URL('./getBusArrivalTimes-worker.ts', import.meta.url)); // Fallback to standard worker\n  port = getUpdateRateWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\nport.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getBusArrivalTimesWorkerResponses[taskID]) {\n    getBusArrivalTimesWorkerResponses[taskID](result); // Resolve the correct promise\n    delete getBusArrivalTimesWorkerResponses[taskID]; // Clean up the response handler\n  }\n};\n\n// Handle errors\nport.onerror = function (e) {\n  console.error(e.message);\n};\n\nexport async function getBusArrivalTimes(chartWidth: number, chartHeight: number): Promise<BusArrivalTimes> {\n  const taskID = generateIdentifier('t');\n\n  const personalSchedules = await listPersonalSchedules();\n  const busArrivalTimeDataGroups = await listBusArrivalTimeDataGroups();\n\n  const result = await new Promise((resolve, reject) => {\n    getBusArrivalTimesWorkerResponses[taskID] = resolve; // Store the resolve function for this taskID\n    port.onerror = function (e) {\n      reject(e.message);\n    };\n    port.postMessage([personalSchedules, busArrivalTimeDataGroups, chartWidth, chartHeight, taskID]); // Send the task to the worker\n  });\n  return result;\n}\n","import { convertBytes } from '../../tools/convert';\nimport { segmentsToPath, simplifyPath } from '../../tools/path';\nimport { dateToString, TimeStampPeriod } from '../../tools/time';\nimport { lfSetItem, lfGetItem, lfListItemKeys, lfRemoveItem } from '../storage/index';\n\nlet incompleteRecords = {};\n\nexport async function recordRequest(requestID: string, data: object, incomplete: boolean) {\n  if (!incompleteRecords.hasOwnProperty(requestID)) {\n    incompleteRecords[requestID] = data;\n  }\n  incompleteRecords[requestID].end_time = data.end_time;\n  incompleteRecords[requestID].content_length = incompleteRecords[requestID].content_length + data.content_length;\n\n  if (!incomplete) {\n    if (incompleteRecords.hasOwnProperty(requestID)) {\n      await lfSetItem(2, requestID, JSON.stringify(incompleteRecords[requestID]));\n      delete incompleteRecords[requestID];\n    }\n  }\n}\n\nexport async function discardExpiredDataUsageRecords() {\n  const keys = await lfListItemKeys(2);\n  for (const key of keys) {\n    const json = await lfGetItem(2, key);\n    const object: object = JSON.parse(json);\n    if (new Date().getTime() - object.timeStamp > 60 * 60 * 24 * 30 * 1000) {\n      await lfRemoveItem(2, key);\n    }\n  }\n}\n\nexport async function getDataUsageRecordsPeriod(): Promise<TimeStampPeriod> {\n  const keys = await lfListItemKeys(2);\n  let startTimeArray = [];\n  let endTimeArray = [];\n  for (const key of keys) {\n    const json = await lfGetItem(2, key);\n    const object = JSON.parse(json);\n    startTimeArray.push(object.start_time);\n    endTimeArray.push(object.end_time);\n  }\n  const minStartTime = new Date(Math.min(...startTimeArray));\n  const maxEndTime = new Date(Math.max(...endTimeArray));\n\n  return {\n    start: minStartTime,\n    end: maxEndTime\n  };\n}\n\nexport async function calculateTotalDataUsage(): Promise<string> {\n  const keys = await lfListItemKeys(2);\n  let totalContentLength = 0;\n  for (const key of keys) {\n    const json = await lfGetItem(2, key);\n    const object = JSON.parse(json);\n    totalContentLength += object.content_length;\n  }\n  return convertBytes(totalContentLength);\n}\n\nexport type AggregationPeriod = 'minutely' | 'hourly' | 'daily';\n\nexport async function generateDataUsageGraph(aggregationPeriod: AggregationPeriod, width: number, height: number, padding: number): Promise<string | boolean> {\n  const keys = await lfListItemKeys(2);\n  let dateToStringTemplate = 'YYYY_MM_DD_hh_mm_ss';\n  switch (aggregationPeriod) {\n    case 'minutely':\n      dateToStringTemplate = 'YYYY_MM_DD_hh_mm';\n      break;\n    case 'hourly':\n      dateToStringTemplate = 'YYYY_MM_DD_hh';\n      break;\n    case 'daily':\n      dateToStringTemplate = 'YYYY_MM_DD';\n      break;\n    default:\n      break;\n  }\n\n  let aggregatedData = {};\n  for (const key of keys) {\n    const json = await lfGetItem(2, key);\n    const object = JSON.parse(json);\n    const startDate = new Date(object.start_time);\n    const graphDataKey = `d_${dateToString(startDate, dateToStringTemplate)}`;\n    if (!aggregatedData.hasOwnProperty(graphDataKey)) {\n      aggregatedData[graphDataKey] = { start_time: object.start_time, end_time: object.end_time, content_length: 0 };\n    }\n    aggregatedData[graphDataKey].content_length = aggregatedData[graphDataKey].content_length + object.content_length;\n    if (object.start_time < aggregatedData[graphDataKey].start_time) {\n      aggregatedData[graphDataKey].start_time = object.start_time;\n    }\n    if (object.end_time > aggregatedData[graphDataKey].end_time) {\n      aggregatedData[graphDataKey].end_time = object.end_time;\n    }\n  }\n\n  let graphDataArray = [];\n  for (const graphDataKey in aggregatedData) {\n    const item = aggregatedData[graphDataKey];\n    graphDataArray.push(item);\n  }\n\n  if (graphDataArray.length > 3) {\n    graphDataArray.sort(function (a, b) {\n      return a.start_time - b.start_time;\n    });\n    const startTimeArray = graphDataArray.map((e) => e.start_time);\n    const minStartTime = Math.min(...startTimeArray);\n    const maxStartTime = Math.max(...startTimeArray);\n\n    const contentLengthArray = graphDataArray.map((e) => e.content_length);\n    const minContentLength = Math.min(...contentLengthArray);\n    const maxContentLength = Math.max(...contentLengthArray);\n\n    let points = [];\n    for (const graphData of graphDataArray) {\n      const point = {\n        x: Math.round(padding + ((graphData.start_time - minStartTime) / (maxStartTime - minStartTime)) * width),\n        y: Math.round(padding + (1 - (graphData.content_length - minContentLength) / (maxContentLength - minContentLength)) * height)\n      };\n      points.push(point);\n    }\n\n    // X-axis (horizontal)\n    const xAxis = `<line x1=\"${padding}\" y1=\"${height + padding}\" x2=\"${padding + width}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n    // Y-axis (vertical)\n    const yAxis = `<line x1=\"${padding}\" y1=\"${padding}\" x2=\"${padding}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n    // Axis Labels\n    const xAxisLabel = `<text x=\"${padding + width / 2}\" y=\"${padding + height + padding}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\">時間</text>`;\n    const yAxisLabel = `<text x=\"${padding / 2}\" y=\"${padding + height / 2}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\" transform=\"rotate(-90, ${padding * 0.7}, ${padding + height / 2})\">傳輸量</text>`;\n\n    // Paths\n    const simplifiedPath = simplifyPath(points, 1.1);\n    const pathData = segmentsToPath(simplifiedPath, 1);\n    const fillingPathData = `M${padding},${height + padding}${pathData}L${padding + width},${height + padding}L${padding},${height + padding}`;\n    const path = `<path d=\"${pathData}\" fill=\"none\" stroke=\"var(--b-cssvar-main-color)\" stroke-width=\"0.9\" stroke-linecap=\"round\" stroke-linejoin=\"round\" opacity=\"1\"></path>`;\n    const fillingPath = `<path d=\"${fillingPathData}\" stroke=\"none\" stroke-width=\"0\" fill=\"url(#grad1)\"></path>`;\n    const filling = `<linearGradient id=\"grad1\" x1=\"50%\" y1=\"0%\" x2=\"50%\" y2=\"100%\"><stop offset=\"0%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.3);\" /><stop offset=\"73%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.09);\" /><stop offset=\"100%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0);\" /></linearGradient>`;\n\n    // SVG\n    return /*html*/ `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width + padding * 2}px\" height=\"${height + padding * 2}px\" viewBox=\"0 0 ${width + padding * 2} ${height + padding * 2}\"><defs>${filling}</defs>${fillingPath}${path}${xAxis}${yAxis}${xAxisLabel}${yAxisLabel}</svg>`;\n  } else {\n    return false;\n  }\n}\n"],"names":["storeIndexToCategory","store","name","key","getStoreKey","getStoresSizeStatistics","_getStoresSizeStatistics","apply","arguments","totalSizeInBytes","categorizedSizesInBytes","storesLength","getStoresLength","i","_step","thisStoreSizeInBytes","_iterator","_createForOfIteratorHelper","lfListItemKeys","s","n","done","itemKey","value","item","lfGetItem","itemLength","String","length","err","e","f","thisCategory","thisCategoryKey","hasOwnProperty","category","size","totalSize","convertBytes","categorizedSizes","thisCategorySize","updateRateData_trackedStops","updateRateData_writeAheadLog_id","updateRateData_writeAheadLog_tracking","updateRateData_writeAheadLog_currentDataLength","updateRateData_writeAheadLog_group","data","timestamp","id","updateRateData_groups","updateRateData_groupsIndex","getUpdateRateDataStats","sumEstimateTime","sumEstimateTimeSquared","sumTimestamp","sumTimestampSquared","dataLength","estimateTime","Math","pow","_step2","averageEstimateTime","averageTimestamp","estimateTimeVariance","timestampVariance","estimateTimeSTDEV","sqrt","timestampSTDEV","covariance","_iterator2","item2","estimate_time","average","stdev","correlation","mergeUpdateRateDataStats","targetStats","sourceStats","mergedDataLength","mergedAverageEstimateTime","mergedAverageTimestamp","mergeStandardDeviation","mergePearsonCorrelation","collectUpdateRateData","_x","_collectUpdateRateData","_asyncToGenerator","EstimateTime","currentTimestamp","Date","getTime","needToReset","generateIdentifier","EstimateTimeLength1","randomItem","floor","random","push","StopID","_step3","_iterator3","stopID","stopKey","concat","indexOf","parseInt","lfSetItem","JSON","stringify","_step4","_iterator4","dataGroup","existingData","existingDataObject","parse","stats","existingIndex","splice","lfRemoveItem","recoverUpdateRateDataFromWriteAheadLog","_recoverUpdateRateDataFromWriteAheadLog","_step5","oneWeekAgo","_iterator5","json","object","thisTimestamp","thisID","thisStopData","initializeUpdateRateDataGroups","_initializeUpdateRateDataGroups","_step6","index","_iterator6","discardExpiredUpdateRateDataGroups","_discardExpiredUpdateRateDataGroups","_step7","_iterator7","port","getUpdateRateWorkerResponses","SharedWorker","getUpdateRateSharedWorker","URL","start","getUpdateRateWorker","Worker","getUpdateRate","_getUpdateRate","dataGroups","filter","taskID","Promise","resolve","reject","onerror","message","postMessage","onmessage","_e$data","_slicedToArray","result","console","error","busArrivalTimeData_writeAheadLog_id","busArrivalTimeData_writeAheadLog_tracking","busArrivalTimeData_trackedStops","busArrivalTimeData_writeAheadLog_group","busArrivalTimeData_writeAheadLog_currentDataLength","getBusArrivalTimeDataStats","statsArray","Uint32Array","time","offset","date","getHours","getMinutes","Array","from","mergeBusArrivalTimeDataStats","mergedArray","collectBusArrivalTimeData","_collectBusArrivalTimeData","now","currentDay","getDay","allFolderContent","listAllFolderContent","map","isInPersonalSchedule","newStats","mergedStats","newExtremum","findExtremum","min","max","day","recoverBusArrivalTimeDataFromWriteAheadLog","_recoverBusArrivalTimeDataFromWriteAheadLog","_listBusArrivalTimeDataGroups","getBusArrivalTimesWorkerResponses","getBusArrivalTimes","_x2","_x3","_getBusArrivalTimes","chartWidth","chartHeight","personalSchedules","listPersonalSchedules","busArrivalTimeDataGroups","listBusArrivalTimeDataGroups","incompleteRecords","recordRequest","_recordRequest","requestID","incomplete","end_time","content_length","discardExpiredDataUsageRecords","_discardExpiredDataUsageRecords","timeStamp","getDataUsageRecordsPeriod","_getDataUsageRecordsPeriod","startTimeArray","endTimeArray","start_time","end","calculateTotalDataUsage","_calculateTotalDataUsage","totalContentLength","generateDataUsageGraph","_x4","_x5","_x6","_x7","_generateDataUsageGraph","aggregationPeriod","width","height","padding","keys","dateToStringTemplate","aggregatedData","startDate","graphDataKey","dateToString","graphDataArray","sort","a","b","minStartTime","_toConsumableArray","maxStartTime","contentLengthArray","minContentLength","maxContentLength","points","graphData","point","x","round","y","xAxis","yAxis","xAxisLabel","yAxisLabel","simplifiedPath","simplifyPath","pathData","segmentsToPath","fillingPathData","path","fillingPath"],"sourceRoot":""}