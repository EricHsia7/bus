{"version":3,"file":"2615c33bb60eb62784f6.min.js","mappings":"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","sources":["webpack://bus/./src/tools/address.ts","webpack://bus/./src/tools/array.ts","webpack://bus/./src/tools/convert.ts","webpack://bus/./src/tools/graphic.ts","webpack://bus/./src/tools/index.ts","webpack://bus/./src/tools/labels.ts"],"sourcesContent":["import { generateLetterLabels } from './labels';\nimport { areItemsDifferent } from './array';\n\nexport function mergeAddressesIntoOne(addresses: Array<string>): object | string {\n  const parts = [\n    {\n      suffixes: '市',\n      key: 'city',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '區',\n      key: 'district',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '鄉鎮村里',\n      key: 'area',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '路街道',\n      key: 'road',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.replaceAll(/[\\(\\)\\（\\）]/gim, '').trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '段',\n      key: 'road_section',\n      process: function (e) {\n        var toNumber = function (char) {\n          switch (char) {\n            case '一':\n              return 1;\n              break;\n            case '二':\n              return 2;\n              break;\n            case '三':\n              return 3;\n              break;\n            case '四':\n              return 4;\n              break;\n            case '五':\n              return 5;\n              break;\n            case '六':\n              return 6;\n              break;\n            case '七':\n              return 7;\n              break;\n            case '八':\n              return 8;\n              break;\n            case '九':\n              return 9;\n              break;\n            case '十':\n              return 10;\n              break;\n          }\n          if (!isNaN(parseInt(char))) {\n            return parseInt(char);\n          }\n          return 0;\n        };\n        var len = String(e).length;\n        var numbers = [];\n        for (let i = 0; i < len; i++) {\n          var p = toNumber(String(e).charAt(i));\n          if (p === 10) {\n            if (numbers.length > 0) {\n              numbers = [numbers.reduce((a, b) => a + b, 0) * 10];\n            }\n          } else {\n            numbers = [numbers.reduce((a, b) => a + b, 0) + p];\n          }\n        }\n        return numbers;\n      },\n      type: 0\n    },\n    {\n      suffixes: '巷',\n      key: 'alley',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return parseInt(t.trim().replaceAll(/[巷]/gim));\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '弄',\n      key: 'alley_branch',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return parseInt(t.trim().replaceAll(/[弄]/gim));\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '號',\n      key: 'doorplate',\n      process: function (e) {\n        var numbers = String(e).match(/[0-9]+/gim);\n        numbers =\n          numbers?.map((n) => {\n            if (n === null) {\n              return null;\n            } else {\n              return parseInt(n);\n            }\n          }) || null;\n        return numbers;\n      },\n      type: 0\n    },\n    {\n      suffixes: '樓',\n      key: 'floornumber',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      key: 'exit',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 2\n    },\n    {\n      key: 'direction',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim().replace(/[往向]/gim, '');\n          });\n        }\n      },\n      type: 1\n    }\n  ];\n\n  function parseAddress(address: string): object {\n    function regex(suffixes, type) {\n      if (type === 0) {\n        return new RegExp(`([^市區鄉鎮村里路段街道巷弄號樓與]+[${suffixes}])`, 'gmi');\n      }\n      if (type === 1) {\n        return new RegExp(`([往向]+[東南西北])`, 'gmi');\n      }\n      if (type === 2) {\n        return new RegExp(`([0-9]+[號]出口)`, 'gmi');\n      }\n    }\n    var result = {};\n    for (var part of parts) {\n      var r = regex(part?.suffixes, part.type);\n      result[part.key] = part.process(String(address).match(r));\n    }\n    return result;\n  }\n\n  function mergeAddresses(addresses: Array<string>): object {\n    var result = {};\n    for (var address of addresses) {\n      var parsedAddress = parseAddress(address);\n      for (var part of parts) {\n        if (!result.hasOwnProperty(part.key)) {\n          result[part.key] = [];\n        }\n        result[part.key] = result[part.key].concat(parsedAddress[part.key]);\n      }\n    }\n    for (var key in result) {\n      result[key] = Array.from(new Set(result[key]))\n        .filter((e) => (e ? true : false))\n        .sort(function (a, b) {\n          if (typeof a === 'number' && typeof b === 'number') {\n            return a - b;\n          } else {\n            return String(a).charCodeAt(0) - String(b).charCodeAt(0);\n          }\n        });\n    }\n    return result;\n  }\n  return mergeAddresses(addresses);\n}\n\nexport function addressToString(address: object): string {\n  return `${address.city.join('')}${address.district.join('')}${address.road.join('、')}${\n    address.road_section.sort(function (a, b) {\n      return a - b;\n    }).length > 0\n      ? address.road_section.join('、') + '段'\n      : ''\n  }${\n    address.alley.length > 0\n      ? address.alley\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '巷'\n      : ''\n  }${\n    address.alley_branch.length > 0\n      ? address.alley_branch\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '弄'\n      : ''\n  }${\n    address.doorplate.length > 0\n      ? address.doorplate\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '號'\n      : ''\n  }${address.floornumber.length > 0 ? address.floornumber.join('、') + '樓' : ''}${address.direction.length > 0 ? '（朝' + address.direction.join('、') + '）' : ''}`;\n}\n\nexport function extractCommonFeaturesFromAddresses(addresses: Array<string>): string {\n  // Create an object to store feature occurrences\n  const featureCounts: { [key: string]: { count: number; chars: string; index: number } } = {};\n\n  // Create a set to store unique simplified addresses\n  const simplifiedSet = new Set<string>();\n\n  // Iterate through each address\n  for (const address of addresses) {\n    // Extract common features by splitting the address\n    const features = String(address)\n      .split('')\n      .filter((feature) => feature.trim() !== '');\n\n    // Join the extracted features to create a simplified address\n    const simplifiedAddress = features.join('');\n\n    // Add the simplified address to the set\n    simplifiedSet.add(simplifiedAddress);\n\n    // Count occurrences of each feature\n    let index = 0;\n    for (const feature of features) {\n      // Check if the feature is a digit\n      if (!isNaN(parseInt(feature))) {\n        // Create a key for the digit feature\n        const digitKey = `digit_${index}_${feature.charCodeAt(0)}`;\n        featureCounts[digitKey] = {\n          count: (featureCounts[digitKey]?.count || 0) + 1,\n          chars: feature,\n          index: index\n        };\n      } else {\n        // Create a key for non-digit features\n        const featureKey = `chars_${index}_${feature.charCodeAt(0)}`;\n        featureCounts[featureKey] = {\n          count: (featureCounts[featureKey]?.count || 0) + 1,\n          chars: feature,\n          index: index\n        };\n      }\n      index += 1;\n    }\n  }\n\n  // Set threshold and limit for filtering features\n  const threshold = addresses.length * 0.6;\n  const limit = addresses.length * 1;\n\n  // Convert the feature counts object to an array of [feature, count] pairs\n  const sortedFeatures = Object.entries(featureCounts)\n    .filter((pair) => threshold <= pair[1].count && pair[1].count <= limit)\n    .sort((a, b) => a[1].index - b[1].index);\n\n  // Extract the features from the sorted array\n  const commonFeatures = sortedFeatures.map((pair) => pair[1].chars);\n\n  return commonFeatures.join('');\n}\n\nexport function generateLabelFromAddresses(addresses: Array<object>): Array<string> {\n  var result = [];\n  var filledProperties = {};\n  for (var address of addresses) {\n    for (var key in address) {\n      if (!filledProperties.hasOwnProperty(key)) {\n        filledProperties[key] = 0;\n      }\n      if (address[key].length > 0) {\n        filledProperties[key] = filledProperties[key] + 1;\n      }\n    }\n  }\n  var commonProperties = Object.entries(filledProperties)\n    .map((property) => {\n      return { key: property[0], value: property[1] };\n    })\n    .filter((e) => {\n      return e.value === addresses.length ? true : false;\n    })\n    .sort(function (a, b) {\n      return a.value - b.value;\n    });\n  if (commonProperties.length > 0) {\n    for (var commonProperty of commonProperties) {\n      var components = [];\n      for (var address of addresses) {\n        components.push(address[commonProperty.key].join(''));\n      }\n      if (areItemsDifferent(components)) {\n        result.push({ components: components, len: Math.max(...components.map((e) => e.length)) });\n      }\n    }\n  }\n\n  if (result.length > 0) {\n    result = result.sort(function (a, b) {\n      return a.len - b.len;\n    });\n    return result[0].components;\n  } else {\n    var addressesLength = addresses.length;\n    return generateLetterLabels(addressesLength);\n  }\n}\n","// Function to split data based on delta\nexport function splitDataByDelta(data: Array): Array {\n  const result = [];\n  let currentGroup = [];\n  for (let i = 0; i < data.length; i++) {\n    if (i === 0 || data[i][0] - data[i - 1][0] > 0) {\n      if (currentGroup.length > 0) {\n        result.push(currentGroup);\n      }\n      currentGroup = [data[i]];\n    } else {\n      currentGroup.push(data[i]);\n    }\n  }\n  if (currentGroup.length > 0) {\n    result.push(currentGroup);\n  }\n  return result;\n}\n\nexport function areItemsDifferent(arr: Array): boolean {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) {\n        return false; // Found a duplicate\n      }\n    }\n  }\n  return true; // No duplicates found\n}\n\nexport function getIntersection(arrayA: Array, arrayB: Array): Array {\n  let result = [];\n  if (arrayA.length <= arrayB.length) {\n    for (const item of arrayA) {\n      if (arrayB.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  } else {\n    for (const item of arrayB) {\n      if (arrayA.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  }\n  return result;\n}\n","const ErathRadius = 6378137;\n\nexport function convertPositionsToDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const dLat = (lat2 * Math.PI) / 180 - (lat1 * Math.PI) / 180;\n  const dLon = (lon2 * Math.PI) / 180 - (lon1 * Math.PI) / 180;\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const d = ErathRadius * c;\n  return d; // measured in meters\n}\n\nexport function mercatorProjection(lat: number, lon: number, scale = 1) {\n  const meterToPixelRatio = 100 / 100; // 100 meters = 100 pixels\n\n  // Convert degrees to radians\n  const latRad = (lat * Math.PI) / 180;\n  const lonRad = (lon * Math.PI) / 180;\n\n  // Mercator projection formulas\n  const x = ErathRadius * lonRad;\n  const y = ErathRadius * Math.log(Math.tan(Math.PI / 4 + latRad / 2));\n\n  // Scale based on the ratio (meters to pixels)\n  const xPixels = x * meterToPixelRatio * scale;\n  const yPixels = y * meterToPixelRatio * scale;\n\n  return { x: xPixels, y: yPixels };\n}\n\nexport function convertBytes(contentLength: number): string {\n  const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  let i = 0;\n\n  while (contentLength >= 1024 && i < units.length - 1) {\n    contentLength /= 1024;\n    i++;\n  }\n\n  return `${contentLength.toFixed(2)} ${units[i]}`;\n}\n\nexport function convertNumberToLetters(number: number): string {\n  let result = '';\n  while (number > 0) {\n    let remainder = (number - 1) % 26; // Adjust for 1-based indexing\n    let letter = String.fromCharCode(remainder + 65); // A=65 in ASCII\n    result = letter + result;\n    number = Math.floor((number - 1) / 26); // Update number for next iteration\n  }\n  return result;\n}\n\nexport function convertWKTToArray(wkt: string): Array<[number, number]> {\n  // Extract the part inside the parentheses and split by comma to get the coordinate pairs\n  const coordinates = wkt\n    .replace('LINESTRING (', '')\n    .replace(')', '')\n    .split(', ')\n    .map((coord) => {\n      // For each coordinate pair, split by space and parse as float\n      return coord.split(' ').map(parseFloat);\n    });\n  return coordinates;\n}\n","interface Segment {\n  x: number;\n  y: number;\n}\n\ntype Segments = Array<Segment>;\n\nfunction distanceToSegment(point: Segment, start: Segment, end: Segment): number {\n  let dx = end.x - start.x;\n  let dy = end.y - start.y;\n  const d = dx * dx + dy * dy;\n  const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;\n\n  if (t < 0) {\n    dx = point.x - start.x;\n    dy = point.y - start.y;\n  } else if (t > 1) {\n    dx = point.x - end.x;\n    dy = point.y - end.y;\n  } else {\n    const closestPoint = { x: start.x + t * dx, y: start.y + t * dy };\n    dx = point.x - closestPoint.x;\n    dy = point.y - closestPoint.y;\n  }\n\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function simplifyPath(points: Segments, tolerance: number): Segments {\n  if (points.length < 3) {\n    return points;\n  }\n\n  let dmax = 0;\n  let index = 0;\n\n  // Find the point with the maximum distance\n  for (let i = 1; i < points.length - 1; i++) {\n    const d = distanceToSegment(points[i], points[0], points[points.length - 1]);\n    if (d > dmax) {\n      index = i;\n      dmax = d;\n    }\n  }\n\n  // If max distance is greater than tolerance, split the curve\n  if (dmax > tolerance) {\n    const leftPoints = points.slice(0, index + 1);\n    const rightPoints = points.slice(index);\n    const simplifiedLeft = simplifyPath(leftPoints, tolerance);\n    const simplifiedRight = simplifyPath(rightPoints, tolerance);\n    return simplifiedLeft.slice(0, simplifiedLeft.length - 1).concat(simplifiedRight);\n  } else {\n    return [points[0], points[points.length - 1]];\n  }\n}\n\nexport function segmentsToPath(segments: Segments, scale: number): string {\n  if (segments.length < 1) {\n    return '';\n  }\n  let pathCommand = `M${segments[0].x * scale},${segments[0].y * scale}`;\n  for (let i = 1; i < segments.length - 1; i++) {\n    const current = segments[i];\n    const next = segments[i + 1] || current;\n\n    pathCommand += `Q${current.x * scale},${current.y * scale},${(current.x * scale + next.x * scale) / 2},${(current.y * scale + next.y * scale) / 2}`;\n  }\n  const lastPoint = segments[segments.length - 1];\n  pathCommand += `L${lastPoint.x * scale},${lastPoint.y * scale}`;\n  return pathCommand;\n}\n\nexport function getTextWidth(text: string, weight: number, size: string, fontFamily: string): number {\n  const canvas: HTMLCanvasElement = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  const font: string = `${weight} ${size} ${fontFamily}`;\n  context.font = font;\n  return context.measureText(text).width;\n}\n\ninterface BorderRadius {\n  tl: number;\n  tr: number;\n  br: number;\n  bl: number;\n}\n\nexport function drawRoundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | BorderRadius, fill: string): void {\n  // If radius is a single value, treat it as the same for all corners\n  if (typeof radius === 'number') {\n    radius = { tl: radius, tr: radius, br: radius, bl: radius };\n  } else {\n    // Set defaults if individual radii are not provided\n    radius = {\n      tl: radius.tl || 0,\n      tr: radius.tr || 0,\n      br: radius.br || 0,\n      bl: radius.bl || 0\n    };\n  }\n\n  // Start path\n  ctx.beginPath();\n  // Move to the top-left corner, accounting for the top-left radius\n  ctx.moveTo(x + radius.tl, y);\n  // Draw the top line, rounding the top-right corner\n  ctx.lineTo(x + width - radius.tr, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n  // Draw the right side, rounding the bottom-right corner\n  ctx.lineTo(x + width, y + height - radius.br);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n  // Draw the bottom side, rounding the bottom-left corner\n  ctx.lineTo(x + radius.bl, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n  // Draw the left side, rounding the top-left corner\n  ctx.lineTo(x, y + radius.tl);\n  ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n  // Complete the path\n  ctx.closePath();\n\n  ctx.fillStyle = fill;\n  ctx.fill(); // To fill the shape\n}\n\nexport function drawPoint(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, fill: string, strokeStyle: string, lineWidth: number): void {\n  ctx.beginPath();\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\n  ctx.fillStyle = fill;\n  ctx.fill();\n  ctx.strokeStyle = strokeStyle;\n  ctx.lineWidth = lineWidth;\n  ctx.stroke();\n}\n\nexport function drawLine(ctx: CanvasRenderingContext2D, points: Segments, strokeStyle: string, lineWidth: number): void {\n  ctx.beginPath();\n  ctx.moveTo(points[0].x, points[0].y);\n  for (let i = 1; i < points.length; i++) {\n    const currentPoint = points[i];\n    const nextPoint = points[i + 1] || currentPoint;\n    ctx.quadraticCurveTo(currentPoint.x, currentPoint.y, (currentPoint.x + nextPoint.x) / 2, (currentPoint.y + nextPoint.y) / 2);\n  }\n  ctx.strokeStyle = strokeStyle;\n  ctx.lineWidth = lineWidth;\n  ctx.stroke();\n  ctx.closePath();\n}\n\nexport function generateSVGCircle(centerX: number, centerY: number, radius: number, stroke: string, strokeWidth: number, fill: string): HTMLElement {\n  const circleElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n  circleElement.setAttributeNS(null, 'cx', centerX);\n  circleElement.setAttributeNS(null, 'cy', centerY);\n  circleElement.setAttributeNS(null, 'r', radius);\n  circleElement.setAttributeNS(null, 'fill', fill);\n  circleElement.setAttributeNS(null, 'stroke', stroke);\n  circleElement.setAttributeNS(null, 'stroke-width', strokeWidth);\n  return circleElement;\n}\n","export const md5 = require('md5');\n\nexport function compareThings(a: any, b: any): boolean {\n  function anyToString(any: any): string {\n    return JSON.stringify({ e: any });\n  }\n  const ax = anyToString(a);\n  const bx = anyToString(b);\n  const length: number = 32;\n  const axLength: number = ax.length;\n  const bxLength: number = bx.length;\n  if (axLength === bxLength) {\n    if (axLength > length || bxLength > length) {\n      const hash_a: string = md5(ax);\n      const hash_b: string = md5(bx);\n\n      let equal: boolean = true;\n      for (let i = 0; i < 8; i++) {\n        const a_i: string = hash_a.charAt(i);\n        const b_i: string = hash_b.charAt(i);\n        if (a_i === b_i) {\n          continue;\n        } else {\n          equal = false;\n          break;\n        }\n      }\n      return equal;\n    } else {\n      if (ax === bx) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function generateIdentifier(prefix: string = ''): string {\n  const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n  let result = `${prefix}_`;\n  const length: number = 16;\n  for (let i = 0; i < length; i++) {\n    const randomNumber = Math.round(Math.random() * characterSet.length);\n    result += characterSet.substring(randomNumber, randomNumber + 1);\n  }\n  return result;\n}\n\nexport function getNoCacheParameter(interval: number): string {\n  const time = new Date().getTime();\n  const number = (time / interval).toFixed(0) * interval;\n  const string = number.toString(36);\n  return string;\n}\n\nexport function releaseFile(content: string, type: string = 'application/json', fileName: string): void {\n  const blob = new Blob([content], { type: type });\n  const fileObj = new File([blob], fileName, { type: type });\n  if (navigator.canShare && navigator.canShare({ files: [fileObj] })) {\n    navigator\n      .share({\n        files: [fileObj]\n      })\n      .catch((error) => {});\n  } else {\n    const blobURL = URL.createObjectURL(blob);\n    const downloadLink = document.createElement('a');\n    downloadLink.href = blobURL;\n    downloadLink.download = fileName;\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    downloadLink.remove();\n    setTimeout(() => {\n      URL.revokeObjectURL(blobURL);\n    }, 10 * 1000);\n  }\n}\n\nexport function isRunningStandalone(): boolean {\n  return window.matchMedia('(display-mode: standalone)').matches;\n}\n\nexport function supportTouch(): boolean {\n  if ('ontouchstart' in window || navigator.maxTouchPoints) {\n    // Touch events are supported\n    return true;\n  } else {\n    // Touch events are not supported\n    return false;\n  }\n}\n","import { convertNumberToLetters } from './convert';\nimport { convertToUnitVector } from './math';\n\nexport function generateLetterLabels(quantity: number): Array<string> {\n  let result = [];\n  for (let i = 0; i < quantity; i++) {\n    result.push(`地點${convertNumberToLetters(i + 1)}`);\n  }\n  return result;\n}\n\nexport function generateDirectionLabels(setsOfVectors: Array<Array<[number, number]>>): Array<string> {\n  let result = [];\n  const unknownVector = [0, 0];\n  // cardinal directions\n  const NorthVector = [0, 1];\n  const EastVector = [1, 0];\n  const WestVector = [-1, 0];\n  const SouthVector = [0, -1];\n  // intercardinal directions\n  const NorthEastVector = [Math.sqrt(2) / 2, Math.sqrt(2) / 2]; // 45 degrees\n  const SouthEastVector = [Math.sqrt(2) / 2, -Math.sqrt(2) / 2]; // 135 degrees\n  const SouthWestVector = [-Math.sqrt(2) / 2, -Math.sqrt(2) / 2]; // 225 degrees\n  const NorthWestVector = [-Math.sqrt(2) / 2, Math.sqrt(2) / 2]; // 315 degrees\n\n  const directions = [\n    {\n      vector: unknownVector,\n      label: '未知'\n    },\n    {\n      vector: NorthVector,\n      label: '北'\n    },\n    {\n      vector: EastVector,\n      label: '東'\n    },\n    {\n      vector: SouthVector,\n      label: '南'\n    },\n    {\n      vector: WestVector,\n      label: '西'\n    },\n    {\n      vector: NorthEastVector,\n      label: '東北'\n    },\n    {\n      vector: SouthEastVector,\n      label: '東南'\n    },\n    {\n      vector: SouthWestVector,\n      label: '西南'\n    },\n    {\n      vector: NorthWestVector,\n      label: '西北'\n    }\n  ];\n\n  for (const vectorSet of setsOfVectors) {\n    let x = 0;\n    let y = 0;\n    for (const vector of vectorSet) {\n      x += vector[0];\n      y += vector[1];\n    }\n    const meanVector = convertToUnitVector([x, y]);\n    let result2 = [];\n    for (const direction of directions) {\n      const dotProduct = direction.vector[0] * meanVector[0] + direction.vector[1] * meanVector[1];\n      result2.push({ label: direction.label, dotProduct: dotProduct });\n    }\n    result2 = result2.sort(function (a, b) {\n      return b.dotProduct - a.dotProduct;\n    });\n    const bestMatch = result2[0];\n    result.push(bestMatch.label);\n  }\n  return result;\n}\n"],"names":["addressToString","address","concat","city","join","district","road","road_section","sort","a","b","length","alley","alley_branch","doorplate","floornumber","direction","generateLabelFromAddresses","addresses","_step4","result","filledProperties","_iterator4","_createForOfIteratorHelper","s","n","done","value","key","hasOwnProperty","err","e","f","commonProperties","Object","entries","map","property","filter","_step5","_iterator5","_step6","commonProperty","components","_iterator6","push","areItemsDifferent","len","Math","max","apply","_toConsumableArray","addressesLength","generateLetterLabels","splitDataByDelta","data","currentGroup","i","arr","j","getIntersection","arrayA","arrayB","_step","_iterator","item","indexOf","_step2","_iterator2","ErathRadius","convertPositionsToDistance","lat1","lon1","lat2","lon2","dLat","PI","dLon","sin","cos","c","atan2","sqrt","mercatorProjection","lat","lon","scale","arguments","undefined","latRad","lonRad","x","y","log","tan","convertBytes","contentLength","units","toFixed","convertNumberToLetters","number","remainder","String","fromCharCode","floor","distanceToSegment","point","start","end","dx","dy","d","t","closestPoint","simplifyPath","points","tolerance","dmax","index","leftPoints","slice","rightPoints","simplifiedLeft","simplifiedRight","segmentsToPath","segments","pathCommand","current","next","lastPoint","getTextWidth","text","weight","size","fontFamily","context","canvas","document","createElement","getContext","font","measureText","width","drawRoundedRect","ctx","height","radius","fill","tl","tr","br","bl","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fillStyle","generateSVGCircle","centerX","centerY","stroke","strokeWidth","circleElement","createElementNS","setAttributeNS","md5","require","compareThings","anyToString","any","JSON","stringify","ax","bx","axLength","bxLength","hash_a","hash_b","equal","charAt","generateIdentifier","characterSet","randomNumber","round","random","substring","getNoCacheParameter","interval","Date","getTime","toString","releaseFile","content","type","fileName","blob","Blob","fileObj","File","navigator","canShare","files","share","error","blobURL","URL","createObjectURL","downloadLink","href","download","body","appendChild","click","remove","setTimeout","revokeObjectURL","isRunningStandalone","window","matchMedia","matches","supportTouch","maxTouchPoints","quantity","generateDirectionLabels","setsOfVectors","directions","vector","label","vectorSet","_step3","meanVector","convertToUnitVector","result2","_iterator3","dotProduct","bestMatch"],"sourceRoot":""}