{"version":3,"file":"56eab314e7d65d2f603f.js","mappings":"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","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/./src/tools/array.ts","webpack://bus/./src/tools/math.ts","webpack://bus/./src/data/analytics/update-rate/getUpdateRate_worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","// Function to split data based on delta\n\n/**\n * Splits data into groups based on delta between consecutive elements.\n *\n * @param {Array<[number, number]>} data - Array of tuples where each tuple contains two numbers.\n * @returns {Array<Array<[number, number]>>} - Array of groups, each containing arrays of tuples.\n */\n\nexport function splitDataByDelta(data: Array<[number, number]>): Array<Array<[number, number]>> {\n  const result: Array<Array<[number, number]>> = [];\n  let currentGroup: Array<[number, number]> = [];\n\n  for (let i = 0; i < data.length; i++) {\n    if (i === 0 || data[i][0] - data[i - 1][0] > 0) {\n      if (currentGroup.length > 0) {\n        result.push(currentGroup);\n      }\n      currentGroup = [data[i]];\n    } else {\n      currentGroup.push(data[i]);\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    result.push(currentGroup);\n  }\n\n  return result;\n}\n\nexport function areItemsDifferent(arr: Array): boolean {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) {\n        return false; // Found a duplicate\n      }\n    }\n  }\n  return true; // No duplicates found\n}\n\n/**\n * Get common items from the two arrays\n * @param arrayA - The first array\n * @param arrayB - The second array\n * @returns An array of the common items\n */\n\nexport function getIntersection(arrayA: Array, arrayB: Array): Array {\n  let result = [];\n  if (arrayA.length <= arrayB.length) {\n    for (const item of arrayA) {\n      if (arrayB.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  } else {\n    for (const item of arrayB) {\n      if (arrayA.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  }\n  return result;\n}\n","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function convertToUnitVector(vector: Array<number>): Array<number> {\n  let length = Math.hypot(vector);\n  let newVector = [];\n  if (length > 0) {\n    let scale = 1 / length;\n    for (const x of vector) {\n      newVector.push(x * scale);\n    }\n    return newVector;\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  let result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  // Step 1: Exponentiate each element (for numerical stability, subtract the max value)\n  const max = Math.max(...array);\n  const expArr = array.map((value) => Math.exp(value - max));\n\n  // Step 2: Sum all the exponentiated values\n  const sumExp = expArr.reduce((accumulation, value) => accumulation + value, 0);\n\n  // Step 3: Normalize each value\n  return expArr.map((value) => value / sumExp);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function aggregateNumbers(array: Array<number>, exponent: number): Array<number> {\n  const arrLength = array.length;\n\n  if (arrLength < 3) {\n    return array;\n  }\n\n  let sum: number = 0;\n  for (let i = 0; i < arrLength; i++) {\n    sum += array[i];\n  }\n  let average = sum / arrLength;\n\n  let SquaredDeviationSum: number = 0;\n  for (let j = 0; j < arrLength; j++) {\n    SquaredDeviationSum += Math.pow(array[j] - average, 2);\n  }\n  const standardDeviation = Math.sqrt(SquaredDeviationSum / arrLength);\n\n  let exponentials = [];\n  let exponentialSum = 0;\n  for (let k = 0; k < arrLength; k++) {\n    const exponential = Math.exp(array[k] / standardDeviation);\n    exponentialSum += exponential;\n    exponentials.push(exponential);\n  }\n\n  let P = Math.pow(arrLength, exponent);\n  let groupedNumbers = {};\n  for (let l = 0; l < arrLength; l++) {\n    const key = `k_${Math.floor((exponentials[l] / exponentialSum) * P)}`;\n    if (!groupedNumbers.hasOwnProperty(key)) {\n      groupedNumbers[key] = {\n        sum: 0,\n        len: 0\n      };\n    }\n    groupedNumbers[key].sum += array[l];\n    groupedNumbers[key].len += 1;\n  }\n\n  let result = [];\n  for (const key in groupedNumbers) {\n    const thisGroup = groupedNumbers[key];\n    result.push(Math.floor(thisGroup.sum / thisGroup.len));\n  }\n\n  result.sort((a, b) => a - b);\n  return result;\n}\n","import { splitDataByDelta } from '../../../tools/array';\nimport { pearsonCorrelation } from '../../../tools/math';\n\nlet taskQueue = [];\nlet isProcessing = false;\n\nif ('onconnect' in self) {\n  self.onconnect = function (e) {\n    const port = e.ports[0];\n\n    port.onmessage = function (event) {\n      const [collection, taskID] = event.data;\n      taskQueue.push({ collection, taskID, port });\n      getUpdateRate_worker();\n    };\n  };\n} else {\n  const port = self;\n\n  self.onmessage = function (event) {\n    const [collection, taskID] = event.data;\n    taskQueue.push({ collection, taskID, port });\n    getUpdateRate_worker();\n  };\n}\n\nfunction getUpdateRate_worker(): number {\n  if (isProcessing || taskQueue.length === 0) return;\n\n  isProcessing = true;\n  const { collection, taskID, port } = taskQueue.shift();\n\n  // Perform the calculation\n  let weightedAverage: number = 0;\n  let totalCorrelation: number = 0;\n  let totalWeight: number = 0;\n  for (const dataSet of collection) {\n    const groups = splitDataByDelta(dataSet);\n    for (const group of groups) {\n      const firstColumn: Array<number> = group.map((item) => item[0]);\n      const secondColumn: Array<number> = group.map((item) => item[1]);\n      const correlation: number = pearsonCorrelation(firstColumn, secondColumn);\n      if (!(correlation === 0) && Math.abs(correlation) > 0.2 && !isNaN(correlation)) {\n        totalCorrelation += correlation * firstColumn.length;\n        totalWeight += firstColumn.length;\n      }\n    }\n  }\n  weightedAverage = totalCorrelation / totalWeight;\n  const result = isNaN(weightedAverage) ? 0.8 : Math.abs(weightedAverage);\n\n  // Send the result back to the main thread\n  port.postMessage([result, taskID]);\n\n  isProcessing = false;\n  getUpdateRate_worker(); // Process next task in queue, if any\n}\n"],"names":["root","factory","exports","module","define","amd","self","splitDataByDelta","data","result","currentGroup","i","length","push","pearsonCorrelation","x","y","n","Error","sumX","sumY","sumXY","sumXSquared","sumYSquared","Math","pow","numerator","denominator","sqrt","taskQueue","isProcessing","onconnect","e","port","ports","onmessage","event","_event$data","_slicedToArray","collection","taskID","getUpdateRate_worker","_event$data2","weightedAverage","_step","_taskQueue$shift","shift","totalCorrelation","totalWeight","_iterator","_createForOfIteratorHelper","s","done","_step2","_iterator2","value","group","firstColumn","map","item","correlation","abs","isNaN","err","f","postMessage"],"sourceRoot":""}