{"version":3,"file":"a0a84df9b8cd05fd1413.js","mappings":"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","sources":["webpack://bus/./src/data/apis/getProvider/index.ts","webpack://bus/./src/data/apis/getEstimateTime/index.ts","webpack://bus/./src/data/apis/getAPIURL/index.ts","webpack://bus/./src/data/analytics/storage-size.ts","webpack://bus/./src/data/apis/getRoute/index.ts","webpack://bus/./src/data/apis/getLocation/index.ts","webpack://bus/./src/data/apis/getMaterialSymbolsSearchIndex/index.ts","webpack://bus/./src/data/apis/getCarInfo/index.ts"],"sourcesContent":["import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface ProviderItem {\n  id: number;\n  nameZn: string; // name in Chinese (Zhōngwén)\n  nameEn: string; // name in English\n  email: string;\n  phoneInfo: string;\n  stationId: string;\n  stationNameZn: string;\n  stationNameEn: string;\n  type: '0' | '1' | '2' | '3' | '4' | '5'; // 0: city bus station, 1: coach bus station, 2: MRT station, 3: train station, 4: airport, 5: port\n}\n\nexport type Provider = Array<ProviderItem>;\n\nlet ProviderAPIVariableCache_available: boolean = false;\nlet ProviderAPIVariableCache_data: object = {};\n\nexport async function getProvider(requestID: string): Promise<Provider> {\n  async function getData() {\n    const apis = [\n      [0, 9],\n      [1, 9]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getProvider_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 60 * 1000;\n  const cacheKey = 'bus_provider_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(result));\n    if (!ProviderAPIVariableCache_available) {\n      ProviderAPIVariableCache_available = true;\n      ProviderAPIVariableCache_data = result;\n    }\n    return result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(result));\n      return result;\n    } else {\n      if (!ProviderAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        ProviderAPIVariableCache_available = true;\n        ProviderAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getProvider_0', 0, true);\n      setDataReceivingProgress(requestID, 'getProvider_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return ProviderAPIVariableCache_data;\n    }\n  }\n}\n","import { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataUpdateTime } from '../loader';\n\nexport interface EstimateTimeItem {\n  RouteID: number;\n  StopID: number;\n  EstimateTime: string | '-1' | '-2' | '-3' | '-4'; // x (>=0): remaining time to wait measured in seconds, -1: no departed bus, -2: skip stopping (due to traffic moderation), -3: the next bus will not come until tomorrow, -4: not in operation\n  GoBack: '0' | '1' | '2'; // 0: go, 1: back, 2: unknown\n}\n\nexport type EstimateTime = Array<EstimateTimeItem>;\n\nexport async function getEstimateTime(requestID: string): Promise<EstimateTime> {\n  const apis = [\n    [0, 4],\n    [1, 4]\n  ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n  let result = [];\n  for (const api of apis) {\n    const data = await fetchData(api.url, requestID, `getEstimateTime_${api.e[0]}`, 'json');\n    result = result.concat(data.BusInfo);\n    setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n  }\n  return result;\n}\n","import { getNoCacheParameter } from '../../../tools/index';\nimport { getSettingOptionValue } from '../../settings/index';\n\n/**\n * Get API URL with no cache parameter (query string).\n * @param city - 0: blobbus -> Taipei City, 2: ntpcbus -> New Taipei City\n * @param api - 0: BusData, 1: BusEvent, 2: CarInfo, 3: CarUnusual, 4: EstimateTime, 5: IStop, 6: IStopPath, 7: OrgPathAttribute, 8: PathDetail, 9: Provider, 10: Route, 11: Stop, 12: SemiTimeTable, 13: StopLocation, 14: TimeTable, 15: BusRouteFareList\n * @param alternative - Whether to use alternative resources\n * @param interval - The interval for no cache parameter\n * @returns The direct link to a gzip file.\n */\n\nexport function getAPIURL(city: number, api: number, alternative: boolean = false, interval: number = 10000): string {\n  const cities = ['blobbus', 'ntpcbus'];\n  // blobbus → Taipei City\n  // ntpcbus → New Taipei City\n  const buckets = ['BusData', 'BusEvent', 'CarInfo', 'CarUnusual', 'EstimateTime', 'IStop', 'IStopPath', 'OrgPathAttribute', 'PathDetail', 'Provider', 'Route', 'Stop', 'SemiTimeTable', 'StopLocation', 'TimeTable', 'BusRouteFareList'];\n  const proxy = getSettingOptionValue('proxy');\n  if (alternative) {\n    return `http://erichsia7.github.io/bus-alternative-static-apis/${cities[city]}/Get${buckets[api]}.gz?_=${getNoCacheParameter(interval)}`;\n  } else {\n    if (proxy) {\n      return `https://bus-proxy.erichsia7.workers.dev?url=https://tcgbusfs.blob.core.windows.net/${cities[city]}/Get${buckets[api]}.gz&_=${getNoCacheParameter(interval)}`;\n    } else {\n      return `https://tcgbusfs.blob.core.windows.net/${cities[city]}/Get${buckets[api]}.gz?_=${getNoCacheParameter(interval)}`;\n    }\n  }\n}\n\nexport function getMaterialSymbolsAPIURL(interval: number = 10000): string {\n  return `https://erichsia7.github.io/material-symbols-list/search-index.gz?_=${getNoCacheParameter(interval)}`;\n}\n","import { convertBytes } from '../../tools/convert';\nimport { getStoresLength, lfGetItem, lfListItemKeys } from '../storage/index';\n\ninterface StoreCategory {\n  name: string;\n  key: string;\n}\n\ninterface StoreSizeInBytes {\n  category: StoreCategory;\n  size: number;\n}\n\ntype CategorizedSizesInBytes = { [key: string]: StoreSizeInBytes };\n\nexport interface StoreSize {\n  category: StoreCategory;\n  size: string;\n}\n\nexport type CategorizedSizes = { [key: string]: StoreSize };\n\nexport interface StoreSizeStatistics {\n  categorizedSizes: CategorizedSizes;\n  totalSize: number;\n}\n\nfunction storeIndexToCategory(store: number): StoreCategory {\n  const [name, key] = [\n    ['快取', 'cache'],\n    ['設定', 'settings'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['分析', 'analytics'],\n    ['個人化行程', 'personalSchedule'],\n    ['最近檢視', 'recentViews'],\n    ['通知', 'notification'],\n    ['通知', 'notification'],\n    ['資料夾', 'folders'],\n    ['資料夾', 'folders'],\n    ['資料夾', 'folders']\n  ][store] || ['其他', 'others'];\n  const result = {\n    name,\n    key\n  };\n  return result;\n}\n\nexport async function getStoresSizeStatistics(): Promise<StoreSizeStatistics> {\n  let totalSizeInBytes: number = 0;\n  const categorizedSizesInBytes: CategorizedSizesInBytes = {};\n  const storesLength = getStoresLength();\n\n  for (let i = 0; i < storesLength; i++) {\n    const keysInStore = await lfListItemKeys(i);\n    let thisStoreSizeInBytes: number = 0;\n    for (const itemKey of keysInStore) {\n      const item = await lfGetItem(i, itemKey);\n      const itemInString = String(item);\n      const itemLength = itemInString.length + itemKey.length;\n      totalSizeInBytes += itemLength;\n      thisStoreSizeInBytes += itemLength;\n    }\n    const thisCategory = storeIndexToCategory(i);\n    const thisCategoryKey = thisCategory.key;\n    if (!categorizedSizesInBytes.hasOwnProperty(thisCategoryKey)) {\n      categorizedSizesInBytes[thisCategoryKey] = {\n        category: thisCategory,\n        size: 0\n      };\n    }\n    categorizedSizesInBytes[thisCategory.key].size += thisStoreSizeInBytes;\n  }\n\n  const totalSize = convertBytes(totalSizeInBytes);\n\n  const categorizedSizes: CategorizedSizes = {};\n  for (const key in categorizedSizesInBytes) {\n    const thisCategory = categorizedSizesInBytes[key].category;\n    const thisCategorySize = categorizedSizesInBytes[key].size;\n    categorizedSizes[key] = {\n      category: thisCategory,\n      size: convertBytes(thisCategorySize)\n    };\n  }\n\n  const result: StoreSizeStatistics = {\n    totalSize,\n    categorizedSizes\n  };\n\n  return result;\n}\n","import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface RouteItem {\n  providerId: number;\n  providerName: string;\n  nameZh: string; // name in Chinese\n  nameEn: string; // name in English\n  aliasName: string; // another name in Chinese\n  pathAttributeId: number;\n  pathAttributeNId: string;\n  pathAttributeName: string; // another name in Chinese\n  pathAttributeEname: string; // another name in English\n  buildPeriod: '1' | '2' | '3' | '9' | '10';\n  departureZh: string; // departure stop name in Chinese\n  destinationZh: string; // destination stop name in Chinese\n  departureEn: string; // departure stop name in English\n  destinationEn: string; // destination stop name in English\n  goFirstBusTime: string; // time code (hhmm)\n  goLastBusTime: string;\n  backFirstBusTime: string;\n  backLastBusTime: string;\n  offPeakHeadway: string; // time code (hhmm or mm)\n  busTimeDesc: string;\n  roadMapUrl: string;\n  headwayDesc: string;\n  holidayGoFirstBusTime: string;\n  holidayBackFirstBusTime: string;\n  holidayBackLastBusTime: string;\n  holidayGoLastBusTime: string;\n  holidayBusTimeDesc: string;\n  realSequence: string; // number in string\n  holidayHeadwayDesc: string;\n  holidayOffPeakHeadway: string;\n  holidayPeakHeadway: string;\n  segmentBufferEn: string;\n  ticketPriceDescriptionZh: string;\n  ticketPriceDescriptionEn: string;\n  peakHeadway: string;\n  ttiaPathId: string;\n  segmentBufferZh: string;\n  distance: string;\n  NId: string;\n  Id: number; // RouteID\n  routeType: string;\n}\n\nexport type Route = Array<RouteItem>;\n\nexport interface SimplifiedRouteItem {\n  pd: number;\n  n: string;\n  pid: Array<number>;\n  dep: string;\n  des: string;\n  id: number;\n}\n\nexport type SimplifiedRoute = { [key: string]: SimplifiedRouteItem };\n\nlet RouteAPIVariableCache_available: boolean = false;\nlet RouteAPIVariableCache_data: object = {};\n\nasync function simplifyRoute(Route: Route): Promise<SimplifiedRoute> {\n  const worker = new Worker(new URL('./simplifyRoute-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(Route); // Send data to the worker\n  });\n\n  return result;\n}\n\nexport async function getRoute(requestID: string, simplify: boolean = true): Promise<SimplifiedRoute | Route> {\n  async function getData() {\n    const apis = [\n      [0, 10],\n      [1, 10]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getRoute_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n  if (simplify === false) {\n    return await getData();\n  }\n  const cacheTimeToLive = 60 * 60 * 24 * 1 * 1000;\n  const cacheKey = 'bus_route_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    const simplified_result = await simplifyRoute(result);\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(simplified_result));\n    if (!RouteAPIVariableCache_available) {\n      RouteAPIVariableCache_available = true;\n      RouteAPIVariableCache_data = simplified_result;\n    }\n    return simplified_result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      const simplified_result = await simplifyRoute(result);\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(simplified_result));\n      if (!RouteAPIVariableCache_available) {\n        RouteAPIVariableCache_available = true;\n        RouteAPIVariableCache_data = simplified_result;\n      }\n      return simplified_result;\n    } else {\n      if (!RouteAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        RouteAPIVariableCache_available = true;\n        RouteAPIVariableCache_data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getRoute_0', 0, true);\n      setDataReceivingProgress(requestID, 'getRoute_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return RouteAPIVariableCache_data;\n    }\n  }\n}\n","import { ParsedAddress } from '../../../tools/address';\nimport { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface LocationItem {\n  Id: number; // StopID\n  routeId: number; // RouteID\n  nameZh: string; // name in Chinese\n  nameEn: string; // name in English\n  seqNo: number; // sequence on the route\n  pgp: string; // pgp (-1: get off, 0: get on and off, 1: get on)\n  goBack: '0' | '1' | '2'; // GoBack (0: go, 1: back, 2: unknown)\n  longitude: string; // number in string\n  latitude: string; // number in string\n  address: string;\n  stopLocationId: number; // LocationID\n  showLon: string; // number in string\n  showLat: string; // number in string\n  vector: string;\n}\n\nexport type Location = Array<LocationItem>;\n\nexport interface SimplifiedLocationItem {\n  n: string; // name\n  lo: number; // longitude\n  la: number; // latitude\n  g: string; // geohash\n  r: Array<number>; // RouteIDs\n  s: Array<number>; // StopIDs\n  v: Array<[number, number]>; // a set of vectors\n  a: Array<string>; // addresses\n  id: number; // stopLocationId\n}\n\nexport type SimplifiedLocation = { [l_id: string]: SimplifiedLocationItem };\n\nexport interface MergedLocationItem {\n  n: string; // name\n  lo: Array<number>; // longitude\n  la: Array<number>; // latitude\n  g: Array<string>; // geohash\n  r: Array<Array<number>>; // RouteIDs\n  s: Array<Array<number>>; // StopIDs\n  v: Array<Array<[number, number]>>; // sets of vectors\n  a: Array<ParsedAddress>; // addresses\n  id: Array<number>; // stopLocationIds\n  hash: string;\n}\n\nexport type MergedLocation = { [ml_hash: string]: MergedLocationItem };\n\nexport interface IndexedLocationItem {\n  lo: number; // longitude\n  la: number; // latitude\n  hash: string;\n}\n\nexport type IndexedLocation = { [geohash: string]: Array<IndexedLocationItem> };\n\nconst LocationAPIVariableCache = {\n  simplified: {\n    available: false,\n    data: {}\n  },\n  merged: {\n    available: false,\n    data: {}\n  },\n  indexed: {\n    available: false,\n    data: {}\n  }\n};\n\nasync function simplifyLocation(Location: Location): Promise<SimplifiedLocation> {\n  const worker = new Worker(new URL('./simplifyLocation-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(Location); // Send data to the worker\n  });\n\n  return result;\n}\n\nasync function mergeLocationByName(object: SimplifiedLocation): Promise<MergedLocation> {\n  const worker = new Worker(new URL('./mergeLocationByName-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(object); // Send data to the worker\n  });\n\n  return result;\n}\n\nasync function indexLocationByGeohash(object: MergedLocation): Promise<IndexedLocation> {\n  const worker = new Worker(new URL('./indexLocationByGeohash-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(object); // Send data to the worker\n  });\n\n  return result;\n}\n\n/**\n * getLocation\n * @param requestID\n * @param type 0: simplified, 1: merged, 2: indexed\n * @returns SimplifiedLocation, MergedLocation, or IndexedLocation\n */\n\nexport async function getLocation(requestID: string, type: 0 | 1 | 2): Promise<SimplifiedLocation | MergedLocation | IndexedLocation> {\n  async function getData() {\n    const apis = [\n      [0, 11],\n      [1, 11]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getLocation_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 30 * 1000;\n  const cacheType = ['simplified', 'merged', 'indexed'][type];\n  const cacheKey = `bus_${cacheType}_location_cache`;\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    let finalResult;\n    switch (type) {\n      case 0: {\n        const result = await getData();\n        const simplified_result = await simplifyLocation(result);\n        finalResult = simplified_result;\n        break;\n      }\n      case 1: {\n        const simplified_result = await getLocation(requestID, 0);\n        const merged_result = await mergeLocationByName(simplified_result);\n        finalResult = merged_result;\n        break;\n      }\n      case 2: {\n        const merged_result = await getLocation(requestID, 1);\n        const indexed_result = await indexLocationByGeohash(merged_result);\n        finalResult = indexed_result;\n        break;\n      }\n      default:\n        break;\n    }\n\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(finalResult));\n    if (!LocationAPIVariableCache[cacheType].available) {\n      LocationAPIVariableCache[cacheType].available = true;\n      LocationAPIVariableCache[cacheType].data = finalResult;\n    }\n    return finalResult;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      let finalResult;\n      switch (type) {\n        case 0: {\n          const result = await getData();\n          const simplified_result = await simplifyLocation(result);\n          finalResult = simplified_result;\n          break;\n        }\n        case 1: {\n          const simplified_result = await getLocation(requestID, 0);\n          const merged_result = await mergeLocationByName(simplified_result);\n          finalResult = merged_result;\n          break;\n        }\n        case 2: {\n          const merged_result = await getLocation(requestID, 1);\n          const indexed_result = await indexLocationByGeohash(merged_result);\n          finalResult = indexed_result;\n          break;\n        }\n        default:\n          break;\n      }\n\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(finalResult));\n      if (!LocationAPIVariableCache[cacheType].available) {\n        LocationAPIVariableCache[cacheType].available = true;\n        LocationAPIVariableCache[cacheType].data = finalResult;\n      }\n      return finalResult;\n    } else {\n      if (!LocationAPIVariableCache[cacheType].available) {\n        const cache = await lfGetItem(0, cacheKey);\n        LocationAPIVariableCache[cacheType].available = true;\n        LocationAPIVariableCache[cacheType].data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getLocation_0', 0, true);\n      setDataReceivingProgress(requestID, 'getLocation_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return LocationAPIVariableCache[cacheType].data;\n    }\n  }\n}\n","import { MaterialSymbols } from '../../../interface/icons/material-symbols-type';\nimport { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getMaterialSymbolsAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress } from '../loader';\n\nlet MaterialSymbolsAPIVariableCache_available: boolean = false;\nlet MaterialSymbolsAPIVariableCache_data: Array<string> = [];\n\nexport interface MaterialSymbolsSearchIndex {\n  dictionary: string;\n  symbols: { [symbol: MaterialSymbols]: Array<number> };\n}\n\nexport async function getMaterialSymbolsSearchIndex(requestID: string): Promise<MaterialSymbolsSearchIndex> {\n  async function getData() {\n    const apiurl = getMaterialSymbolsAPIURL();\n    const data = await fetchData(apiurl, requestID, 'getMaterialSymbolsSearchIndex', 'json');\n    return data;\n  }\n\n  const cacheTimeToLive = 60 * 60 * 24 * 7 * 1000;\n  const cacheKey = 'bus_material_symbols_search_index_cache';\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(result));\n    if (!MaterialSymbolsAPIVariableCache_available) {\n      MaterialSymbolsAPIVariableCache_available = true;\n      MaterialSymbolsAPIVariableCache_data = result;\n    }\n    return result;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(result));\n      if (!MaterialSymbolsAPIVariableCache_available) {\n        MaterialSymbolsAPIVariableCache_available = true;\n        MaterialSymbolsAPIVariableCache_data = result;\n      }\n      return result;\n    } else {\n      if (!MaterialSymbolsAPIVariableCache_available) {\n        const cache = await lfGetItem(0, cacheKey);\n        MaterialSymbolsAPIVariableCache_available = true;\n        MaterialSymbolsAPIVariableCache_data = JSON.parse(cache)\n      }\n      setDataReceivingProgress(requestID, 'getMaterialSymbolsSearchIndex', 0, true);\n      return MaterialSymbolsAPIVariableCache_data;\n    }\n  }\n}\n","import { lfGetItem, lfSetItem } from '../../storage/index';\nimport { getAPIURL } from '../getAPIURL/index';\nimport { fetchData, setDataReceivingProgress, setDataUpdateTime } from '../loader';\n\nexport interface CarInfoItem {\n  BusId: number; // BusId ≠ BusID\n  BusNId: string;\n  CarNum: string; // CarNumber = BusID = vehicle registration number\n  CarType: '0' | '1' | '2' | '3'; // 0: normal bus (一般), 1: low-floor bus (低底盤), 2: disability-friendly bus (大復康巴士), 3: dog-friendly bus (狗狗友善專車)\n  IboxId: number;\n  StationId: number;\n  PathAttributeId: number;\n  BuildPeriod: string;\n  Ctime: string;\n}\n\nexport type CarInfo = Array<CarInfoItem>;\n\nexport interface SimplifiedCarInfoItem {\n  BusId: CarInfoItem['BusId'];\n  CarNum: CarInfoItem['CarNum'];\n  CarType: CarInfoItem['CarType'];\n  PathAttributeId: CarInfoItem['PathAttributeId'];\n}\n\nexport type SimplifiedCarInfo = { [key: string]: SimplifiedCarInfoItem };\n\nconst CarInfoAPIVariableCache = {\n  raw: {\n    data: [],\n    available: false\n  },\n  simplified: {\n    data: {},\n    available: false\n  }\n};\n\nasync function simplifyCarInfo(CarInfo: CarInfo): Promise<SimplifiedCarInfo> {\n  const worker = new Worker(new URL('./simplifyCarInfo-worker.ts', import.meta.url));\n\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n\n    worker.postMessage(CarInfo); // Send data to the worker\n  });\n\n  return result;\n}\n\nexport async function getCarInfo(requestID: string, simplified: boolean = false): Promise<CarInfo | SimplifiedCarInfo> {\n  async function getData() {\n    const apis = [\n      [0, 2],\n      [1, 2]\n    ].map((e) => ({ url: getAPIURL(e[0], e[1]), e: e }));\n    let result = [];\n    for (const api of apis) {\n      const data = await fetchData(api.url, requestID, `getCarInfo_${api.e[0]}`, 'json');\n      result = result.concat(data.BusInfo);\n      setDataUpdateTime(requestID, data.EssentialInfo.UpdateTime);\n    }\n    return result;\n  }\n\n  const cacheType = simplified ? 'simplified' : 'raw';\n  const cacheKey = `bus_${cacheType}_car_info_cache`;\n  const cacheTimeToLive = 60 * 60 * 24 * 30 * 1000;\n  const cacheTimestamp = await lfGetItem(0, `${cacheKey}_timestamp`);\n  if (cacheTimestamp === null) {\n    const result = await getData();\n    let finalResult;\n    if (simplified) {\n      finalResult = await simplifyCarInfo(result);\n    } else {\n      finalResult = result;\n    }\n    await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n    await lfSetItem(0, cacheKey, JSON.stringify(finalResult));\n    if (!CarInfoAPIVariableCache[cacheType].available) {\n      CarInfoAPIVariableCache[cacheType].available = true;\n      CarInfoAPIVariableCache[cacheType].data = finalResult;\n    }\n    return finalResult;\n  } else {\n    if (new Date().getTime() - parseInt(cacheTimestamp) > cacheTimeToLive) {\n      const result = await getData();\n      let finalResult;\n      if (simplified) {\n        finalResult = await simplifyCarInfo(result);\n      } else {\n        finalResult = result;\n      }\n      await lfSetItem(0, `${cacheKey}_timestamp`, new Date().getTime());\n      await lfSetItem(0, cacheKey, JSON.stringify(finalResult));\n      return finalResult;\n    } else {\n      if (!CarInfoAPIVariableCache[cacheType].available) {\n        const cache = await lfGetItem(0, cacheKey);\n        CarInfoAPIVariableCache[cacheType].available = true;\n        CarInfoAPIVariableCache[cacheType].data = JSON.parse(cache);\n      }\n      setDataReceivingProgress(requestID, 'getCarInfo_0', 0, true);\n      setDataReceivingProgress(requestID, 'getCarInfo_1', 0, true);\n      setDataUpdateTime(requestID, -1);\n      return CarInfoAPIVariableCache[cacheType].data;\n    }\n  }\n}\n"],"names":["ProviderAPIVariableCache_available","ProviderAPIVariableCache_data","getProvider","_x","_getProvider","apply","arguments","_asyncToGenerator","requestID","getData","_getData","_step","result","_iterator","_createForOfIteratorHelper","map","e","url","getAPIURL","s","n","done","api","value","data","fetchData","concat","BusInfo","setDataUpdateTime","EssentialInfo","UpdateTime","err","f","cacheKey","cacheTimestamp","lfGetItem","lfSetItem","Date","getTime","JSON","stringify","parseInt","cache","parse","setDataReceivingProgress","getEstimateTime","_getEstimateTime","city","alternative","length","undefined","interval","cities","buckets","proxy","getSettingOptionValue","getNoCacheParameter","getMaterialSymbolsAPIURL","storeIndexToCategory","store","_ref2","_slicedToArray","name","key","getStoresSizeStatistics","_getStoresSizeStatistics","totalSizeInBytes","categorizedSizesInBytes","storesLength","getStoresLength","i","thisStoreSizeInBytes","lfListItemKeys","itemKey","item","itemLength","String","thisCategory","thisCategoryKey","hasOwnProperty","category","size","totalSize","convertBytes","categorizedSizes","thisCategorySize","RouteAPIVariableCache_available","RouteAPIVariableCache_data","simplifyRoute","_simplifyRoute","Route","worker","Worker","URL","Promise","resolve","reject","onmessage","terminate","onerror","message","postMessage","getRoute","_x2","_getRoute","simplified_result","LocationAPIVariableCache","simplified","available","merged","indexed","simplifyLocation","_simplifyLocation","Location","mergeLocationByName","_mergeLocationByName","object","indexLocationByGeohash","_x3","_indexLocationByGeohash","getLocation","_x4","_x5","_getLocation","type","cacheType","finalResult","merged_result","MaterialSymbolsAPIVariableCache_available","MaterialSymbolsAPIVariableCache_data","getMaterialSymbolsSearchIndex","_getMaterialSymbolsSearchIndex","apiurl","CarInfoAPIVariableCache","raw","simplifyCarInfo","_simplifyCarInfo","CarInfo","getCarInfo","_getCarInfo"],"ignoreList":[],"sourceRoot":""}