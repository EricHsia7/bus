{"version":3,"file":"5850a92051138389042c.js","mappings":"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","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/./src/tools/math.ts","webpack://bus/./src/data/apis/getLocation/simplifyLocation-worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\nexport function convertToUnitVector(vector: Array<number>): Array<number> {\n  let length = Math.hypot(vector);\n  let newVector = [];\n  if (length > 0) {\n    let scale = 1 / length;\n    for (const x of vector) {\n      newVector.push(x * scale);\n    }\n    return newVector;\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  let result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function findExtremum(array: Array<number>): [number, number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n","import { convertToUnitVector } from '../../../tools/math';\nimport { Location, SimplifiedLocation, SimplifiedLocationItem } from './index';\n\nself.onmessage = function (e) {\n  const result = processWorkerTask(e.data);\n  self.postMessage(result); // Send the result back to the main thread\n};\n\nfunction processWorkerTask(Location: Location): SimplifiedLocation {\n  let locationsByRoute = {};\n  for (const item of Location) {\n    const thisRouteID = item.routeId;\n    const thisRouteKey = `r_${thisRouteID}`;\n    if (!locationsByRoute.hasOwnProperty(thisRouteKey)) {\n      locationsByRoute[thisRouteKey] = [];\n    }\n    locationsByRoute[thisRouteKey].push(item);\n  }\n  for (const key in locationsByRoute) {\n    locationsByRoute[key] = locationsByRoute[key].sort(function (a, b) {\n      return a.seqNo - b.seqNo;\n    });\n  }\n  let result: SimplifiedLocation = {};\n  for (const item of Location) {\n    let vector = [0, 0];\n    const locationsOnThisRoute = locationsByRoute[`r_${item.routeId}`];\n    const locationsOnThisRouteLength = locationsOnThisRoute.length;\n    let nextLocation = null;\n    for (let i = 0; i < locationsOnThisRouteLength; i++) {\n      if (locationsOnThisRoute[i].Id === item.Id) {\n        let nextIndex = 0;\n        if (i < locationsOnThisRouteLength - 1) {\n          nextIndex = i + 1;\n        }\n        nextLocation = locationsOnThisRoute[nextIndex];\n      }\n    }\n    if (nextLocation) {\n      const x = parseFloat(nextLocation.longitude) - parseFloat(item.longitude);\n      const y = parseFloat(nextLocation.latitude) - parseFloat(item.latitude);\n      vector = convertToUnitVector([x, y]);\n    }\n\n    const key = `l_${item.stopLocationId}`;\n    if (!result.hasOwnProperty(key)) {\n      let simplifiedItem = {} as SimplifiedLocationItem;\n      simplifiedItem.n = item.nameZh;\n      simplifiedItem.lo = parseFloat(item.longitude);\n      simplifiedItem.la = parseFloat(item.latitude);\n      simplifiedItem.r = [item.routeId];\n      simplifiedItem.s = [item.Id];\n      simplifiedItem.v = [vector];\n      simplifiedItem.a = [item.address];\n      result[key] = simplifiedItem;\n    } else {\n      if (!(result[key].r.indexOf(item.routeId) > -1)) {\n        result[key].r.push(item.routeId);\n      }\n      if (!(result[key].s.indexOf(item.Id) > -1)) {\n        result[key].s.push(item.Id);\n        result[key].v.push(vector);\n      }\n      result[key].a.push(item.address);\n    }\n  }\n  return result;\n}\n"],"names":["root","factory","exports","module","define","amd","self","convertToUnitVector","vector","length","Math","hypot","newVector","_step","scale","_iterator","_createForOfIteratorHelper","s","n","done","x","value","push","err","e","f","onmessage","result","Location","locationsByRoute","item","thisRouteKey","routeId","hasOwnProperty","key","sort","a","b","seqNo","_step2","_iterator2","locationsOnThisRoute","locationsOnThisRouteLength","nextLocation","i","Id","nextIndex","parseFloat","longitude","latitude","stopLocationId","r","indexOf","v","address","simplifiedItem","nameZh","lo","la","processWorkerTask","data","postMessage"],"sourceRoot":""}