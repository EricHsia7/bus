{"version":3,"file":"85b6f1d08fef86ed281c.js","mappings":"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","sources":["webpack://bus/./src/data/folder/index.ts"],"sourcesContent":["import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { generateLabelFromAddresses } from '../../tools/address';\nimport { CardinalDirection, getCardinalDirectionFromVector } from '../../tools/cardinal-direction';\nimport { generateIdentifier } from '../../tools/index';\nimport { generateDirectionLabels, generateLetterLabels } from '../../tools/labels';\nimport { normalizeVector } from '../../tools/math';\nimport { collectBusArrivalTimeData } from '../analytics/bus-arrival-time/index';\nimport { collectUpdateRateData } from '../analytics/update-rate/index';\nimport { EstimateTimeItem, getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, MergedLocation, MergedLocationItem, SimplifiedLocation } from '../apis/getLocation/index';\nimport { getMaterialSymbolsSearchIndex } from '../apis/getMaterialSymbolsSearchIndex/index';\nimport { getRoute, SimplifiedRoute, SimplifiedRouteItem } from '../apis/getRoute/index';\nimport { getStop, SimplifiedStop } from '../apis/getStop/index';\nimport { EstimateTimeStatus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue, SettingSelectOptionRefreshIntervalValue } from '../settings/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\n\ninterface FolderContentRouteEndPoints {\n  departure: string;\n  destination: string;\n}\n\nexport interface FolderContentStopRoute {\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n  id: number;\n}\n\nexport interface FolderContentStop {\n  type: 'stop';\n  id: number;\n  timestamp: number;\n  name: string;\n  direction: number;\n  route: FolderContentStopRoute;\n}\n\nexport interface FolderContentRoute {\n  type: 'route';\n  id: number;\n  timestamp: number;\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n}\n\nexport interface FolderContentLocation {\n  type: 'location';\n  id: string; // hash\n  timestamp: number;\n  name: string;\n}\n\nexport interface FolderContentBus {\n  type: 'bus';\n  id: number; // CarID\n  timestamp: number;\n  busID: string; // BusID\n}\n\nexport interface FolderContentEmpty {\n  type: 'empty';\n  id: number;\n}\n\nexport type FolderContent = FolderContentStop | FolderContentRoute | FolderContentLocation | FolderContentBus | FolderContentEmpty;\n\nexport interface Folder {\n  name: string;\n  icon: MaterialSymbols;\n  id: string;\n  timestamp: number;\n}\n\nexport type FolderArray = Array<Folder>;\n\nexport interface FolderWithContent extends Folder {\n  content: Array<FolderContent>;\n  contentLength: number;\n}\n\nexport type FolderWithContentArray = Array<FolderWithContent>;\n\nconst FolderList: { [key: string]: Folder } = {};\n\nexport async function initializeFolderList() {\n  const folderKeys = await lfListItemKeys(11);\n  for (const folderKey of folderKeys) {\n    const thisFolderJSON = await lfGetItem(11, folderKey);\n    if (thisFolderJSON) {\n      const thisFolderObject = JSON.parse(thisFolderJSON) as Folder;\n      if (!FolderList.hasOwnProperty(folderKey)) {\n        FolderList[folderKey] = thisFolderObject;\n      }\n    }\n  }\n}\n\nexport async function createFolder(name: Folder['name'], icon: Folder['icon']): Promise<Folder['id'] | false> {\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!materialSymbolsSearchIndex.symbols.hasOwnProperty(icon)) return false;\n\n  // Check existence\n  const folderID = generateIdentifier();\n  const folderKey = `f_${folderID}`;\n  if (FolderList.hasOwnProperty(folderKey)) {\n    return false;\n  }\n  const existingFolder = await lfGetItem(11, folderKey);\n  if (existingFolder) {\n    return false;\n  }\n\n  // Generate folder\n  const nowTime = new Date().getTime();\n  let newFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: nowTime\n  };\n\n  // Save folder\n  FolderList[folderKey] = newFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(newFolder));\n  await lfSetItem(12, folderKey, JSON.stringify([]));\n  return folderID;\n}\n\nexport async function updateFolder(folderID: Folder['id'], name: Folder['name'], icon: Folder['icon']): Promise<boolean> {\n  const folderKey: string = `f_${folderID}`;\n\n  // Check existence\n  const existingFolderJSON = await lfGetItem(11, folderKey);\n  if (!existingFolderJSON) {\n    return false;\n  }\n  const existingFolderObject = JSON.parse(existingFolderJSON) as Folder;\n\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!materialSymbolsSearchIndex.symbols.hasOwnProperty(icon)) return false;\n\n  // Generate folder\n  const modifiedFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: existingFolderObject.timestamp\n  };\n\n  // Save folder\n  FolderList[folderKey] = modifiedFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(modifiedFolder));\n  return true;\n}\n\nexport function getFolder(folderID: Folder['id']): Folder | false {\n  const folderKey: string = `f_${folderID}`;\n  if (!FolderList.hasOwnProperty(folderKey)) {\n    return false;\n  }\n  const folderObject: Folder = {\n    name: FolderList[folderKey].name,\n    icon: FolderList[folderKey].icon,\n    id: FolderList[folderKey].id,\n    timestamp: FolderList[folderKey].timestamp\n  };\n  return folderObject;\n  // return cloneDeep(Folders[folderKey]);\n}\n\nexport function listFolders(): FolderArray {\n  const result = [];\n  for (const folderKey in FolderList) {\n    const folderObject: Folder = {\n      name: FolderList[folderKey].name,\n      icon: FolderList[folderKey].icon,\n      id: FolderList[folderKey].id,\n      timestamp: FolderList[folderKey].timestamp\n    };\n    result.push(folderObject);\n  }\n  result.sort(function (a, b) {\n    return a.timestamp - b.timestamp;\n  });\n  return result;\n}\n\nexport async function listFolderContent(folderID: Folder['id']): Promise<Array<FolderContent>> {\n  const result: Array<FolderContent> = [];\n\n  const folderKey: string = `f_${folderID}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return result;\n  }\n\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return result;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0) {\n    const emptyItem: FolderContentEmpty = {\n      type: 'empty',\n      id: 0,\n      index: 0\n    };\n    result.push(emptyItem);\n    return result;\n  }\n\n  for (const thisFolderContentKey of thisFolderContentIndexArray) {\n    const thisContentJSON = await lfGetItem(13, thisFolderContentKey);\n    if (thisContentJSON) {\n      const thisContentObject = JSON.parse(thisContentJSON) as FolderContent;\n      result.push(thisContentObject);\n    }\n  }\n  return result;\n}\n\nasync function getFolderContentLength(folderID: Folder['id']): Promise<number> {\n  const folderKey: string = `f_${folderID}`;\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return 0;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  return thisFolderContentIndexArray.length;\n}\n\nexport async function listFoldersWithContent(): Promise<FolderWithContentArray> {\n  const folders = await listFolders();\n  const result: FolderWithContentArray = [];\n  for (const folder of folders) {\n    const folderContent = await listFolderContent(folder.id);\n    const folderContentLength = await getFolderContentLength(folder.id);\n    result.push({\n      name: folder.name,\n      icon: folder.icon,\n      id: folder.id,\n      timestamp: folder.timestamp,\n      content: folderContent,\n      contentLength: folderContentLength\n    });\n  }\n  return result;\n}\n\nexport async function listAllFolderContent(types: Array<FolderContent['type']>): Promise<Array<FolderContent>> {\n  let useFilter: boolean = true;\n  if (typeof types !== 'object' || !Array.isArray(types)) {\n    useFilter = false;\n  }\n  let result: Array<FolderContent> = [];\n  const keys = await lfListItemKeys(13);\n  for (const key of keys) {\n    const json = await lfGetItem(13, key);\n    if (json) {\n      const object = JSON.parse(json) as FolderContent;\n      if (useFilter) {\n        if (types.indexOf(object.type) > -1) {\n          result.push(object);\n        }\n      } else {\n        result.push(object);\n      }\n    }\n  }\n  return result;\n}\n\nexport interface integratedFolderContentStopRoute extends FolderContentStopRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentStop extends FolderContentStop {\n  status: EstimateTimeStatus;\n  route: integratedFolderContentStopRoute;\n}\n\nexport interface integratedFolderContentRoute extends FolderContentRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentLocation extends FolderContentLocation {\n  // labels: string;\n}\n\nexport interface integratedFolderContentBus extends FolderContentBus {}\n\nexport interface integratedFolderContentEmpty extends FolderContentEmpty {}\n\nexport type integratedFolderContent = integratedFolderContentStop | integratedFolderContentRoute | integratedFolderContentLocation | integratedFolderContentBus | integratedFolderContentEmpty;\n\nexport interface integratedFolder extends Folder {\n  content: Array<integratedFolderContent>;\n  contentLength: number;\n}\n\nexport interface integratedFolders {\n  folders: Array<integratedFolder>;\n  dataUpdateTime: number;\n}\n\nexport async function integrateFolders(requestID: string): Promise<integratedFolders> {\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n\n  const EstimateTime = await getEstimateTime(requestID);\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  // const Location = (await getLocation(requestID, 1)) as MergedLocation;\n\n  const foldersWithContent = await listFoldersWithContent();\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode') as number;\n  // const location_labels = getSettingOptionValue('location_labels');\n  const power_saving = getSettingOptionValue('power_saving') as boolean;\n  const refresh_interval_setting = getSettingOptionValue('refresh_interval') as SettingSelectOptionRefreshIntervalValue;\n\n  let StopIDs = [] as Array<number>;\n  for (const folderWithContent1 of foldersWithContent) {\n    StopIDs = StopIDs.concat(\n      folderWithContent1.content\n        .filter((m) => {\n          return m.type === 'stop' ? true : false;\n        })\n        .map((e) => e.id)\n    );\n  }\n\n  let batchFoundEstimateTime: { [key: string]: EstimateTimeItem } = {};\n  for (const EstimateTimeItem of EstimateTime) {\n    if (StopIDs.indexOf(EstimateTimeItem.StopID) > -1) {\n      const thisStopKey: string = `s_${EstimateTimeItem.StopID}`;\n      batchFoundEstimateTime[thisStopKey] = EstimateTimeItem;\n    }\n  }\n\n  let folders: integratedFolders['folders'] = [];\n\n  for (const folderWithContent2 of foldersWithContent) {\n    // Initialize integratedFolder\n    const integratedFolder: integratedFolder = {\n      name: folderWithContent2.name,\n      icon: folderWithContent2.icon,\n      id: folderWithContent2.id,\n      timestamp: folderWithContent2.timestamp,\n      content: [],\n      contentLength: folderWithContent2.contentLength\n    };\n\n    for (let item of folderWithContent2.content) {\n      let integratedItem = item as integratedFolderContent;\n      switch (integratedItem.type) {\n        case 'stop': {\n          const thisStopKey = `s_${integratedItem.id}`;\n          let thisEstimateTime = {} as EstimateTimeItem;\n          if (batchFoundEstimateTime.hasOwnProperty(thisStopKey)) {\n            thisEstimateTime = batchFoundEstimateTime[thisStopKey];\n          } else {\n            break;\n          }\n          integratedItem.status = parseEstimateTime(thisEstimateTime.EstimateTime, time_formatting_mode);\n          const thisRouteKey = `r_${integratedItem.route.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.route.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'route': {\n          const thisRouteKey = `r_${integratedItem.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'location': {\n          /*\n          const thisLocationKey = `ml_${integratedItem.id}`;\n          const thisLocation = Location[thisLocationKey] as MergedLocationItem;\n          let labels: Array<string> = [];\n          switch (location_labels) {\n            case 'address':\n              labels = generateLabelFromAddresses(thisLocation.a);\n              break;\n            case 'letters':\n              const stopLocationIds = thisLocation.id;\n              const stopLocationQuantity = stopLocationIds.length;\n              labels = generateLetterLabels(stopLocationQuantity);\n              break;\n            case 'directions':\n              const setsOfVectors = thisLocation.v;\n              const cardinalDirections: Array<CardinalDirection> = [];\n              for (const vectorSet of setsOfVectors) {\n                let x: number = 0;\n                let y: number = 0;\n                for (const vector of vectorSet) {\n                  x += vector[0];\n                  y += vector[1];\n                }\n                const meanVector = normalizeVector([x, y]) as [number, number];\n                const cardinalDirection = getCardinalDirectionFromVector(meanVector);\n                cardinalDirections.push(cardinalDirection);\n              }\n\n              labels = generateDirectionLabels(cardinalDirections);\n              break;\n            default:\n              break;\n          }\n          integratedItem.labels = labels.join(' - ');\n          */\n          break;\n        }\n        case 'bus':\n          break;\n        case 'empty':\n          break;\n        default:\n          break;\n      }\n      integratedFolder.content.push(integratedItem);\n    }\n    folders.push(integratedFolder);\n  }\n\n  const result: integratedFolders = {\n    folders: folders,\n    dataUpdateTime: getDataUpdateTime(requestID)\n  };\n\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n\n  if (!power_saving) {\n    if (refresh_interval_setting.dynamic) {\n      await collectUpdateRateData(EstimateTime);\n    }\n    await collectBusArrivalTimeData(EstimateTime);\n  }\n\n  return result;\n}\n\nexport async function saveToFolder(folderID: Folder['id'], content: FolderContent): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const contentKey = `${content.type}_${content.id}`;\n  const thisFolder = getFolder(folderID);\n\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0 || thisFolderContentIndexArray.indexOf(contentKey) < 0) {\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray.concat(contentKey)));\n    await lfSetItem(13, contentKey, JSON.stringify(content));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport async function isFolderContentSaved(type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderContentKeyToCheck = `${type}_${id}`;\n\n  const keys = await lfListItemKeys(12);\n  for (const key of keys) {\n    const thisFolderContentIndexJSON = (await lfGetItem(12, key)) as string;\n    if (!thisFolderContentIndexJSON) {\n      continue;\n    }\n    const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n    if (thisFolderContentIndexArray.indexOf(folderContentKeyToCheck) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport async function removeFromFolder(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n\n  // Check existence\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  // Remove reference from folder content index\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 0) {\n    thisFolderContentIndexArray.splice(index, 1);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n  }\n\n  // Remove content if there are no other references\n  const isSaved = await isFolderContentSaved(type, id);\n  if (isSaved === false) {\n    await lfRemoveItem(13, thisFolderContentKey);\n  }\n  return true;\n}\n\nexport async function saveStop(folderID: Folder['id'], StopID: number, RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Stop = (await getStop(requestID)) as SimplifiedStop;\n  const Location = (await getLocation(requestID, 0)) as SimplifiedLocation;\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n\n  const thisStop = Stop[`s_${StopID}`];\n  const thisStopDirection: number = parseInt(thisStop.goBack);\n  const thisLocation = Location[`l_${thisStop.stopLocationId}`];\n  const thisStopName: string = thisLocation.n;\n\n  const thisRoute = Route[`r_${RouteID}`];\n  const thisRouteName: string = thisRoute.n;\n  const thisRouteDeparture: string = thisRoute.dep;\n  const thisRouteDestination: string = thisRoute.des;\n\n  const newContent: FolderContentStop = {\n    type: 'stop',\n    id: StopID,\n    timestamp: new Date().getTime(),\n    name: thisStopName,\n    direction: thisStopDirection,\n    route: {\n      name: thisRouteName,\n      endPoints: {\n        departure: thisRouteDeparture,\n        destination: thisRouteDestination\n      },\n      id: RouteID\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveRoute(folderID: Folder['id'], RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisRouteKey = `r_${RouteID}`;\n  let thisRoute = {} as SimplifiedRouteItem;\n  if (Route.hasOwnProperty(thisRouteKey)) {\n    thisRoute = Route[thisRouteKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentRoute = {\n    type: 'route',\n    id: RouteID,\n    timestamp: new Date().getTime(),\n    name: thisRoute.n,\n    endPoints: {\n      departure: thisRoute.dep,\n      destination: thisRoute.des\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveLocation(folderID: Folder['id'], hash: string): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisLocationKey = `ml_${hash}`;\n  let thisLocation = {} as MergedLocationItem;\n  if (Location.hasOwnProperty(thisLocationKey)) {\n    thisLocation = Location[thisLocationKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentLocation = {\n    type: 'location',\n    id: hash,\n    timestamp: new Date().getTime(),\n    name: thisLocation.n\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\n// TODO: Save Bus\n\nexport async function updateFolderContentIndex(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id'], direction: 'up' | 'down'): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 1) {\n    let offset: number = 0;\n    switch (direction) {\n      case 'up':\n        offset = -1;\n        break;\n      case 'down':\n        offset = 1;\n        break;\n      default:\n        offset = 0;\n        break;\n    }\n    thisFolderContentIndexArray.splice(index, 1);\n    thisFolderContentIndexArray.splice(index + offset, 0, thisFolderContentKey);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n    return true;\n  } else {\n    return false;\n  }\n}\n"],"names":["FolderList","createFolder","_x","_x2","_createFolder","apply","arguments","_asyncToGenerator","name","icon","requestID","generateIdentifier","materialSymbolsSearchIndex","getMaterialSymbolsSearchIndex","deleteDataReceivingProgress","symbols","hasOwnProperty","folderID","folderKey","lfGetItem","newFolder","id","timestamp","Date","getTime","lfSetItem","JSON","stringify","updateFolder","_x3","_x4","_x5","_updateFolder","existingFolderJSON","existingFolderObject","parse","modifiedFolder","getFolder","listFolderContent","_x6","_listFolderContent","result","thisFolder","thisFolderContentIndexJSON","thisFolderContentIndexArray","length","push","type","index","_step2","_iterator2","_createForOfIteratorHelper","s","n","done","thisFolderContentKey","value","thisContentJSON","thisContentObject","err","e","f","getFolderContentLength","_x7","_getFolderContentLength","listFoldersWithContent","_listFoldersWithContent","_step3","folders","folderObject","sort","a","b","listFolders","_iterator3","folder","folderContent","folderContentLength","content","contentLength","saveToFolder","_x0","_x1","_saveToFolder","contentKey","indexOf","concat","isFolderContentSaved","_x10","_x11","_isFolderContentSaved","_step9","folderContentKeyToCheck","_iterator9","lfListItemKeys","key","removeFromFolder","_x12","_x13","_x14","_removeFromFolder","splice","lfRemoveItem","saveStop","_x15","_x16","_x17","_saveStop","StopID","RouteID","Stop","getStop","Location","getLocation","Route","getRoute","thisStop","thisStopDirection","parseInt","goBack","thisStopName","stopLocationId","thisRoute","thisRouteName","thisRouteDeparture","dep","thisRouteDestination","des","newContent","direction","route","endPoints","departure","destination","saveRoute","_x18","_x19","_saveRoute","deleteDataUpdateTime","thisRouteKey","saveLocation","_x20","_x21","_saveLocation","hash","thisLocationKey","thisLocation","updateFolderContentIndex","_x22","_x23","_x24","_x25","_updateFolderContentIndex","offset"],"ignoreList":[],"sourceRoot":""}