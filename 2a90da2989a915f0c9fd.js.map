{"version":3,"file":"2a90da2989a915f0c9fd.js","mappings":"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","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/webpack/runtime/chunk loaded","webpack://bus/webpack/runtime/startup chunk dependencies","webpack://bus/./src/tools/path.ts","webpack://bus/./src/tools/time.ts","webpack://bus/./src/data/storage/index.ts","webpack://bus/./src/data/analytics/data-usage/getDataUsageStats-worker.ts","webpack://bus/./src/tools/math.ts","webpack://bus/webpack/bootstrap","webpack://bus/webpack/runtime/ensure chunk","webpack://bus/webpack/runtime/get javascript chunk filename","webpack://bus/webpack/runtime/get mini-css chunk filename","webpack://bus/webpack/runtime/global","webpack://bus/webpack/runtime/hasOwnProperty shorthand","webpack://bus/webpack/runtime/publicPath","webpack://bus/webpack/runtime/importScripts chunk loading","webpack://bus/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(790).then(next);\n};","export interface Segment {\n  x: number;\n  y: number;\n}\n\nexport type Segments = Array<Segment>;\n\nfunction distanceToSegment(point: Segment, start: Segment, end: Segment): number {\n  let dx = end.x - start.x;\n  let dy = end.y - start.y;\n  const d = dx * dx + dy * dy;\n  const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;\n\n  if (t < 0) {\n    dx = point.x - start.x;\n    dy = point.y - start.y;\n  } else if (t > 1) {\n    dx = point.x - end.x;\n    dy = point.y - end.y;\n  } else {\n    const closestPoint = { x: start.x + t * dx, y: start.y + t * dy };\n    dx = point.x - closestPoint.x;\n    dy = point.y - closestPoint.y;\n  }\n\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function simplifyPath(points: Segments, tolerance: number): Segments {\n  if (points.length < 3) {\n    return points;\n  }\n\n  let dmax = 0;\n  let index = 0;\n\n  // Find the point with the maximum distance\n  for (let i = 1; i < points.length - 1; i++) {\n    const d = distanceToSegment(points[i], points[0], points[points.length - 1]);\n    if (d > dmax) {\n      index = i;\n      dmax = d;\n    }\n  }\n\n  // If max distance is greater than tolerance, split the curve\n  if (dmax > tolerance) {\n    const leftPoints = points.slice(0, index + 1);\n    const rightPoints = points.slice(index);\n    const simplifiedLeft = simplifyPath(leftPoints, tolerance);\n    const simplifiedRight = simplifyPath(rightPoints, tolerance);\n    return simplifiedLeft.slice(0, simplifiedLeft.length - 1).concat(simplifiedRight);\n  } else {\n    return [points[0], points[points.length - 1]];\n  }\n}\n\nexport function segmentsToPath(segments: Segments, scale: number): string {\n  if (segments.length < 1) {\n    return '';\n  }\n  let pathCommand = `M${segments[0].x * scale} ${segments[0].y * scale}`;\n  const segmentsLength1 = segments.length - 1;\n  for (let i = 1; i < segmentsLength1; i++) {\n    const current = segments[i];\n    const next = segments[i + 1] || current;\n\n    pathCommand += `Q${current.x * scale} ${current.y * scale} ${(current.x * scale + next.x * scale) / 2} ${(current.y * scale + next.y * scale) / 2}`;\n  }\n  const lastPoint = segments[segmentsLength1];\n  pathCommand += `L${lastPoint.x * scale},${lastPoint.y * scale}`;\n  return pathCommand;\n}\n","export function getThisWeekOrigin(): Date {\n  const today: Date = new Date();\n  const dayOfToday: number = today.getDay();\n  const originDate: number = today.getDate() - dayOfToday;\n  const origin: Date = new Date();\n  origin.setDate(originDate);\n  origin.setHours(0);\n  origin.setMinutes(0);\n  origin.setSeconds(0);\n  origin.setMilliseconds(0);\n  return origin;\n}\n\nexport function offsetDate(origin: Date, date: number, hours: number, minutes: number): Date {\n  const duplicatedOrigin = new Date();\n  duplicatedOrigin.setDate(1);\n  duplicatedOrigin.setMonth(0);\n  duplicatedOrigin.setHours(hours);\n  duplicatedOrigin.setMinutes(minutes);\n  duplicatedOrigin.setSeconds(0);\n  duplicatedOrigin.setMilliseconds(0);\n  duplicatedOrigin.setFullYear(origin.getFullYear());\n  duplicatedOrigin.setMonth(origin.getMonth());\n  duplicatedOrigin.setDate(origin.getDate());\n  duplicatedOrigin.setDate(duplicatedOrigin.getDate() + date);\n  return duplicatedOrigin;\n}\n\nexport function timeStampToNumber(string: string): number {\n  const regex = /[0-9\\.]*/gm;\n  const match = string.match(regex);\n  if (match) {\n    const year = parseInt(match[0]);\n    const month = parseInt(match[2]);\n    const date = parseInt(match[4]);\n    const hours = parseInt(match[6]);\n    const minutes = parseInt(match[8]);\n    const seconds = parseInt(match[10]);\n    const date_object = new Date();\n    date_object.setDate(1);\n    date_object.setMonth(0);\n    date_object.setFullYear(year);\n    date_object.setMonth(month - 1);\n    date_object.setDate(date);\n    date_object.setHours(hours);\n    date_object.setMinutes(minutes);\n    date_object.setSeconds(seconds);\n    return date_object.getTime();\n  }\n  return 0;\n}\n\nexport function dateToString(date: Date, template: string = 'YYYY-MM-DD hh:mm:ss'): string {\n  const result = template\n    .replaceAll(/Y{4,4}/g, date.getFullYear())\n    .replaceAll(/M{2,2}/g, String(date.getMonth() + 1).padStart(2, '0'))\n    .replaceAll(/D{2,2}/g, String(date.getDate()).padStart(2, '0'))\n    .replaceAll(/h{2,2}/g, String(date.getHours()).padStart(2, '0'))\n    .replaceAll(/m{2,2}/g, String(date.getMinutes()).padStart(2, '0'))\n    .replaceAll(/s{2,2}/g, String(date.getSeconds()).padStart(2, '0'));\n  return result;\n}\n\nexport function dateToRelativeTime(date: Date): string {\n  const time = date.getTime();\n  const seconds = Math.floor((new Date().getTime() - time) / 1000);\n  let interval = Math.floor(seconds / 31536000); // seconds in a year\n  if (interval >= 1) {\n    return `${interval}年前`;\n  }\n  interval = Math.floor(seconds / 2592000); // seconds in a month\n  if (interval >= 1) {\n    return `${interval}個月前`;\n  }\n  interval = Math.floor(seconds / 86400); // seconds in a day\n  if (interval >= 1) {\n    return `${interval}天前`;\n  }\n  interval = Math.floor(seconds / 3600); // seconds in an hour\n  if (interval >= 1) {\n    return `${interval}小時前`;\n  }\n  interval = Math.floor(seconds / 60); // seconds in a minute\n  if (interval >= 1) {\n    return `${interval}分鐘前`;\n  }\n  if (seconds > 0) {\n    return `${seconds}秒前`;\n  }\n  return '現在';\n}\n\nexport function formatTime(time: number, mode: number): string {\n  const roundedTime = time | 0;\n  switch (mode) {\n    case 0: {\n      return `${roundedTime}秒`;\n      break;\n    }\n    case 1: {\n      const minutes = String((roundedTime - (roundedTime % 60)) / 60);\n      const seconds = String(roundedTime % 60);\n      return [minutes, seconds].map((u) => u.padStart(2, '0')).join(':');\n      break;\n    }\n    case 2: {\n      const minutes = (roundedTime / 60) | 0;\n      return `${minutes}分`;\n      break;\n    }\n    case 3: {\n      if (roundedTime >= 60 * 60) {\n        const hours = parseFloat((roundedTime / (60 * 60)).toFixed(1));\n        return `${hours}時`;\n      }\n      if (60 <= roundedTime && roundedTime < 60 * 60) {\n        const minutes = (roundedTime / 60) | 0;\n        return `${minutes}分`;\n      }\n      if (roundedTime < 60) {\n        return `${roundedTime}秒`;\n      }\n      break;\n    }\n    default: {\n      return '--';\n      break;\n    }\n  }\n}\n\nexport type WeekDayIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n// 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, 4: Thursday, 5: Friday, 6: Saturday\n\nexport type WeekDayIndexArray = Array<WeekDayIndex>;\n\nexport type WeekDayName = '日' | '一' | '二' | '三' | '四' | '五' | '六';\n\nexport interface WeekDay {\n  name: WeekDayName;\n  day: WeekDayIndex;\n  code: string;\n}\n\nexport function indexToDay(index: WeekDayIndex): WeekDay {\n  const days = [\n    {\n      name: '日',\n      day: 0,\n      code: 'd_0'\n    },\n    {\n      name: '一',\n      day: 1,\n      code: 'd_1'\n    },\n    {\n      name: '二',\n      day: 2,\n      code: 'd_2'\n    },\n    {\n      name: '三',\n      day: 3,\n      code: 'd_3'\n    },\n    {\n      name: '四',\n      day: 4,\n      code: 'd_4'\n    },\n    {\n      name: '五',\n      day: 5,\n      code: 'd_5'\n    },\n    {\n      name: '六',\n      day: 6,\n      code: 'd_6'\n    }\n  ];\n  return days[index];\n}\n\nexport function dateValueToDayOfWeek(dateValue: string): WeekDay {\n  const int = parseInt(dateValue);\n  const index = int - 1;\n  return indexToDay(index);\n}\n\nexport interface TimeObject {\n  hours: number;\n  minutes: number;\n}\n\nexport interface TimePeriod {\n  start: TimeObject;\n  end: TimeObject;\n}\n\nexport interface TimeStampPeriod {\n  start: Date;\n  end: Date;\n}\n\nexport function timeObjectToString(timeObject: TimeObject): string {\n  return `${String(timeObject.hours).padStart(2, '0')}:${String(timeObject.minutes).padStart(2, '0')}`;\n}\n\nexport function createDateObjectFromDate(year: number, month: number, date: number): Date {\n  const dateObject = new Date();\n  dateObject.setDate(1); // Set to the first day of the month to prevent date from being clamped\n  dateObject.setMonth(0);\n  dateObject.setFullYear(year);\n  dateObject.setMonth(month - 1);\n  dateObject.setDate(date);\n  dateObject.setHours(0);\n  dateObject.setMinutes(0);\n  dateObject.setSeconds(0);\n  dateObject.setMilliseconds(0);\n  return dateObject;\n}\n\nexport function maxConcurrency(periods: Array<TimePeriod>): number {\n  let events: Array<[number, 1 | -1]> = [];\n\n  // Convert periods into events\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, 1]); // Start of a period\n    events.push([end.hours * 60 + end.minutes, -1]); // End of a period\n  }\n\n  // Sort events: Primary by time, secondary by type (-1 before +1)\n  events.sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]));\n\n  let maxCount = 0;\n  let currentCount = 0;\n\n  // Sweep through the events\n  for (let [, type] of events) {\n    currentCount += type;\n    maxCount = Math.max(maxCount, currentCount);\n  }\n\n  return maxCount;\n}\n\nexport function assignTracks(periods: Array<TimePeriod>): Array<Array<TimePeriod>> {\n  if (periods.length === 0) return [];\n\n  // Convert periods into events\n  let events: Array<[number, number, number]> = [];\n  let index = 0;\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, end.hours * 60 + end.minutes, index]);\n    index += 1;\n  }\n\n  // Sort intervals by start time\n  events.sort((a, b) => a[0] - b[0]);\n\n  let tracks = [];\n  for (let [start, end, index] of events) {\n    let assigned = false;\n    for (let i = 0; i < tracks.length; i++) {\n      if (tracks[i][tracks[i].length - 1][1] <= start) {\n        tracks[i].push([start, end, index]);\n        assigned = true;\n        break;\n      }\n    }\n    if (!assigned) {\n      tracks.push([[start, end, index]]);\n    }\n  }\n\n  let i = 0;\n  for (const track of tracks) {\n    let j = 0;\n    for (const event of track) {\n      tracks[i][j] = periods[event[2]];\n      j += 1;\n    }\n    i += 1;\n  }\n\n  return tracks;\n}\n","const localforage = require('localforage');\n\nlet storage = {\n  cacheStore: false, // 0\n  settingsStore: false, // 1\n  dataUsageStatsStore: false, // 2\n  updateRateDataStore: false, // 3\n  updateRateDataWriteAheadLogStore: false, // 4\n  busArrivalTimeDataWriteAheadLogStore: false, // 5\n  busArrivalTimeDataStore: false, // 6\n  personalScheduleStore: false, // 7\n  recentViewsStore: false, // 8\n  notificationStore: false, // 9\n  notificationScheduleStore: false, // 10\n  folderListStore: false, // 11\n  folderContentIndexStore: false, // 12\n  folderContentStore: false // 13\n};\n\nconst stores = ['cacheStore', 'settingsStore', 'dataUsageStatsStore', 'updateRateDataStore', 'updateRateDataWriteAheadLogStore', 'busArrivalTimeDataWriteAheadLogStore', 'busArrivalTimeDataStore', 'personalScheduleStore', 'recentViewsStore', 'notificationStore', 'notificationScheduleStore', 'folderListStore', 'folderContentIndexStore', 'folderContentStore'];\n\nasync function dropInstance(store: number): Promise<any> {\n  const storeKey = stores[store];\n  if (storage[storeKey] === false) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n  }\n  const operation = await storage[storeKey].dropInstance();\n  return operation;\n}\n\nexport async function lfSetItem(store: number, key: string, value: any): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].setItem(key, value);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfGetItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].getItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfRemoveItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].removeItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfListItemKeys(store: number): Promise<Array<string>> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const keys = await storage[storeKey].keys();\n    return keys;\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n}\n\nexport function getStoreKey(store: number): string {\n  return stores[store];\n}\n\nexport function getStoresLength(): number {\n  return stores.length;\n}\n\n/*\nexport async function registerStore(id: string): Promise<number> {\n  const storeKey = `F${id}Store`;\n  if (!storage.hasOwnProperty(storeKey) && stores.indexOf(storeKey) < 0) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n    stores.push(storeKey);\n    return stores.length - 1;\n  } else {\n    return stores.indexOf(storeKey);\n  }\n}\n*/\n\nexport async function isStoragePersistent(): Promise<boolean> {\n  // Check if site's storage has been marked as persistent\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persisted();\n      return isPersisted;\n    }\n  }\n  return false;\n}\n\nexport async function askForPersistentStorage(): Promise<'granted' | 'denied' | 'unsupported'> {\n  // Request persistent storage for site\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persist();\n      return isPersisted ? 'granted' : 'denied';\n    }\n  }\n  return 'unsupported';\n}\n","import { findExtremum } from '../../../tools/math';\nimport { Segments, segmentsToPath, simplifyPath } from '../../../tools/path';\nimport { createDateObjectFromDate } from '../../../tools/time';\nimport { DataUsagePeriod, DataUsageStats, DataUsageStatsChunkArray } from './index';\n\nself.onmessage = function (e) {\n  const result = processWorkerTask(e.data);\n  self.postMessage(result); // Send the result back to the main thread\n};\n\ntype data = [dataUsageStatsChunks: DataUsageStatsChunkArray, width: number, height: number, padding: number];\n\nconst minutesPerDay = 60 * 24;\n\n// Main processing function\nfunction processWorkerTask(data: data): DataUsageStats {\n  const [dataUsageStatsChunks, width, height, padding] = data;\n\n  const dataUsageStatsChunksLength = dataUsageStatsChunks.length;\n\n  const extremum: Array<number> = [];\n  let sum: number = 0;\n  for (const dataUsageStatsChunk of dataUsageStatsChunks) {\n    extremum.push(dataUsageStatsChunk.stats.max);\n    extremum.push(dataUsageStatsChunk.stats.min);\n    sum += dataUsageStatsChunk.stats.sum;\n  }\n\n  const globalExtremum = findExtremum(extremum);\n  const max = globalExtremum[1] === 0 ? 1 : globalExtremum[1]; // prevent division by zero\n  const min = globalExtremum[0] === 0 ? 1 : globalExtremum[0]; // prevent division by zero\n\n  const start = dataUsageStatsChunks[0].date;\n  const end = dataUsageStatsChunks[dataUsageStatsChunksLength - 1].date;\n  const startDate = createDateObjectFromDate(start[0], start[1], start[2]);\n  const endDate = createDateObjectFromDate(end[0], end[1], end[2]);\n\n  const points: Segments = [];\n  for (let i = 0; i < dataUsageStatsChunksLength; i++) {\n    const dataUsageStatsChunk = dataUsageStatsChunks[i];\n    const sum = dataUsageStatsChunk.stats.sum;\n    if (sum === 0) {\n      const x1 = padding + (i / (DataUsagePeriod + 1)) * width;\n      const x2 = padding + ((i + (minutesPerDay - 1) / minutesPerDay) / (DataUsagePeriod + 1)) * width;\n      const y = padding + height;\n      points.push({ x: x1, y });\n      points.push({ x: x2, y });\n      continue;\n    }\n    const data = dataUsageStatsChunk.data;\n    for (let j = 0; j < minutesPerDay; j++) {\n      const x = padding + ((i + j / minutesPerDay) / (DataUsagePeriod + 1)) * width;\n      const y = padding + (1 - data[j] / max) * height;\n      points.push({ x, y });\n    }\n  }\n\n  // X-axis (horizontal)\n  const xAxis = `<line x1=\"${padding}\" y1=\"${height + padding}\" x2=\"${padding + width}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Y-axis (vertical)\n  const yAxis = `<line x1=\"${padding}\" y1=\"${padding}\" x2=\"${padding}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Axis Labels\n  const xAxisLabel = `<text x=\"${padding + width / 2}\" y=\"${padding + height + padding}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\">時間</text>`;\n  const yAxisLabel = `<text x=\"${padding / 2}\" y=\"${padding + height / 2}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\" transform=\"rotate(-90, ${padding * 0.7}, ${padding + height / 2})\">傳輸量</text>`;\n\n  // Paths\n  const simplifiedPath = simplifyPath(points, 1.1);\n  const pathData = segmentsToPath(simplifiedPath, 1);\n  const fillingPathData = `M${padding},${height + padding}${pathData}L${padding + width},${height + padding}L${padding},${height + padding}`;\n  const path = `<path d=\"${pathData}\" fill=\"none\" stroke=\"var(--b-cssvar-main-color)\" stroke-width=\"0.9\" stroke-linecap=\"round\" stroke-linejoin=\"round\" opacity=\"1\"></path>`;\n  const fillingPath = `<path d=\"${fillingPathData}\" stroke=\"none\" stroke-width=\"0\" fill=\"url(#grad1)\"></path>`;\n  const filling = `<linearGradient id=\"grad1\" x1=\"50%\" y1=\"0%\" x2=\"50%\" y2=\"100%\"><stop offset=\"0%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.3);\" /><stop offset=\"73%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.09);\" /><stop offset=\"100%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0);\" /></linearGradient>`;\n\n  // SVG\n  const chart = /*html*/ `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width + padding * 2} ${height + padding * 2}\"><defs>${filling}</defs>${fillingPath}${path}${xAxis}${yAxis}${xAxisLabel}${yAxisLabel}</svg>`;\n\n  const result: DataUsageStats = {\n    stats: {\n      max,\n      min,\n      sum\n    },\n    period: {\n      start: startDate,\n      end: endDate\n    },\n    chart\n  };\n\n  // Send the result back to the main thread\n  return result;\n}\n","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\n/**\n * get the unit vecotr towards the same direction\n * @param vector [a1, a2, a3, ...]\n * @returns [b1, b2, b3, ...]\n */\n\nexport function normalizeVector(vector: Array<number>): Array<number> {\n  const length = Math.hypot(vector);\n  const newVector = [];\n  if (length > 0) {\n    const scale = 1 / length;\n    for (const x of vector) {\n      newVector.push(x * scale);\n    }\n    return newVector;\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function findExtremum(array: Array<number>): [minimum: number, maximum: number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [790], () => (__webpack_require__(5106)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + {\"106\":\"2a90da2989a915f0c9fd\",\"790\":\"82e5095298ed4f0999f5\"}[chunkId] + \".js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"./\";","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t106: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkbus\"] = self[\"webpackChunkbus\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["root","factory","exports","module","define","amd","self","deferred","next","distanceToSegment","point","start","end","dx","x","dy","y","d","t","closestPoint","Math","sqrt","simplifyPath","points","tolerance","length","dmax","index","i","leftPoints","slice","rightPoints","simplifiedLeft","simplifiedRight","concat","createDateObjectFromDate","year","month","date","dateObject","Date","setDate","setMonth","setFullYear","setHours","setMinutes","setSeconds","setMilliseconds","require","onmessage","e","result","data","_step","_data","_slicedToArray","dataUsageStatsChunks","width","height","padding","dataUsageStatsChunksLength","extremum","sum","_iterator","_createForOfIteratorHelper","s","n","done","dataUsageStatsChunk","value","push","stats","max","min","err","f","globalExtremum","array","arrayLength","Infinity","item","findExtremum","startDate","endDate","j","minutesPerDay","x1","x2","xAxis","yAxis","xAxisLabel","yAxisLabel","pathData","segments","scale","pathCommand","segmentsLength1","current","lastPoint","segmentsToPath","period","chart","processWorkerTask","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","m","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","fulfilled","Object","keys","every","key","splice","r","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","o","obj","prop","prototype","hasOwnProperty","call","p","b","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}