{"version":3,"file":"e770fe9a67758cc70673.js","mappings":"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","sources":["webpack://bus/./src/data/analytics/update-rate/index.ts","webpack://bus/./src/data/analytics/bus-arrival-time/index.ts","webpack://bus/./src/data/analytics/data-usage/index.ts"],"sourcesContent":["import { generateIdentifier } from '../../../tools/index';\nimport { mergePearsonCorrelation, mergeStandardDeviation } from '../../../tools/math';\nimport { EstimateTime } from '../../apis/getEstimateTime/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../../storage/index';\n\nexport type UpdateRateData = [estimateTime: number, timestamp: number]; // EstimateTime (seconds), timestamp (seconds)\n\nexport interface UpdateRateDataGroupStats {\n  estimate_time: {\n    average: number;\n    stdev: number;\n  };\n  timestamp: {\n    average: number;\n    stdev: number;\n  };\n  correlation: number;\n  length: number;\n}\n\nexport interface UpdateRateDataGroup {\n  stats: UpdateRateDataGroupStats;\n  timestamp: number;\n  id: number; // stop id\n}\n\nexport type UpdateRateDataGroupArray = Array<UpdateRateDataGroup>;\n\nexport interface UpdateRateDataWriteAheadLogGroup {\n  data: Array<UpdateRateData>;\n  timestamp: number;\n  id: string;\n}\n\nconst updateRateData_sampleQuantity: number = 32;\nlet updateRateData_trackedStops: Array<number> = [];\nlet updateRateData_writeAheadLog_id: string = '';\nlet updateRateData_writeAheadLog_tracking: boolean = false;\nlet updateRateData_writeAheadLog_currentDataLength: number = 0;\nconst updateRateData_writeAheadLog_maxDataLength: number = 45;\nlet updateRateData_writeAheadLog_group: UpdateRateDataWriteAheadLogGroup = {\n  data: {},\n  timestamp: 0,\n  id: ''\n};\nconst updateRateData_groups: Array<UpdateRateDataGroup> = [];\nconst updateRateData_groupsIndex: { [key: string]: number } = {};\n\nfunction getUpdateRateDataStats(data: Array<UpdateRateData>): UpdateRateDataGroupStats {\n  let sumEstimateTime = 0;\n  let sumEstimateTimeSquared = 0;\n  let sumTimestamp = 0;\n  let sumTimestampSquared = 0;\n  let dataLength = 0;\n  for (const item of data) {\n    const estimateTime = item[0];\n    const timestamp = item[1];\n    dataLength += 1;\n    sumEstimateTime += estimateTime;\n    sumTimestamp += timestamp;\n    sumEstimateTimeSquared += Math.pow(estimateTime, 2);\n    sumTimestampSquared += Math.pow(timestamp, 2);\n  }\n\n  const averageEstimateTime = sumEstimateTime / dataLength;\n  const averageTimestamp = sumTimestamp / dataLength;\n\n  const estimateTimeVariance = sumEstimateTimeSquared / dataLength - Math.pow(averageEstimateTime, 2);\n  const timestampVariance = sumTimestampSquared / dataLength - Math.pow(averageTimestamp, 2);\n\n  const estimateTimeSTDEV = Math.sqrt(estimateTimeVariance);\n  const timestampSTDEV = Math.sqrt(timestampVariance);\n\n  let covariance = 0;\n  for (const item2 of data) {\n    const estimateTime = item2[0];\n    const timestamp = item2[1];\n    covariance += (estimateTime - averageEstimateTime) * (timestamp - averageTimestamp);\n  }\n  covariance /= dataLength;\n\n  const correlation = covariance / (estimateTimeSTDEV * timestampSTDEV);\n\n  const result: UpdateRateDataGroupStats = {\n    estimate_time: {\n      average: averageEstimateTime,\n      stdev: estimateTimeSTDEV\n    },\n    timestamp: {\n      average: averageTimestamp,\n      stdev: timestampSTDEV\n    },\n    length: dataLength,\n    correlation: correlation\n  };\n  return result;\n}\n\nfunction mergeUpdateRateDataStats(targetStats: UpdateRateDataGroupStats, sourceStats: UpdateRateDataGroupStats): UpdateRateDataGroupStats {\n  const mergedDataLength = targetStats.length + sourceStats.length;\n\n  const mergedAverageEstimateTime = (targetStats.estimate_time.average * targetStats.length + sourceStats.estimate_time.average * sourceStats.length) / mergedDataLength;\n  const mergedAverageTimestamp = (targetStats.timestamp.average * targetStats.length + sourceStats.timestamp.average * sourceStats.length) / mergedDataLength;\n\n  const mergedEstimateTimeSTDEV = mergeStandardDeviation(targetStats.estimate_time.average, targetStats.estimate_time.stdev, targetStats.length, sourceStats.estimate_time.average, sourceStats.estimate_time.stdev, sourceStats.length);\n  const mergedTimestampSTDEV = mergeStandardDeviation(targetStats.timestamp.average, targetStats.timestamp.stdev, targetStats.length, sourceStats.timestamp.average, sourceStats.timestamp.stdev, sourceStats.length);\n\n  const mergedCorrelation = mergePearsonCorrelation(targetStats.estimate_time.average, targetStats.timestamp.average, targetStats.estimate_time.stdev, targetStats.timestamp.stdev, targetStats.length, targetStats.correlation, sourceStats.estimate_time.average, sourceStats.timestamp.average, sourceStats.estimate_time.stdev, sourceStats.timestamp.stdev, sourceStats.length, sourceStats.correlation);\n\n  const result: UpdateRateDataGroupStats = {\n    estimate_time: {\n      average: mergedAverageEstimateTime,\n      stdev: mergedEstimateTimeSTDEV\n    },\n    timestamp: {\n      average: mergedAverageTimestamp,\n      stdev: mergedTimestampSTDEV\n    },\n    length: mergedDataLength,\n    correlation: mergedCorrelation\n  };\n  return result;\n}\n\nexport async function collectUpdateRateData(EstimateTime: EstimateTime) {\n  const now = new Date();\n  const currentTimestamp: number = now.getTime();\n  let needToReset = false;\n  // Initialize\n  if (!updateRateData_writeAheadLog_tracking) {\n    updateRateData_writeAheadLog_tracking = true;\n    updateRateData_trackedStops = [];\n    updateRateData_writeAheadLog_id = generateIdentifier();\n    updateRateData_writeAheadLog_group = {\n      data: {},\n      timestamp: currentTimestamp,\n      id: updateRateData_writeAheadLog_id\n    };\n    updateRateData_writeAheadLog_currentDataLength = 0;\n    const EstimateTimeLength1: number = EstimateTime.length - 1;\n    for (let i = 0; i < updateRateData_sampleQuantity; i++) {\n      const randomIndex: number = Math.floor(Math.random() * EstimateTimeLength1);\n      const randomItem = EstimateTime[randomIndex];\n      updateRateData_trackedStops.push(randomItem.StopID);\n    }\n  }\n\n  // Record EstimateTime\n  for (const item of EstimateTime) {\n    const stopID = item.StopID;\n    const stopKey = `s_${stopID}`;\n    if (updateRateData_trackedStops.indexOf(stopID) > -1) {\n      if (!updateRateData_writeAheadLog_group.data.hasOwnProperty(stopKey)) {\n        updateRateData_writeAheadLog_group.data[stopKey] = [];\n      }\n      updateRateData_writeAheadLog_group.data[stopKey].push([parseInt(item.EstimateTime), Math.floor((currentTimestamp - updateRateData_writeAheadLog_group.timestamp) / 1000)]);\n    }\n  }\n\n  updateRateData_writeAheadLog_currentDataLength += 1;\n  if (updateRateData_writeAheadLog_currentDataLength > updateRateData_writeAheadLog_maxDataLength) {\n    needToReset = true;\n  }\n\n  if (updateRateData_writeAheadLog_currentDataLength % 5 === 0) {\n    await lfSetItem(4, updateRateData_writeAheadLog_id, JSON.stringify(updateRateData_writeAheadLog_group));\n  }\n\n  if (needToReset) {\n    for (const stopID of updateRateData_trackedStops) {\n      const stopKey = `s_${stopID}`;\n      const data = updateRateData_writeAheadLog_group.data[stopKey];\n      const dataGroup = {} as UpdateRateDataGroup;\n      const existingData = await lfGetItem(3, stopKey);\n      if (existingData) {\n        const existingDataObject = JSON.parse(existingData) as UpdateRateDataGroup;\n        dataGroup.stats = mergeUpdateRateDataStats(existingDataObject.stats, getUpdateRateDataStats(data));\n        dataGroup.timestamp = existingDataObject.timestamp;\n        dataGroup.id = stopID;\n      } else {\n        dataGroup.stats = getUpdateRateDataStats(data);\n        dataGroup.timestamp = currentTimestamp;\n        dataGroup.id = stopID;\n      }\n      await lfSetItem(3, stopKey, JSON.stringify(dataGroup));\n      if (updateRateData_groupsIndex.hasOwnProperty(stopKey)) {\n        const existingIndex = updateRateData_groupsIndex[stopKey];\n        updateRateData_groups.splice(existingIndex, 1, dataGroup);\n      } else {\n        updateRateData_groups[stopKey] = updateRateData_groups.length;\n        updateRateData_groups.push(dataGroup);\n      }\n      await lfRemoveItem(4, updateRateData_writeAheadLog_id);\n    }\n\n    updateRateData_writeAheadLog_tracking = false;\n  }\n}\n\nexport async function recoverUpdateRateDataFromWriteAheadLog() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(4);\n  for (const key of keys) {\n    const json = await lfGetItem(4, key);\n    if (json) {\n      const object = JSON.parse(json) as UpdateRateDataWriteAheadLogGroup;\n      const thisTimestamp = object.timestamp;\n      const thisID = object.id;\n      if (thisTimestamp > oneWeekAgo) {\n        for (const stopKey in object.data) {\n          const thisStopData = object.data[stopKey];\n          const dataGroup = {} as UpdateRateDataGroup;\n          const existingData = await lfGetItem(3, stopKey);\n          if (existingData) {\n            const existingDataObject = JSON.parse(existingData) as UpdateRateDataGroup;\n            dataGroup.stats = mergeUpdateRateDataStats(existingDataObject.stats, getUpdateRateDataStats(thisStopData));\n            dataGroup.timestamp = existingDataObject.timestamp;\n            dataGroup.id = existingDataObject.id;\n          } else {\n            dataGroup.stats = getUpdateRateDataStats(thisStopData);\n            dataGroup.timestamp = thisTimestamp;\n            dataGroup.id = parseInt(stopKey.split('_')[1]);\n          }\n          await lfSetItem(3, stopKey, JSON.stringify(dataGroup));\n          if (updateRateData_groupsIndex.hasOwnProperty(stopKey)) {\n            const existingIndex = updateRateData_groupsIndex[stopKey];\n            updateRateData_groups.splice(existingIndex, 1, dataGroup);\n          } else {\n            updateRateData_groups[stopKey] = updateRateData_groups.length;\n            updateRateData_groups.push(dataGroup);\n          }\n        }\n      }\n      await lfRemoveItem(4, thisID);\n    }\n  }\n}\n\nexport async function initializeUpdateRateDataGroups() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(3);\n  let index: number = 0;\n  for (const key of keys) {\n    const json = await lfGetItem(3, key);\n    if (json) {\n      const object = JSON.parse(json) as UpdateRateDataGroup;\n      const thisTimestamp = object.timestamp;\n      if (thisTimestamp > oneWeekAgo) {\n        updateRateData_groups.push(object);\n        updateRateData_groupsIndex[key] = index;\n        index += 1;\n      }\n    }\n  }\n}\n\nexport function listUpdateRateDataGroups(): Array<UpdateRateDataGroup> {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  return updateRateData_groups.filter((item) => item.timestamp > oneWeekAgo);\n}\n\nexport async function discardExpiredUpdateRateDataGroups() {\n  const now = new Date().getTime();\n  const oneWeekAgo = now - 60 * 60 * 7 * 1000;\n  const keys = await lfListItemKeys(3);\n  for (const key of keys) {\n    const json = await lfGetItem(3, key);\n    const object = JSON.parse(json) as UpdateRateDataGroup;\n    const thisTimestamp = object.timestamp;\n    if (thisTimestamp <= oneWeekAgo) {\n      await lfRemoveItem(3, key);\n    }\n  }\n}\n\nconst getUpdateRateWorkerResponses = {};\nlet port;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getUpdateRateSharedWorker = new SharedWorker(new URL('./getUpdateRate-worker.ts', import.meta.url)); // Reusable shared worker\n  port = getUpdateRateSharedWorker.port; // Access the port for communication\n  port.start(); // Start the port (required by some browsers)\n} else {\n  const getUpdateRateWorker = new Worker(new URL('./getUpdateRate-worker.ts', import.meta.url)); // Fallback to standard worker\n  port = getUpdateRateWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\nport.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getUpdateRateWorkerResponses[taskID]) {\n    getUpdateRateWorkerResponses[taskID](result); // Resolve the correct promise\n    delete getUpdateRateWorkerResponses[taskID]; // Clean up the response handler\n  }\n};\n\n// Handle errors\nport.onerror = function (e) {\n  console.error(e.message);\n};\n\nexport async function getUpdateRate(): Promise<number> {\n  const dataGroups = await listUpdateRateDataGroups();\n  const taskID = generateIdentifier();\n\n  const result = await new Promise((resolve, reject) => {\n    getUpdateRateWorkerResponses[taskID] = resolve; // Store the resolve function for this taskID\n\n    port.onerror = function (e) {\n      reject(e.message);\n    };\n\n    port.postMessage([dataGroups, taskID]); // Send the task to the worker\n  });\n\n  return result;\n}\n","import { generateIdentifier } from '../../../tools/index';\nimport { findGlobalExtrema } from '../../../tools/math';\nimport { WeekDayIndex } from '../../../tools/time';\nimport { EstimateTime } from '../../apis/getEstimateTime/index';\nimport { listAllFolderContent } from '../../folder/index';\nimport { isInPersonalSchedule, listPersonalSchedules, PersonalSchedule } from '../../personal-schedule/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../../storage/index';\n\nconst busArrivalTimeData_writeAheadLog_maxDataLength: number = 32;\nlet busArrivalTimeData_writeAheadLog_id: string = '';\nlet busArrivalTimeData_writeAheadLog_tracking: boolean = false;\nlet busArrivalTimeData_trackedStops: Array<number> = [];\nlet busArrivalTimeData_writeAheadLog_group: BusArrivalTimeDataWriteAheadLog = {\n  data: {},\n  timestamp: 0,\n  id: ''\n};\nlet busArrivalTimeData_writeAheadLog_currentDataLength: number = 0;\n\nexport type BusArrivalTimeData = [estimateTime: number, timestamp: number]; // EstimateTime (seconds), timestamp (milliseconds)\n\nexport type BusArrivalTimeDataGroupStats = Array<number>;\n\nexport interface BusArrivalTimeDataGroup {\n  stats: BusArrivalTimeDataGroupStats;\n  day: WeekDayIndex;\n  max: number;\n  min: number;\n  timestamp: number;\n  id: number; // stop id\n}\n\nexport type BusArrivalTimeDataGroupArray = Array<BusArrivalTimeDataGroup>;\n\nexport interface BusArrivalTimeDataWriteAheadLog {\n  data: {\n    [key: string]: Array<BusArrivalTimeData>;\n  };\n  timestamp: number;\n  id: string;\n}\n\nexport interface BusArrivalTime {\n  personalSchedule: PersonalSchedule;\n  chart: string; // svg\n  day: WeekDayIndex;\n}\n\nexport interface BusArrivalTimes {\n  [stopKey: string]: Array<BusArrivalTime>;\n}\n\nconst getBusArrivalTimeDataStatsWorkerTasks = {};\nlet getBusArrivalTimeDataStatsPort;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getBusArrivalTimeDataStatsWorker = new SharedWorker(new URL('./getBusArrivalTimeDataStats-worker.ts', import.meta.url)); // Reusable shared worker\n  getBusArrivalTimeDataStatsPort = getBusArrivalTimeDataStatsWorker.port; // Access the port for communication\n  getBusArrivalTimeDataStatsPort.start(); // Start the port (required by some browsers)\n} else {\n  const getBusArrivalTimeDataStatsWorker = new Worker(new URL('./getBusArrivalTimeDataStats-worker.ts', import.meta.url)); // Fallback to standard worker\n  getBusArrivalTimeDataStatsPort = getBusArrivalTimeDataStatsWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\ngetBusArrivalTimeDataStatsPort.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getBusArrivalTimeDataStatsWorkerTasks[taskID]) {\n    getBusArrivalTimeDataStatsWorkerTasks[taskID](result); // resolve\n    delete getBusArrivalTimeDataStatsWorkerTasks[taskID];\n  }\n};\n\n// Handle errors\ngetBusArrivalTimeDataStatsPort.onerror = function (e) {\n  console.error(e.message);\n};\n\nasync function getBusArrivalTimeDataStats(data: Array<BusArrivalTimeData>): Promise<BusArrivalTimeDataGroupStats> {\n  const taskID = generateIdentifier();\n\n  const result = await new Promise((resolve, reject) => {\n    getBusArrivalTimeDataStatsWorkerTasks[taskID] = resolve; // Store the resolve function for this taskID\n    getBusArrivalTimeDataStatsPort.onerror = function (e) {\n      reject(e.message);\n    };\n    getBusArrivalTimeDataStatsPort.postMessage([data, taskID]); // Send the task to the worker\n  });\n  return result;\n}\n\nfunction mergeBusArrivalTimeDataStats(targetStats: BusArrivalTimeDataGroupStats, sourceStats: BusArrivalTimeDataGroupStats): BusArrivalTimeDataGroupStats {\n  const mergedArray = new Uint32Array(60 * 24);\n  for (let i = 60 * 24 - 1; i >= 0; i--) {\n    mergedArray[i] = targetStats[i] + sourceStats[i];\n  }\n  return Array.from(mergedArray);\n}\n\nexport async function collectBusArrivalTimeData(EstimateTime: EstimateTime) {\n  const now = new Date();\n  const currentTimestamp: number = now.getTime();\n  const currentDay = now.getDay();\n  let needToReset = false;\n  // Initialize\n  if (!busArrivalTimeData_writeAheadLog_tracking) {\n    busArrivalTimeData_writeAheadLog_tracking = true;\n    busArrivalTimeData_writeAheadLog_id = generateIdentifier();\n    busArrivalTimeData_writeAheadLog_group = {\n      id: busArrivalTimeData_writeAheadLog_id,\n      timestamp: currentTimestamp,\n      data: {}\n    };\n    busArrivalTimeData_writeAheadLog_currentDataLength = 0;\n    const allFolderContent = await listAllFolderContent(['stop']);\n    busArrivalTimeData_trackedStops = allFolderContent.map((e) => e.id);\n  }\n\n  // Record EstimateTime\n  if (isInPersonalSchedule(now)) {\n    for (const item of EstimateTime) {\n      const stopID = item.StopID;\n      const stopKey = `s_${stopID}_${currentDay}`;\n      if (busArrivalTimeData_trackedStops.indexOf(stopID) > -1) {\n        if (!busArrivalTimeData_writeAheadLog_group.data.hasOwnProperty(stopKey)) {\n          busArrivalTimeData_writeAheadLog_group.data[stopKey] = [];\n        }\n        busArrivalTimeData_writeAheadLog_group.data[stopKey].push([parseInt(item.EstimateTime), currentTimestamp]);\n      }\n    }\n\n    busArrivalTimeData_writeAheadLog_currentDataLength += 1;\n    if (busArrivalTimeData_writeAheadLog_currentDataLength > busArrivalTimeData_writeAheadLog_maxDataLength) {\n      needToReset = true;\n    }\n\n    if (needToReset || busArrivalTimeData_writeAheadLog_currentDataLength % 8 === 0) {\n      await lfSetItem(5, busArrivalTimeData_writeAheadLog_id, JSON.stringify(busArrivalTimeData_writeAheadLog_group));\n    }\n\n    if (needToReset) {\n      for (const stopID of busArrivalTimeData_trackedStops) {\n        const stopKey = `s_${stopID}_${currentDay}`;\n        const data = busArrivalTimeData_writeAheadLog_group.data[stopKey];\n        const dataGroup = {} as BusArrivalTimeDataGroup;\n        const existingData = await lfGetItem(6, stopKey);\n        if (existingData) {\n          const existingDataObject = JSON.parse(existingData) as BusArrivalTimeDataGroup;\n          const newStats = getBusArrivalTimeDataStats(data);\n          const mergedStats = mergeBusArrivalTimeDataStats(existingDataObject.stats, newStats);\n          dataGroup.stats = mergedStats;\n          const mergedExtrema = findGlobalExtrema(mergedStats);\n          dataGroup.min = mergedExtrema[0];\n          dataGroup.max = mergedExtrema[1];\n          dataGroup.day = currentDay;\n          dataGroup.timestamp = existingDataObject.timestamp;\n          dataGroup.id = stopID;\n        } else {\n          const newStats = getBusArrivalTimeDataStats(data);\n          dataGroup.stats = newStats;\n          const newExtrema = findGlobalExtrema(newStats);\n          dataGroup.min = newExtrema[0];\n          dataGroup.max = newExtrema[1];\n          dataGroup.day = currentDay;\n          dataGroup.timestamp = currentTimestamp;\n          dataGroup.id = stopID;\n        }\n        await lfSetItem(6, stopKey, JSON.stringify(dataGroup));\n        await lfRemoveItem(5, busArrivalTimeData_writeAheadLog_id);\n      }\n      busArrivalTimeData_writeAheadLog_tracking = false;\n    }\n  }\n}\n\nexport async function recoverBusArrivalTimeDataFromWriteAheadLog() {\n  const now = new Date();\n  const currentTimestamp = now.getTime();\n  const currentDay = now.getDay();\n  const keys = await lfListItemKeys(5);\n  for (const key of keys) {\n    const json = await lfGetItem(5, key);\n    const object = JSON.parse(json) as BusArrivalTimeDataWriteAheadLog;\n    const thisID = object.id;\n    for (const stopKey in object.data) {\n      const thisStopData = object.data[stopKey];\n      const dataGroup = {} as BusArrivalTimeDataGroup;\n      const existingData = await lfGetItem(6, stopKey);\n      const stopID = parseInt(stopKey.split('_')[1]);\n      if (existingData) {\n        const existingDataObject = JSON.parse(existingData) as BusArrivalTimeDataGroup;\n        const newStats = getBusArrivalTimeDataStats(thisStopData);\n        const mergedStats = mergeBusArrivalTimeDataStats(existingDataObject.stats, newStats);\n        dataGroup.stats = mergedStats;\n        const newExtremum = findGlobalExtrema(mergedStats);\n        dataGroup.min = newExtremum[0];\n        dataGroup.max = newExtremum[1];\n        dataGroup.day = existingDataObject.day;\n        dataGroup.timestamp = existingDataObject.timestamp;\n        dataGroup.id = stopID;\n      } else {\n        const newStats = getBusArrivalTimeDataStats(thisStopData);\n        dataGroup.stats = newStats;\n        const newExtremum = findGlobalExtrema(newStats);\n        dataGroup.min = newExtremum[0];\n        dataGroup.max = newExtremum[1];\n        dataGroup.day = currentDay;\n        dataGroup.timestamp = currentTimestamp;\n        dataGroup.id = stopID;\n      }\n      await lfSetItem(6, stopKey, JSON.stringify(dataGroup));\n    }\n    await lfRemoveItem(5, thisID);\n  }\n}\n\nexport async function listBusArrivalTimeDataGroups(): Promise<BusArrivalTimeDataGroupArray> {\n  const keys = await lfListItemKeys(6);\n  const result: BusArrivalTimeDataGroupArray = [];\n  for (const key of keys) {\n    const json = await lfGetItem(6, key);\n    if (json) {\n      const object = JSON.parse(json) as BusArrivalTimeDataGroup;\n      result.push(object);\n    }\n  }\n  return result;\n}\n\nconst getBusArrivalTimesWorkerResponses = {};\nlet getBusArrivalTimesPort;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getUpdateRateSharedWorker = new SharedWorker(new URL('./getBusArrivalTimes-worker.ts', import.meta.url)); // Reusable shared worker\n  getBusArrivalTimesPort = getUpdateRateSharedWorker.port; // Access the port for communication\n  getBusArrivalTimesPort.start(); // Start the port (required by some browsers)\n} else {\n  const getUpdateRateWorker = new Worker(new URL('./getBusArrivalTimes-worker.ts', import.meta.url)); // Fallback to standard worker\n  getBusArrivalTimesPort = getUpdateRateWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\ngetBusArrivalTimesPort.onmessage = function (e) {\n  const [result, taskID] = e.data;\n  if (getBusArrivalTimesWorkerResponses[taskID]) {\n    getBusArrivalTimesWorkerResponses[taskID](result); // Resolve the correct promise\n    delete getBusArrivalTimesWorkerResponses[taskID]; // Clean up the response handler\n  }\n};\n\n// Handle errors\ngetBusArrivalTimesPort.onerror = function (e) {\n  console.error(e.message);\n};\n\nexport async function getBusArrivalTimes(chartWidth: number, chartHeight: number): Promise<BusArrivalTimes> {\n  const taskID = generateIdentifier();\n\n  const personalSchedules = await listPersonalSchedules();\n  const busArrivalTimeDataGroups = await listBusArrivalTimeDataGroups();\n\n  const result = await new Promise((resolve, reject) => {\n    getBusArrivalTimesWorkerResponses[taskID] = resolve; // Store the resolve function for this taskID\n    getBusArrivalTimesPort.onerror = function (e) {\n      reject(e.message);\n    };\n    getBusArrivalTimesPort.postMessage([personalSchedules, busArrivalTimeDataGroups, chartWidth, chartHeight, taskID]); // Send the task to the worker\n  });\n  return result;\n}\n","import { createDateObjectFromDate, dateToString, offsetDate, TimeStampPeriod } from '../../../tools/time';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../../storage/index';\n\nexport interface DataUsageStatsChunk {\n  date: [year: number, month: number, day: number];\n  data: Array<number>;\n  stats: {\n    sum: number;\n    max: number;\n    min: number;\n  };\n}\n\nexport type DataUsageStatsChunkArray = Array<DataUsageStatsChunk>;\n\nexport interface DataUsageStats {\n  stats: {\n    sum: number;\n    max: number;\n    min: number;\n  };\n  period: TimeStampPeriod;\n  chart: string;\n}\n\nexport const DataUsagePeriod = 7; // days\n\nexport async function recordDataUsage(contentLength: number, date: Date) {\n  const key = `d_${dateToString(date, 'YYYY_MM_DD')}`;\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const index = hours * 60 + minutes;\n  const existingDataUsageStatsChunkJSON = await lfGetItem(2, key);\n  if (existingDataUsageStatsChunkJSON) {\n    const existingDataUsageStatsChunkObject = JSON.parse(existingDataUsageStatsChunkJSON) as DataUsageStatsChunk;\n    existingDataUsageStatsChunkObject.stats.sum += contentLength;\n    existingDataUsageStatsChunkObject.data[index] += contentLength;\n    const changedData = existingDataUsageStatsChunkObject.data[index];\n    if (changedData > existingDataUsageStatsChunkObject.stats.max) {\n      existingDataUsageStatsChunkObject.stats.max = changedData;\n    }\n    if (changedData < existingDataUsageStatsChunkObject.stats.min) {\n      existingDataUsageStatsChunkObject.stats.min = changedData;\n    }\n    await lfSetItem(2, key, JSON.stringify(existingDataUsageStatsChunkObject));\n  } else {\n    const newDataUsageStatsChunk = {} as DataUsageStatsChunk;\n    const data = new Uint32Array(60 * 24);\n    data[index] += contentLength;\n    newDataUsageStatsChunk.data = Array.from(data);\n    newDataUsageStatsChunk.stats = {\n      sum: contentLength,\n      max: contentLength,\n      min: 0\n    };\n    newDataUsageStatsChunk.date = [date.getFullYear(), date.getMonth() + 1, date.getDate()];\n    await lfSetItem(2, key, JSON.stringify(newDataUsageStatsChunk));\n  }\n}\n\nexport async function listDataUsageStatsChunks(): Promise<DataUsageStatsChunkArray> {\n  const endDate = new Date();\n  endDate.setHours(0);\n  endDate.setMinutes(0);\n  endDate.setSeconds(0);\n  endDate.setMilliseconds(0);\n  const startDate = offsetDate(endDate, -1 * DataUsagePeriod, 0, 0);\n  const result: DataUsageStatsChunkArray = [];\n  for (let i = 1; i <= DataUsagePeriod; i++) {\n    const date = offsetDate(startDate, i, 0, 0);\n    const key = `d_${dateToString(date, 'YYYY_MM_DD')}`;\n    const existingDataUsageStatsChunkJSON = await lfGetItem(2, key);\n    if (existingDataUsageStatsChunkJSON) {\n      const existingDataUsageStatsChunkObject = JSON.parse(existingDataUsageStatsChunkJSON) as DataUsageStatsChunk;\n      result.push(existingDataUsageStatsChunkObject);\n    } else {\n      const blankDataUsageStatsChunk = {} as DataUsageStatsChunk;\n      const data = new Uint32Array(60 * 24);\n      blankDataUsageStatsChunk.data = Array.from(data);\n      blankDataUsageStatsChunk.stats = {\n        sum: 0,\n        max: 0,\n        min: 0\n      };\n      blankDataUsageStatsChunk.date = [date.getFullYear(), date.getMonth() + 1, date.getDate()];\n      result.push(blankDataUsageStatsChunk);\n    }\n  }\n  return result;\n}\n\nexport async function discardExpiredDataUsageStats() {\n  const millisecondsPerDay = 60 * 60 * 24 * 1000;\n  const expirationPeriod = millisecondsPerDay * DataUsagePeriod;\n  const now = new Date().getTime();\n  const keys = await lfListItemKeys(2);\n  for (const key of keys) {\n    const json = await lfGetItem(2, key);\n    const object = JSON.parse(json) as DataUsageStatsChunk;\n    const date = createDateObjectFromDate(object.date[0], object.date[1], object.date[2]);\n    if (now - date.getTime() > expirationPeriod) {\n      await lfRemoveItem(2, key);\n    }\n  }\n}\n\nexport async function getDataUsageStats(width: number, height: number, padding: number): Promise<DataUsageStats> {\n  const worker = new Worker(new URL('./getDataUsageStats-worker.ts', import.meta.url));\n  const dataUsageStatsChunks = await listDataUsageStatsChunks();\n  // Wrap worker communication in a promise\n  const result = await new Promise((resolve, reject) => {\n    worker.onmessage = function (e) {\n      resolve(e.data); // Resolve the promise with the worker's result\n      worker.terminate(); // Terminate the worker when done\n    };\n    worker.onerror = function (e) {\n      reject(e.message); // Reject the promise on error\n      worker.terminate(); // Terminate the worker if an error occurs\n    };\n    worker.postMessage([dataUsageStatsChunks, width, height, padding]); // Send data to the worker\n  });\n  return result;\n}\n"],"names":["updateRateData_trackedStops","updateRateData_writeAheadLog_id","updateRateData_writeAheadLog_tracking","updateRateData_writeAheadLog_currentDataLength","updateRateData_writeAheadLog_group","data","timestamp","id","updateRateData_groups","updateRateData_groupsIndex","getUpdateRateDataStats","_step","sumEstimateTime","sumEstimateTimeSquared","sumTimestamp","sumTimestampSquared","dataLength","_iterator","_createForOfIteratorHelper","s","n","done","item","value","estimateTime","Math","pow","err","e","f","_step2","averageEstimateTime","averageTimestamp","estimateTimeVariance","timestampVariance","estimateTimeSTDEV","sqrt","timestampSTDEV","covariance","_iterator2","item2","estimate_time","average","stdev","length","correlation","mergeUpdateRateDataStats","targetStats","sourceStats","mergedDataLength","mergedAverageEstimateTime","mergedAverageTimestamp","mergeStandardDeviation","mergePearsonCorrelation","collectUpdateRateData","_x","_collectUpdateRateData","apply","arguments","_asyncToGenerator","EstimateTime","currentTimestamp","Date","getTime","needToReset","generateIdentifier","EstimateTimeLength1","i","randomItem","floor","random","push","StopID","_step3","_iterator3","stopID","stopKey","indexOf","hasOwnProperty","parseInt","lfSetItem","JSON","stringify","_step4","_iterator4","dataGroup","existingData","lfGetItem","existingDataObject","parse","stats","existingIndex","splice","lfRemoveItem","recoverUpdateRateDataFromWriteAheadLog","_recoverUpdateRateDataFromWriteAheadLog","_step5","oneWeekAgo","_iterator5","lfListItemKeys","key","json","object","thisTimestamp","thisID","thisStopData","split","initializeUpdateRateDataGroups","_initializeUpdateRateDataGroups","_step6","index","_iterator6","discardExpiredUpdateRateDataGroups","_discardExpiredUpdateRateDataGroups","_step7","_iterator7","port","getUpdateRateWorkerResponses","SharedWorker","getUpdateRateSharedWorker","URL","start","getUpdateRateWorker","Worker","getUpdateRate","_getUpdateRate","dataGroups","filter","taskID","Promise","resolve","reject","onerror","message","postMessage","onmessage","_e$data","_slicedToArray","result","getBusArrivalTimeDataStatsPort","busArrivalTimeData_writeAheadLog_id","busArrivalTimeData_writeAheadLog_tracking","busArrivalTimeData_trackedStops","busArrivalTimeData_writeAheadLog_group","busArrivalTimeData_writeAheadLog_currentDataLength","getBusArrivalTimeDataStatsWorkerTasks","getBusArrivalTimeDataStatsWorker","getBusArrivalTimeDataStats","_getBusArrivalTimeDataStats","mergeBusArrivalTimeDataStats","mergedArray","Uint32Array","Array","from","collectBusArrivalTimeData","_x2","_collectBusArrivalTimeData","now","currentDay","getDay","allFolderContent","listAllFolderContent","map","isInPersonalSchedule","newStats","mergedStats","mergedExtrema","findGlobalExtrema","min","max","day","newExtrema","recoverBusArrivalTimeDataFromWriteAheadLog","_recoverBusArrivalTimeDataFromWriteAheadLog","newExtremum","_listBusArrivalTimeDataGroups","getBusArrivalTimesPort","getBusArrivalTimesWorkerResponses","getBusArrivalTimes","_x3","_x4","_getBusArrivalTimes","chartWidth","chartHeight","personalSchedules","listPersonalSchedules","busArrivalTimeDataGroups","listBusArrivalTimeDataGroups","_e$data2","recordDataUsage","_recordDataUsage","contentLength","date","dateToString","getHours","getMinutes","existingDataUsageStatsChunkJSON","existingDataUsageStatsChunkObject","sum","changedData","newDataUsageStatsChunk","getFullYear","getMonth","getDate","_listDataUsageStatsChunks","endDate","setHours","setMinutes","setSeconds","setMilliseconds","startDate","offsetDate","blankDataUsageStatsChunk","discardExpiredDataUsageStats","_discardExpiredDataUsageStats","createDateObjectFromDate","millisecondsPerDay","getDataUsageStats","_x5","_getDataUsageStats","width","height","padding","worker","dataUsageStatsChunks","listDataUsageStatsChunks","terminate"],"ignoreList":[],"sourceRoot":""}