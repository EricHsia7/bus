{"version":3,"file":"425.103f6e98.js","mappings":"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","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/webpack/runtime/chunk loaded","webpack://bus/webpack/runtime/startup chunk dependencies","webpack://bus/./src/tools/path.ts","webpack://bus/./src/tools/time.ts","webpack://bus/./src/data/storage/index.ts","webpack://bus/./src/data/analytics/data-usage/getDataUsageStats-worker.ts","webpack://bus/./src/tools/math.ts","webpack://bus/webpack/bootstrap","webpack://bus/webpack/runtime/define property getters","webpack://bus/webpack/runtime/ensure chunk","webpack://bus/webpack/runtime/get javascript chunk filename","webpack://bus/webpack/runtime/get mini-css chunk filename","webpack://bus/webpack/runtime/global","webpack://bus/webpack/runtime/hasOwnProperty shorthand","webpack://bus/webpack/runtime/publicPath","webpack://bus/webpack/runtime/importScripts chunk loading","webpack://bus/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(453),\n\t\t__webpack_require__.e(790)\n\t]).then(next);\n};","export type Segment = [x: number, y: number];\n\nexport type Segments = Array<Segment>;\n\nfunction distanceToSegment(point: Segment, start: Segment, end: Segment): number {\n  let dx = end[0] - start[0];\n  let dy = end[1] - start[1];\n  const d = dx * dx + dy * dy;\n  const t = ((point[0] - start[0]) * dx + (point[1] - start[1]) * dy) / d;\n\n  if (t < 0) {\n    dx = point[0] - start[0];\n    dy = point[1] - start[1];\n  } else if (t > 1) {\n    dx = point[0] - end[0];\n    dy = point[1] - end[1];\n  } else {\n    const closestPoint = [start[0] + t * dx, start[1] + t * dy];\n    dx = point[0] - closestPoint[0];\n    dy = point[1] - closestPoint[1];\n  }\n\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function simplifyPath(points: Segments, tolerance: number): Segments {\n const length1 = points.length - 1;\n  if (length1 < 2) {\n    return points;\n  }\n\n  let dmax = 0;\n  let index = 0;\n\n  // Find the point with the maximum distance\n  for (let i = 1; i < length1; i++) {\n    const d = distanceToSegment(points[i], points[0], points[length1]);\n    if (d > dmax) {\n      index = i;\n      dmax = d;\n    }\n  }\n\n  // If max distance is greater than tolerance, split the curve\n  if (dmax > tolerance) {\n    const leftPoints = points.slice(0, index + 1);\n    const rightPoints = points.slice(index);\n    const simplifiedLeft = simplifyPath(leftPoints, tolerance);\n    const simplifiedRight = simplifyPath(rightPoints, tolerance);\n    simplifiedLeft.pop();\n    return simplifiedLeft.concat(simplifiedRight);\n  } else {\n    return [points[0], points[length1]];\n  }\n}\n\nexport function segmentsToPath(segments: Segments): string {\n  const segmentsLength1 = segments.length - 1;\n  if (segmentsLength1 < 0) {\n    return '';\n  }\n  const pathCommand = [`M${segments[0][0]} ${segments[0][1]}`];\n  for (let i = 1; i < segmentsLength1; i++) {\n    const current = segments[i];\n    const next = segments[i + 1] || current;\n    pathCommand.push(`Q${current[0]} ${current[1]} ${(current[0] + next[0]) / 2} ${(current[1] + next[1]) / 2}`);\n  }\n  const lastPoint = segments[segmentsLength1];\n  pathCommand.push(`L${lastPoint[0]} ${lastPoint[1]}`);\n  return pathCommand.join(' ');\n}\n","export function getThisWeekOrigin(): Date {\n  const today: Date = new Date();\n  const dayOfToday: number = today.getDay();\n  const originDate: number = today.getDate() - dayOfToday;\n  const origin: Date = new Date();\n  origin.setDate(originDate);\n  origin.setHours(0);\n  origin.setMinutes(0);\n  origin.setSeconds(0);\n  origin.setMilliseconds(0);\n  return origin;\n}\n\nexport function offsetDate(origin: Date, date: number, hours: number, minutes: number): Date {\n  const duplicatedOrigin = new Date();\n  duplicatedOrigin.setDate(1);\n  duplicatedOrigin.setMonth(0);\n  duplicatedOrigin.setHours(hours);\n  duplicatedOrigin.setMinutes(minutes);\n  duplicatedOrigin.setSeconds(0);\n  duplicatedOrigin.setMilliseconds(0);\n  duplicatedOrigin.setFullYear(origin.getFullYear());\n  duplicatedOrigin.setMonth(origin.getMonth());\n  duplicatedOrigin.setDate(origin.getDate());\n  duplicatedOrigin.setDate(duplicatedOrigin.getDate() + date);\n  return duplicatedOrigin;\n}\n\nexport function timeStampToNumber(string: string): number {\n  const regex = /[0-9\\.]*/gm;\n  const match = string.match(regex);\n  if (match) {\n    const year = parseInt(match[0]);\n    const month = parseInt(match[2]);\n    const date = parseInt(match[4]);\n    const hours = parseInt(match[6]);\n    const minutes = parseInt(match[8]);\n    const seconds = parseInt(match[10]);\n    const date_object = new Date();\n    date_object.setDate(1);\n    date_object.setMonth(0);\n    date_object.setFullYear(year);\n    date_object.setMonth(month - 1);\n    date_object.setDate(date);\n    date_object.setHours(hours);\n    date_object.setMinutes(minutes);\n    date_object.setSeconds(seconds);\n    return date_object.getTime();\n  }\n  return 0;\n}\n\nexport function dateToString(date: Date, template: string = 'YYYY-MM-DD hh:mm:ss'): string {\n  const result = template\n    .replaceAll(/Y{4,4}/g, date.getFullYear())\n    .replaceAll(/M{2,2}/g, String(date.getMonth() + 1).padStart(2, '0'))\n    .replaceAll(/D{2,2}/g, String(date.getDate()).padStart(2, '0'))\n    .replaceAll(/h{2,2}/g, String(date.getHours()).padStart(2, '0'))\n    .replaceAll(/m{2,2}/g, String(date.getMinutes()).padStart(2, '0'))\n    .replaceAll(/s{2,2}/g, String(date.getSeconds()).padStart(2, '0'));\n  return result;\n}\n\nexport function dateToRelativeTime(date: Date): string {\n  const time = date.getTime();\n  const seconds = Math.floor((new Date().getTime() - time) / 1000);\n  let interval = Math.floor(seconds / 31536000); // seconds in a year\n  if (interval >= 1) {\n    return `${interval}年前`;\n  }\n  interval = Math.floor(seconds / 2592000); // seconds in a month\n  if (interval >= 1) {\n    return `${interval}個月前`;\n  }\n  interval = Math.floor(seconds / 86400); // seconds in a day\n  if (interval >= 1) {\n    return `${interval}天前`;\n  }\n  interval = Math.floor(seconds / 3600); // seconds in an hour\n  if (interval >= 1) {\n    return `${interval}小時前`;\n  }\n  interval = Math.floor(seconds / 60); // seconds in a minute\n  if (interval >= 1) {\n    return `${interval}分鐘前`;\n  }\n  if (seconds > 0) {\n    return `${seconds}秒前`;\n  }\n  return '現在';\n}\n\nexport function formatTime(time: number, mode: number): string {\n  const roundedTime = time | 0;\n  switch (mode) {\n    case 0: {\n      return `${roundedTime}秒`;\n      break;\n    }\n    case 1: {\n      const minutes = String((roundedTime - (roundedTime % 60)) / 60);\n      const seconds = String(roundedTime % 60);\n      return [minutes, seconds].map((u) => u.padStart(2, '0')).join(':');\n      break;\n    }\n    case 2: {\n      const minutes = (roundedTime / 60) | 0;\n      return `${minutes}分`;\n      break;\n    }\n    case 3: {\n      if (roundedTime >= 60 * 60) {\n        const hours = parseFloat((roundedTime / (60 * 60)).toFixed(1));\n        return `${hours}時`;\n      }\n      if (60 <= roundedTime && roundedTime < 60 * 60) {\n        const minutes = (roundedTime / 60) | 0;\n        return `${minutes}分`;\n      }\n      if (roundedTime < 60) {\n        return `${roundedTime}秒`;\n      }\n      break;\n    }\n    default: {\n      return '--';\n      break;\n    }\n  }\n}\n\nexport type WeekDayIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n// 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, 4: Thursday, 5: Friday, 6: Saturday\n\nexport type WeekDayIndexArray = Array<WeekDayIndex>;\n\nexport type WeekDayName = '日' | '一' | '二' | '三' | '四' | '五' | '六';\n\nexport interface WeekDay {\n  name: WeekDayName;\n  day: WeekDayIndex;\n  code: string;\n}\n\nexport function indexToDay(index: WeekDayIndex): WeekDay {\n  const days = [\n    {\n      name: '日',\n      day: 0,\n      code: 'd_0'\n    },\n    {\n      name: '一',\n      day: 1,\n      code: 'd_1'\n    },\n    {\n      name: '二',\n      day: 2,\n      code: 'd_2'\n    },\n    {\n      name: '三',\n      day: 3,\n      code: 'd_3'\n    },\n    {\n      name: '四',\n      day: 4,\n      code: 'd_4'\n    },\n    {\n      name: '五',\n      day: 5,\n      code: 'd_5'\n    },\n    {\n      name: '六',\n      day: 6,\n      code: 'd_6'\n    }\n  ];\n  return days[index];\n}\n\nexport function dateValueToDayOfWeek(dateValue: string): WeekDay {\n  const int = parseInt(dateValue);\n  const index = int - 1;\n  return indexToDay(index);\n}\n\nexport interface TimeObject {\n  hours: number;\n  minutes: number;\n}\n\nexport interface TimePeriod {\n  start: TimeObject;\n  end: TimeObject;\n}\n\nexport interface TimeStampPeriod {\n  start: Date;\n  end: Date;\n}\n\nexport function timeObjectToString(timeObject: TimeObject): string {\n  return `${String(timeObject.hours).padStart(2, '0')}:${String(timeObject.minutes).padStart(2, '0')}`;\n}\n\nexport function createDateObjectFromDate(year: number, month: number, date: number): Date {\n  const dateObject = new Date();\n  dateObject.setDate(1); // Set to the first day of the month to prevent date from being clamped\n  dateObject.setMonth(0);\n  dateObject.setFullYear(year);\n  dateObject.setMonth(month - 1);\n  dateObject.setDate(date);\n  dateObject.setHours(0);\n  dateObject.setMinutes(0);\n  dateObject.setSeconds(0);\n  dateObject.setMilliseconds(0);\n  return dateObject;\n}\n\nexport function maxConcurrency(periods: Array<TimePeriod>): number {\n  let events: Array<[number, 1 | -1]> = [];\n\n  // Convert periods into events\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, 1]); // Start of a period\n    events.push([end.hours * 60 + end.minutes, -1]); // End of a period\n  }\n\n  // Sort events: Primary by time, secondary by type (-1 before +1)\n  events.sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]));\n\n  let maxCount = 0;\n  let currentCount = 0;\n\n  // Sweep through the events\n  for (let [, type] of events) {\n    currentCount += type;\n    maxCount = Math.max(maxCount, currentCount);\n  }\n\n  return maxCount;\n}\n\nexport function assignTracks(periods: Array<TimePeriod>): Array<Array<TimePeriod>> {\n  if (periods.length === 0) return [];\n\n  // Convert periods into events\n  let events: Array<[number, number, number]> = [];\n  let index = 0;\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, end.hours * 60 + end.minutes, index]);\n    index += 1;\n  }\n\n  // Sort intervals by start time\n  events.sort((a, b) => a[0] - b[0]);\n\n  let tracks = [];\n  for (let [start, end, index] of events) {\n    let assigned = false;\n    for (let i = 0; i < tracks.length; i++) {\n      if (tracks[i][tracks[i].length - 1][1] <= start) {\n        tracks[i].push([start, end, index]);\n        assigned = true;\n        break;\n      }\n    }\n    if (!assigned) {\n      tracks.push([[start, end, index]]);\n    }\n  }\n\n  let i = 0;\n  for (const track of tracks) {\n    let j = 0;\n    for (const event of track) {\n      tracks[i][j] = periods[event[2]];\n      j += 1;\n    }\n    i += 1;\n  }\n\n  return tracks;\n}\n","const localforage = require('localforage');\n\nlet storage = {\n  cacheStore: false, // 0\n  settingsStore: false, // 1\n  dataUsageStatsStore: false, // 2\n  updateRateDataStore: false, // 3\n  updateRateDataWriteAheadLogStore: false, // 4\n  busArrivalTimeDataWriteAheadLogStore: false, // 5\n  busArrivalTimeDataStore: false, // 6\n  personalScheduleStore: false, // 7\n  recentViewsStore: false, // 8\n  notificationStore: false, // 9\n  notificationScheduleStore: false, // 10\n  folderListStore: false, // 11\n  folderContentIndexStore: false, // 12\n  folderContentStore: false // 13\n};\n\nconst stores = ['cacheStore', 'settingsStore', 'dataUsageStatsStore', 'updateRateDataStore', 'updateRateDataWriteAheadLogStore', 'busArrivalTimeDataWriteAheadLogStore', 'busArrivalTimeDataStore', 'personalScheduleStore', 'recentViewsStore', 'notificationStore', 'notificationScheduleStore', 'folderListStore', 'folderContentIndexStore', 'folderContentStore'];\n\nasync function dropInstance(store: number): Promise<any> {\n  const storeKey = stores[store];\n  if (storage[storeKey] === false) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n  }\n  const operation = await storage[storeKey].dropInstance();\n  return operation;\n}\n\nexport async function lfSetItem(store: number, key: string, value: any): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].setItem(key, value);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfGetItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].getItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfRemoveItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].removeItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfListItemKeys(store: number): Promise<Array<string>> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const keys = await storage[storeKey].keys();\n    return keys;\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n}\n\nexport function getStoreKey(store: number): string {\n  return stores[store];\n}\n\nexport function getStoresLength(): number {\n  return stores.length;\n}\n\n/*\nexport async function registerStore(id: string): Promise<number> {\n  const storeKey = `F${id}Store`;\n  if (!storage.hasOwnProperty(storeKey) && stores.indexOf(storeKey) < 0) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n    stores.push(storeKey);\n    return stores.length - 1;\n  } else {\n    return stores.indexOf(storeKey);\n  }\n}\n*/\n\nexport async function isStoragePersistent(): Promise<boolean> {\n  // Check if site's storage has been marked as persistent\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persisted();\n      return isPersisted;\n    }\n  }\n  return false;\n}\n\nexport async function askForPersistentStorage(): Promise<'granted' | 'denied' | 'unsupported'> {\n  // Request persistent storage for site\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persist();\n      return isPersisted ? 'granted' : 'denied';\n    }\n  }\n  return 'unsupported';\n}\n","import { findGlobalExtremum } from '../../../tools/math';\nimport { Segments, segmentsToPath, simplifyPath } from '../../../tools/path';\nimport { createDateObjectFromDate } from '../../../tools/time';\nimport { DataUsagePeriod, DataUsageStats, DataUsageStatsChunkArray } from './index';\n\nself.onmessage = function (e) {\n  const result = processWorkerTask(e.data);\n  self.postMessage(result); // Send the result back to the main thread\n};\n\ntype data = [dataUsageStatsChunks: DataUsageStatsChunkArray, width: number, height: number, padding: number];\n\nconst minutesPerDay = 60 * 24;\n\n// Main processing function\nfunction processWorkerTask(data: data): DataUsageStats {\n  const [dataUsageStatsChunks, width, height, padding] = data;\n\n  const dataUsageStatsChunksLength = dataUsageStatsChunks.length;\n\n  const extrema: Array<number> = [];\n  let sum: number = 0;\n  for (const dataUsageStatsChunk of dataUsageStatsChunks) {\n    extrema.push(dataUsageStatsChunk.stats.max, dataUsageStatsChunk.stats.min);\n    sum += dataUsageStatsChunk.stats.sum;\n  }\n\n  const globalExtremum = findGlobalExtremum(extrema);\n  const max = globalExtremum[1] === 0 ? 1 : globalExtremum[1]; // prevent division by zero\n  const min = globalExtremum[0] === 0 ? 1 : globalExtremum[0]; // prevent division by zero\n\n  const start = dataUsageStatsChunks[0].date;\n  const end = dataUsageStatsChunks[dataUsageStatsChunksLength - 1].date;\n  const startDate = createDateObjectFromDate(start[0], start[1], start[2]);\n  const endDate = createDateObjectFromDate(end[0], end[1], end[2]);\n\n  const points: Segments = [];\n  let cumulative: number = 0;\n  let lastX: number = 0;\n  for (let i = 0; i < dataUsageStatsChunksLength; i++) {\n    const dataUsageStatsChunk = dataUsageStatsChunks[i];\n    if (dataUsageStatsChunk.stats.sum === 0) {\n      const x1 = padding + (i / (DataUsagePeriod + 1)) * width;\n      const x2 = padding + ((i + (minutesPerDay - 1) / minutesPerDay) / (DataUsagePeriod + 1)) * width;\n      const y = padding + height;\n      points.push([x1, y]);\n      points.push([x2, y]);\n      lastX = x2;\n      continue;\n    }\n    const data = dataUsageStatsChunk.data;\n    for (let j = 0; j < minutesPerDay; j++) {\n      cumulative += data[j];\n      const x = padding + ((i + j / minutesPerDay) / (DataUsagePeriod + 1)) * width;\n      const y = padding + (1 - cumulative / sum) * height;\n      points.push([x, y]);\n      lastX = x;\n    }\n  }\n\n  // X-axis (horizontal)\n  const xAxis = `<line x1=\"${padding}\" y1=\"${height + padding}\" x2=\"${padding + width}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Y-axis (vertical)\n  const yAxis = `<line x1=\"${padding}\" y1=\"${padding}\" x2=\"${padding}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Axis Labels\n  const xAxisLabel = `<text x=\"${padding + width / 2}\" y=\"${padding + height + padding}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\">時間</text>`;\n  const yAxisLabel = `<text x=\"${padding / 2}\" y=\"${padding + height / 2}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\" transform=\"rotate(-90, ${padding * 0.7}, ${padding + height / 2})\">累計傳輸量</text>`;\n\n  // Paths\n  const simplifiedPath = simplifyPath(points, 1.1);\n  const pathData = segmentsToPath(simplifiedPath);\n  const fillingPathData = `M${padding},${height + padding} ${pathData} L${lastX},${height + padding} L${padding},${height + padding}`;\n  const path = `<path d=\"${pathData}\" fill=\"none\" stroke=\"var(--b-cssvar-main-color)\" stroke-width=\"0.9\" stroke-linecap=\"round\" stroke-linejoin=\"round\" opacity=\"1\"></path>`;\n  const fillingPath = `<path d=\"${fillingPathData}\" stroke=\"none\" stroke-width=\"0\" fill=\"url(#grad1)\"></path>`;\n  const filling = `<linearGradient id=\"grad1\" x1=\"50%\" y1=\"0%\" x2=\"50%\" y2=\"100%\"><stop offset=\"0%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.3);\" /><stop offset=\"73%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.09);\" /><stop offset=\"100%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0);\" /></linearGradient>`;\n\n  // SVG\n  const chart = /*html*/ `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width + padding * 2} ${height + padding * 2}\"><defs>${filling}</defs>${fillingPath}${path}${xAxis}${yAxis}${xAxisLabel}${yAxisLabel}</svg>`;\n\n  const result: DataUsageStats = {\n    stats: {\n      max,\n      min,\n      sum\n    },\n    period: {\n      start: startDate,\n      end: endDate\n    },\n    chart\n  };\n\n  // Send the result back to the main thread\n  return result;\n}\n","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\n/**\n * get the unit vecotr towards the same direction\n * @param vector [a1, a2, a3, ...]\n * @returns [b1, b2, b3, ...]\n */\n\nexport function normalizeVector(vector: Array<number>): Array<number> {\n  const length = Math.hypot(vector);\n  const componentQuantity = vector.length;\n  const newVector = new Float32Array(componentQuantity);\n  if (length > 0) {\n    const scale = 1 / length;\n    for (let i = componentQuantity; i > 0; i--) {\n      newVector[i] = vector[i] * scale;\n    }\n    return Array.from(newVector);\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function findGlobalExtremum(array: Array<number>): [minimum: number, maximum: number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [453,790], () => (__webpack_require__(7425)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames not based on template\n\tif (chunkId === 425) return \"425.103f6e98.js\";\n\t// return url for filenames based on template\n\treturn \"\" + {\"453\":\"eab3f90e\",\"790\":\"eaf3a719\"}[chunkId] + \".js\";\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"./\";","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t425: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkbus\"] = self[\"webpackChunkbus\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["root","factory","exports","module","define","amd","self","deferred","next","distanceToSegment","point","start","end","dx","dy","d","t","closestPoint","Math","sqrt","simplifyPath","points","tolerance","length1","length","dmax","index","i","leftPoints","slice","rightPoints","simplifiedLeft","simplifiedRight","pop","concat","createDateObjectFromDate","year","month","date","dateObject","Date","setDate","setMonth","setFullYear","setHours","setMinutes","setSeconds","setMilliseconds","require","onmessage","e","result","data","_step","_data","_slicedToArray","dataUsageStatsChunks","width","height","padding","dataUsageStatsChunksLength","extrema","sum","_iterator","_createForOfIteratorHelper","s","n","done","dataUsageStatsChunk","value","push","stats","max","min","err","f","globalExtremum","array","arrayLength","Infinity","item","findGlobalExtremum","startDate","endDate","cumulative","lastX","j","minutesPerDay","x","y","x1","x2","xAxis","yAxis","xAxisLabel","yAxisLabel","pathData","segments","segmentsLength1","pathCommand","current","lastPoint","join","segmentsToPath","period","chart","processWorkerTask","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","m","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","fulfilled","Object","keys","every","key","splice","r","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","call","p","b","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"ignoreList":[],"sourceRoot":""}