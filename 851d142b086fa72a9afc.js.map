{"version":3,"file":"851d142b086fa72a9afc.js","mappings":"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","sources":["webpack://bus/./src/data/notification/apis/cancelNotification/index.ts","webpack://bus/./src/data/notification/apis/loader.ts","webpack://bus/./src/data/location/index.ts","webpack://bus/./src/data/notification/apis/registerNotificationClient/index.ts","webpack://bus/./src/data/notification/apis/getNotificationAPIURL/index.ts","webpack://bus/./src/data/location/details.ts","webpack://bus/./src/data/notification/apis/rotateNotificationSecret/index.ts","webpack://bus/./src/data/notification/apis/scheduleNotification/index.ts","webpack://bus/./src/data/notification/apis/getNotificationRequestBody/index.ts"],"sourcesContent":["import { NotificationClientID, NotificationSchedule, NotificationSecret, removeNotificationSchedule } from '../../index';\nimport { getNotificationAPIURL } from '../getNotificationAPIURL/index';\nimport { getNotificationRequestBody } from '../getNotificationRequestBody/index';\nimport { makeNotificationRequest } from '../loader';\n\nexport async function cancelNotification(schedule_id: NotificationSchedule['schedule_id']): Promise<boolean> {\n  if (NotificationClientID === '' || NotificationSecret === '' || schedule_id === undefined) {\n    return false;\n  }\n  const url = getNotificationAPIURL('cancel', [schedule_id]);\n  const requestBody = getNotificationRequestBody('cancel', [schedule_id]);\n  const response = await makeNotificationRequest('cancel', url, requestBody);\n  if (response === false) {\n    return false;\n  } else {\n    if (response.code === 200 && response.method === 'cancel') {\n      await removeNotificationSchedule(schedule_id);\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","type NotificationResponseCode = 200 | 400 | 401 | 404 | 500;\n\ninterface NotificationResponseCancel {\n  result: string;\n  code: NotificationResponseCode;\n  method: 'cancel';\n}\n\ninterface NotificationResponseRegister {\n  result: string;\n  code: NotificationResponseCode;\n  method: 'register';\n  client_id: string | 'null';\n  secret: string | 'null';\n}\n\ninterface NotificationResponseSchedule {\n  result: string;\n  code: NotificationResponseCode;\n  method: 'schedule';\n  schedule_id: string | 'null';\n}\n\ninterface NotificationResponseRotate {\n  result: string;\n  code: NotificationResponseCode;\n  method: 'rotate';\n  secret: string | 'null';\n}\n\ninterface NotificationResponseReschedule {\n  result: string;\n  code: NotificationResponseCode;\n  method: 'reschedule';\n}\n\nexport type NotificationResponse = NotificationResponseCancel | NotificationResponseRegister | NotificationResponseSchedule | NotificationResponseRotate | NotificationResponseReschedule;\n\nexport async function makeNotificationRequest(method: NotificationResponse['method'], url: string | false, body: object | false): Promise<NotificationResponse | false> {\n  try {\n    if (url === false || body === false) {\n      return false;\n    }\n\n    const requestOptions = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(body)\n    };\n\n    // Send the request\n    const response = await fetch(url, requestOptions);\n\n    if (!response.ok) {\n      // Log additional details for debugging\n      const errorText = await response.text();\n      console.error('API request failed', {\n        status: response.status,\n        statusText: response.statusText,\n        body: errorText\n      });\n      return false;\n    }\n\n    // Attempt to parse the JSON response\n    try {\n      const text = await response.text();\n      const json = JSON.parse(text);\n      switch (method) {\n        case 'cancel':\n          return json as NotificationResponseCancel;\n          break;\n        case 'register':\n          return json as NotificationResponseRegister;\n          break;\n        case 'schedule':\n          return json as NotificationResponseSchedule;\n          break;\n        case 'rotate':\n          return json as NotificationResponseRotate;\n          break;\n        case 'reschedule':\n          return json as NotificationResponseReschedule;\n          break;\n        default:\n          return false;\n          break;\n      }\n    } catch (jsonError) {\n      console.error('Failed to parse JSON response', jsonError);\n      throw new Error('Invalid JSON response from server');\n    }\n  } catch (error) {\n    // Catch and log errors\n    console.error('Error making request:', error);\n    return false;\n  }\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { addressToString, generateLabelFromAddresses } from '../../tools/address';\nimport { CardinalDirection, getCardinalDirectionFromVector } from '../../tools/cardinal-direction';\nimport { generateDirectionLabels, generateLetterLabels } from '../../tools/labels';\nimport { normalizeVector } from '../../tools/math';\nimport { BusArrivalTime, getBusArrivalTimes } from '../analytics/bus-arrival-time/index';\nimport { getBusData } from '../apis/getBusData/index';\nimport { getBusEvent } from '../apis/getBusEvent/index';\nimport { EstimateTime, EstimateTimeItem, getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, MergedLocation } from '../apis/getLocation/index';\nimport { getRoute, SimplifiedRoute } from '../apis/getRoute/index';\nimport { getStop } from '../apis/getStop/index';\nimport { batchFindBusesForLocation, EstimateTimeStatus, formatBus, FormattedBus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue } from '../settings/index';\nimport { getUserOrientation } from '../user-orientation/index';\n\ninterface BatchFoundEstimateTimeItem extends EstimateTimeItem {}\n\ntype BatchFoundEstimateTime = {\n  [key: string]: BatchFoundEstimateTimeItem;\n};\n\nfunction batchFindEstimateTime(EstimateTime: EstimateTime, StopIDList: Array<number>): BatchFoundEstimateTime {\n  const result = {};\n  for (const item of EstimateTime) {\n    if (StopIDList.indexOf(item.StopID) > -1) {\n      const thisStopKey: string = `s_${item.StopID}`;\n      result[thisStopKey] = item;\n    }\n  }\n  return result;\n}\n\ntype BatchFoundEstimateTimeRanking = {\n  [key: string]: IntegratedLocationItemRanking;\n};\n\nfunction rankBatchFoundEstimateTime(batchFoundEstimateTime: BatchFoundEstimateTime, StopIDList: Array<number>): BatchFoundEstimateTimeRanking {\n  // StopIDList act as a secondary filter\n  const result: BatchFoundEstimateTimeRanking = {};\n  const rankingArray: Array<[number, number]> = []; // StopID, EstimateTime\n  for (const thisStopKey in batchFoundEstimateTime) {\n    const thisBatchFoundEstimateTimeItem = batchFoundEstimateTime[thisStopKey];\n    const thisStopID = thisBatchFoundEstimateTimeItem.StopID;\n    const thisEstimateTime = parseInt(thisBatchFoundEstimateTimeItem.EstimateTime);\n    if (thisEstimateTime >= 0 && StopIDList.indexOf(thisStopID) > -1) {\n      rankingArray.push([thisStopID, thisEstimateTime]);\n    }\n  }\n  const rankingArrayLength = rankingArray.length;\n  rankingArray.sort(function (a, b) {\n    return a[1] - b[1];\n  });\n  let index = 1;\n  for (const rankingItem of rankingArray) {\n    // Classify into 4 groups and give a code\n    const rankingRatio = index / rankingArrayLength;\n    const rankingCode = (rankingRatio - (rankingRatio % 0.25)) / 0.25;\n    const thisStopID = rankingItem[0];\n    const thisStopKey = `s_${thisStopID}`;\n    result[thisStopKey] = {\n      number: index,\n      text: index.toString(),\n      code: rankingCode\n    };\n    index += 1;\n  }\n  return result;\n}\n\nexport interface LocationGroupProperty {\n  key: string;\n  icon: MaterialSymbols;\n  value: string;\n}\n\nexport interface LocationGroup {\n  name: string;\n  properties: Array<LocationGroupProperty>;\n}\n\nexport interface IntegratedLocationItemRanking {\n  number: number;\n  text: '--' | string;\n  code: -1 | 0 | 1 | 2 | 3 | 4; // -1: not applicable, 0: 0-25%, 1: 25-50%, 2: 50-75%, 3: 75-100%, 4: 100%\n}\n\nexport interface IntegratedLocationItem {\n  route_name: string;\n  route_direction: string;\n  routeId: number;\n  stopId: number;\n  status: EstimateTimeStatus;\n  ranking: IntegratedLocationItemRanking;\n  buses: Array<FormattedBus>;\n  busArrivalTimes: Array<BusArrivalTime>;\n}\n\nexport interface IntegratedLocation {\n  groupedItems: {\n    [g_index: string]: Array<IntegratedLocationItem>;\n  };\n  groups: {\n    [g_index: string]: LocationGroup;\n  };\n  groupQuantity: number;\n  itemQuantity: {\n    [g_index: string]: number;\n  };\n  LocationName: string;\n  dataUpdateTime: number;\n  hash: string;\n}\n\nexport async function integrateLocation(hash: string, chartWidth: number, chartHeight: number, requestID: string): Promise<IntegratedLocation> {\n  setDataReceivingProgress(requestID, 'getLocation_0', 0, false);\n  setDataReceivingProgress(requestID, 'getLocation_1', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_0', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_1', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_0', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_1', 0, false);\n  const EstimateTime = await getEstimateTime(requestID);\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  const Stop = await getStop(requestID);\n  const BusEvent = await getBusEvent(requestID);\n  const BusData = await getBusData(requestID);\n  const BusArrivalTimes = await getBusArrivalTimes(chartWidth, chartHeight);\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode');\n  const location_labels = getSettingOptionValue('location_labels');\n  const display_user_orientation = getSettingOptionValue('display_user_orientation');\n\n  const groupedItems = {} as IntegratedLocation['groupedItems'];\n  const itemQuantity = {} as IntegratedLocation['itemQuantity'];\n  const groups = {} as IntegratedLocation['groups'];\n\n  const userOrientation = getUserOrientation();\n\n  const thisLocationKey = `ml_${hash}`;\n  const thisLocation = Location[thisLocationKey];\n  const thisLocationName = thisLocation.n;\n  const stopLocationIds = thisLocation.id;\n  const setsOfVectors = thisLocation.v;\n\n  let StopIDs = [];\n  let RouteIDs = [];\n  const stopLocationQuantity = stopLocationIds.length;\n\n  for (let i = 0; i < stopLocationQuantity; i++) {\n    StopIDs = StopIDs.concat(thisLocation.s[i]);\n    RouteIDs = RouteIDs.concat(thisLocation.r[i]);\n  }\n\n  const batchFoundEstimateTime = batchFindEstimateTime(EstimateTime, StopIDs);\n  const batchFoundBuses = batchFindBusesForLocation(BusEvent, BusData, Route, StopIDs);\n\n  const cardinalDirections: Array<CardinalDirection> = [];\n  for (const vectorSet of setsOfVectors) {\n    let x: number = 0;\n    let y: number = 0;\n    for (const vector of vectorSet) {\n      x += vector[0];\n      y += vector[1];\n    }\n    const meanVector = normalizeVector([x, y]);\n    const cardinalDirection = getCardinalDirectionFromVector(meanVector);\n    cardinalDirections.push(cardinalDirection);\n  }\n\n  let labels: Array<string> = [];\n  switch (location_labels) {\n    case 'address':\n      labels = generateLabelFromAddresses(thisLocation.a);\n      break;\n    case 'letters':\n      labels = generateLetterLabels(stopLocationQuantity);\n      break;\n    case 'directions':\n      labels = generateDirectionLabels(cardinalDirections);\n      break;\n    default:\n      break;\n  }\n\n  for (let i = 0; i < stopLocationQuantity; i++) {\n    const groupKey = `g_${i}`;\n    groupedItems[groupKey] = [];\n    itemQuantity[groupKey] = 0;\n    groups[groupKey] = {\n      name: labels[i],\n      properties: [\n        {\n          key: 'address',\n          icon: 'personal_places',\n          value: addressToString(thisLocation.a[i])\n        },\n        {\n          key: 'exact_position',\n          icon: 'location_on',\n          value: `${thisLocation.la[i].toFixed(5)}, ${thisLocation.lo[i].toFixed(5)}`\n        },\n        {\n          key: 'cardinal_direction',\n          icon: cardinalDirections[i].icon,\n          value: `${cardinalDirections[i].name}${display_user_orientation && userOrientation.cardinalDirection.id !== -1 && userOrientation.cardinalDirection.id === cardinalDirections[i].id ? '（目前指向）' : ''}`\n        }\n      ]\n    };\n\n    const thisGroupStops = thisLocation.s[i];\n    const stopQuantity = thisGroupStops.length;\n    const thisGroupRanking = rankBatchFoundEstimateTime(batchFoundEstimateTime, thisGroupStops);\n\n    for (let o = 0; o < stopQuantity; o++) {\n      const integratedItem = {} as IntegratedLocationItem;\n      // Collect data from 'Stop'\n      const thisStopID = thisLocation.s[i][o];\n      const thisStopKey = `s_${thisStopID}`;\n      let thisStop: SimplifiedStopItem = {};\n      if (Stop.hasOwnProperty(thisStopKey)) {\n        thisStop = Stop[thisStopKey];\n      } else {\n        continue;\n      }\n      integratedItem.stopId = thisStopID;\n\n      // Collect data from 'thisGroupRanking'\n      let thisItemRanking = { number: 0, text: '--', code: -1 } as IntegratedLocationItemRanking;\n      if (thisGroupRanking.hasOwnProperty(thisStopKey)) {\n        thisItemRanking = thisGroupRanking[thisStopKey];\n      }\n      integratedItem.ranking = thisItemRanking;\n\n      // Collect data from 'Route'\n      const thisRouteID: number = thisLocation.r[i][o];\n      const thisRouteKey = `r_${thisRouteID}`;\n      let thisRoute: SimplifiedRouteItem = {};\n      if (Route.hasOwnProperty(thisRouteKey)) {\n        thisRoute = Route[thisRouteKey];\n      } else {\n        continue;\n      }\n      integratedItem.route_name = thisRoute.n;\n      integratedItem.route_direction = `往${[thisRoute.des, thisRoute.dep, ''][parseInt(thisStop.goBack)]}`;\n      integratedItem.routeId = thisRouteID;\n\n      // Collect data from 'batchFoundEstimateTime'\n      let thisEstimateTime = {} as EstimateTimeItem;\n      if (batchFoundEstimateTime.hasOwnProperty(thisStopKey)) {\n        thisEstimateTime = batchFoundEstimateTime[thisStopKey];\n      } else {\n        continue;\n      }\n      const parsedEstimateTime = parseEstimateTime(thisEstimateTime.EstimateTime, time_formatting_mode);\n      integratedItem.status = parsedEstimateTime;\n\n      // Collect data from 'batchFoundBuses'\n      let buses = [];\n      if (batchFoundBuses.hasOwnProperty(thisStopKey)) {\n        buses = batchFoundBuses[thisStopKey].map((e) => formatBus(e));\n      }\n      integratedItem.buses = buses;\n\n      // Collect data from 'BusArrivalTimes'\n      let thisBusArrivalTimes = [];\n      if (BusArrivalTimes.hasOwnProperty(thisStopKey)) {\n        thisBusArrivalTimes = BusArrivalTimes[thisStopKey];\n      }\n      integratedItem.busArrivalTimes = thisBusArrivalTimes;\n\n      groupedItems[groupKey].push(integratedItem);\n      itemQuantity[groupKey] += 1;\n    }\n  }\n\n  for (const key in groupedItems) {\n    groupedItems[key].sort(function (a, b) {\n      return a.routeId - b.routeId;\n    });\n    /*\n      .map((item: IntegratedLocationItem) => {\n        // accessing ranking[key] inside map callback will cause constant violations any way\n        return {\n          route_name: item.route_name,\n          route_direction: item.route_direction,\n          routeId: item.routeId,\n          stopId: item.stopId,\n          status: item.status,\n          rank: {\n            number: thisRankingIndex + 1,\n            code: 0\n          },\n          buses: item.buses,\n          busArrivalTimes: item.busArrivalTimes\n        };\n      })*/\n  }\n  const result: IntegratedLocation = {\n    groupedItems: groupedItems,\n    groups: groups,\n    groupQuantity: stopLocationQuantity,\n    itemQuantity: itemQuantity,\n    LocationName: thisLocationName,\n    hash: hash,\n    dataUpdateTime: getDataUpdateTime(requestID)\n  };\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  //await recordEstimateTimeForUpdateRate(EstimateTime);\n  return result;\n}\n","import { saveNotificationClient, setNotificationClientID, setNotificationSecret } from '../..';\nimport { getNotificationAPIURL } from '../getNotificationAPIURL/index';\nimport { getNotificationRequestBody } from '../getNotificationRequestBody/index';\nimport { makeNotificationRequest } from '../loader';\n\nexport async function registerNotificationClient(registrationKey: string): Promise<boolean> {\n  if (!registrationKey) {\n    return false;\n  }\n  const url = getNotificationAPIURL('register');\n  const requestBody = getNotificationRequestBody('register', [registrationKey]);\n  const response = await makeNotificationRequest('register', url, requestBody);\n  if (response === false) {\n    return false;\n  } else {\n    if (response.code === 200 && response.method === 'register') {\n      setNotificationClientID(response.client_id)\n      setNotificationSecret(response.secret)\n      await saveNotificationClient();\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","import { NotificationProvider, NotificationResponse } from '../../index';\n\nexport function getNotificationAPIURL(method: NotificationResponse['method']): string | false {\n  if (NotificationProvider === '') {\n    return false;\n  }\n  const url = new URL(NotificationProvider);\n  if (['cancel', 'register', 'schedule', 'rotate', 'reschedule'].indexOf(method) > -1) {\n    url.searchParams.set('method', method);\n    return url.toString();\n  } else {\n    return false;\n  }\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { shareLocationPermalink, showLocationPermalinkQRCode } from '../../interface/location/details/index';\nimport { openSaveToFolder } from '../../interface/save-to-folder/index';\nimport { generateIdentifier } from '../../tools/index';\nimport { getLocation, MergedLocation, MergedLocationItem } from '../apis/getLocation/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime } from '../apis/loader';\n\nexport interface IntegratedLocationDetailsAction {\n  icon: MaterialSymbols;\n  action: Function;\n  key: string,\n  name: string;\n}\n\nexport type IntegratedLocationDetailsActionArray = Array<IntegratedLocationDetailsAction>;\n\nexport interface IntegratedLocationDetails {\n  actions: IntegratedLocationDetailsActionArray;\n  actionsQuantity: number\n  hash: string;\n}\n\nexport async function integrateLocationDetails(hash: string, requestID: string): Promise<IntegratedLocationDetails> {\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisLocationKey = `ml_${hash}`;\n  let thisLocation = {} as MergedLocationItem;\n  if (Location.hasOwnProperty(thisLocationKey)) {\n    thisLocation = Location[thisLocationKey];\n  } else {\n    return {\n      actions: [],\n      actionsQuantity: 0,\n      hash: hash\n    };\n  }\n  const actions: IntegratedLocationDetailsActionArray = [\n    {\n      icon: 'folder',\n      name: '儲存',\n      key: 'save-to-folder',\n      action: function () {\n        openSaveToFolder('location', [hash]);\n      }\n    },\n    {\n      icon: 'ios_share',\n      name: '分享',\n      key: 'permalink',\n      action: function () {\n        shareLocationPermalink(hash);\n      }\n    },\n    {\n      icon: 'qr_code_2',\n      name: '二維條碼',\n      key: 'permalink-qr-code',\n      action: function () {\n        showLocationPermalinkQRCode(hash);\n      }\n    }\n  ];\n  const result: IntegratedLocationDetails = {\n    actions: actions,\n    actionsQuantity: actions.length,\n    hash: hash\n  };\n  return result;\n}\n","import { NotificationClientID, NotificationSecret, saveNotificationClient, setNotificationSecret } from '../../index';\nimport { getNotificationAPIURL } from '../getNotificationAPIURL/index';\nimport { getNotificationRequestBody } from '../getNotificationRequestBody/index';\nimport { makeNotificationRequest } from '../loader';\n\nexport async function rotateNotificationSecret(): Promise<boolean> {\n  if (NotificationClientID === '' || NotificationSecret === '') {\n    return false;\n  }\n  const url = getNotificationAPIURL('rotate');\n  const requestBody = getNotificationRequestBody('rotate', []);\n  const response = await makeNotificationRequest('rotate', url, requestBody);\n  if (response === false) {\n    return false;\n  } else {\n    if (response.code === 200 && response.method === 'rotate') {\n      setNotificationSecret(response.secret);\n      await saveNotificationClient();\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","import { NotificationClientID, NotificationSchedule, NotificationSecret, saveNotificationSchedule } from '../../index';\nimport { getNotificationAPIURL } from '../getNotificationAPIURL/index';\nimport { getNotificationRequestBody } from '../getNotificationRequestBody/index';\nimport { makeNotificationRequest } from '../loader';\nimport { rotateNotificationSecret } from '../rotateNotificationSecret/index';\n\nexport async function scheduleNotification(stop_id: NotificationSchedule['stop_id'], location_name: NotificationSchedule['location_name'], route_id: NotificationSchedule['route_id'], route_name: NotificationSchedule['route_name'], direction: NotificationSchedule['direction'], estimate_time: NotificationSchedule['estimate_time'], time_formatting_mode: NotificationSchedule['time_formatting_mode'], time_offset: NotificationSchedule['time_offset'], scheduled_time: string | number | Date): Promise<string | false> {\n  if (NotificationClientID === '' || NotificationSecret === '' || stop_id === undefined || location_name === undefined || route_id === undefined || route_name === undefined || direction === undefined || estimate_time === undefined || typeof time_formatting_mode !== 'number' || scheduled_time === undefined) {\n    return false;\n  }\n  let processed_schedule_time = new Date();\n  switch (typeof scheduled_time) {\n    case 'string':\n      processed_schedule_time = new Date(scheduled_time);\n      break;\n    case 'number':\n      processed_schedule_time = new Date(scheduled_time);\n      break;\n    default:\n      if (scheduled_time instanceof Date) {\n        processed_schedule_time = scheduled_time;\n      } else {\n        return false;\n      }\n      break;\n  }\n  const url = getNotificationAPIURL('schedule');\n  const requestBody = getNotificationRequestBody('schedule', [stop_id, location_name, route_id, route_name, direction, estimate_time, time_formatting_mode, time_offset, processed_schedule_time.toISOString()]);\n  const response = await makeNotificationRequest('schedule', url, requestBody);\n  if (response === false) {\n    return false;\n  } else {\n    if (response.code === 200 && response.method === 'schedule') {\n      if (Math.random() > 0.8) {\n        await rotateNotificationSecret();\n      }\n      await saveNotificationSchedule(response.schedule_id, stop_id, location_name, route_id, route_name, direction, estimate_time, time_formatting_mode, time_offset, processed_schedule_time.getTime());\n      return response.schedule_id;\n    } else {\n      return false;\n    }\n  }\n}\n","import { sha256 } from '../../../../tools/index';\nimport { generateTOTPToken } from '../../../../tools/totp';\nimport { NotificationClientID, NotificationResponse, NotificationSecret } from '../../index';\n\nexport function getNotificationRequestBody(method: NotificationResponse['method'], parameters: Array<any>): object | false {\n  switch (method) {\n    case 'cancel':\n      if (NotificationClientID === '' || NotificationSecret === '' || parameters.length !== 1) {\n        return false;\n      } else {\n        return {\n          client_id: NotificationClientID,\n          totp_token: generateTOTPToken(NotificationSecret),\n          schedule_id: parameters[0]\n        };\n      }\n      break;\n    case 'register':\n      if (parameters.length !== 1) {\n        return false;\n      } else {\n        const currentDate = new Date();\n        currentDate.setMilliseconds(0);\n        currentDate.setSeconds(0);\n        return {\n          hash: sha256(`${parameters[0]}${currentDate.getTime()}`)\n        };\n      }\n      break;\n    case 'schedule':\n      if (NotificationClientID === '' || NotificationSecret === '' || parameters.length !== 9) {\n        return false;\n      } else {\n        return {\n          client_id: NotificationClientID,\n          totp_token: generateTOTPToken(NotificationSecret),\n          stop_id: parameters[0],\n          location_name: parameters[1],\n          route_id: parameters[2],\n          route_name: parameters[3],\n          direction: parameters[4],\n          estimate_time: parameters[5],\n          time_formatting_mode: parameters[6],\n          time_offset: parameters[7],\n          scheduled_time: parameters[8]\n        };\n      }\n      break;\n    case 'rotate':\n      if (NotificationClientID === '' || NotificationSecret === '' || parameters.length !== 0) {\n        return false;\n      } else {\n        return {\n          client_id: NotificationClientID,\n          totp_token: generateTOTPToken(NotificationSecret)\n        };\n      }\n      break;\n    case 'reschedule':\n      if (NotificationClientID === '' || NotificationSecret === '' || parameters.length !== 3) {\n        return false;\n      } else {\n        return {\n          client_id: NotificationClientID,\n          totp_token: generateTOTPToken(NotificationSecret),\n          schedule_id: parameters[0],\n          estimate_time: parameters[1],\n          scheduled_time: parameters[2]\n        };\n      }\n      break;\n    default:\n      return false;\n      break;\n  }\n}\n"],"names":["cancelNotification","_x","_cancelNotification","apply","arguments","schedule_id","NotificationClientID","NotificationSecret","undefined","url","getNotificationAPIURL","requestBody","getNotificationRequestBody","response","makeNotificationRequest","code","method","removeNotificationSchedule","_x2","_x3","_makeNotificationRequest","body","requestOptions","headers","JSON","stringify","fetch","ok","text","json","parse","jsonError","Error","error","rankBatchFoundEstimateTime","batchFoundEstimateTime","StopIDList","result","rankingArray","thisStopKey","thisBatchFoundEstimateTimeItem","thisStopID","StopID","thisEstimateTime","parseInt","EstimateTime","indexOf","push","rankingArrayLength","length","sort","a","b","index","_i","_rankingArray","rankingRatio","rankingCode","number","toString","integrateLocation","_x4","_integrateLocation","hash","chartWidth","chartHeight","requestID","setDataReceivingProgress","getEstimateTime","Location","getLocation","Route","getRoute","Stop","getStop","BusEvent","getBusEvent","BusData","getBusData","BusArrivalTimes","getBusArrivalTimes","time_formatting_mode","getSettingOptionValue","location_labels","display_user_orientation","groupedItems","itemQuantity","groups","userOrientation","getUserOrientation","thisLocation","thisLocationName","n","stopLocationIds","id","setsOfVectors","v","StopIDs","RouteIDs","stopLocationQuantity","i","concat","s","r","_step2","_step","_iterator","_createForOfIteratorHelper","done","item","value","err","e","f","batchFindEstimateTime","batchFoundBuses","batchFindBusesForLocation","cardinalDirections","_iterator2","_step3","vectorSet","x","y","_iterator3","vector","meanVector","normalizeVector","cardinalDirection","getCardinalDirectionFromVector","labels","generateLabelFromAddresses","generateLetterLabels","generateDirectionLabels","groupKey","name","properties","key","icon","addressToString","la","toFixed","lo","thisGroupStops","stopQuantity","thisGroupRanking","o","integratedItem","thisStop","hasOwnProperty","stopId","thisItemRanking","ranking","thisRouteID","thisRouteKey","thisRoute","route_name","route_direction","des","dep","goBack","routeId","parsedEstimateTime","parseEstimateTime","status","buses","map","formatBus","thisBusArrivalTimes","busArrivalTimes","groupQuantity","LocationName","dataUpdateTime","getDataUpdateTime","deleteDataReceivingProgress","deleteDataUpdateTime","registerNotificationClient","_registerNotificationClient","registrationKey","setNotificationClientID","client_id","setNotificationSecret","secret","saveNotificationClient","NotificationProvider","URL","searchParams","set","integrateLocationDetails","_integrateLocationDetails","thisLocationKey","actions","actionsQuantity","action","openSaveToFolder","shareLocationPermalink","showLocationPermalinkQRCode","_rotateNotificationSecret","scheduleNotification","_x5","_x6","_x7","_x8","_x9","_scheduleNotification","stop_id","location_name","route_id","direction","estimate_time","time_offset","scheduled_time","processed_schedule_time","Date","_typeof","toISOString","Math","random","rotateNotificationSecret","saveNotificationSchedule","getTime","parameters","totp_token","generateTOTPToken","currentDate","setMilliseconds","setSeconds","sha256"],"sourceRoot":""}