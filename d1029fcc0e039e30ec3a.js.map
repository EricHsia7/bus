{"version":3,"file":"d1029fcc0e039e30ec3a.js","mappings":"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","sources":["webpack://bus/./src/data/export/index.ts","webpack://bus/./src/data/folder/index.ts","webpack://bus/./src/data/import/index.ts","webpack://bus/./src/data/location/details.ts","webpack://bus/./src/data/location/index.ts"],"sourcesContent":["import { FolderWithContentArray, listFoldersWithContent } from '../folder/index';\nimport { listPersonalSchedules, PersonalScheduleArray } from '../personal-schedule/index';\nimport { listRecentViews, RecentViewArray } from '../recent-views/index';\nimport { listSettingsWithOptions, SettingsWithOptionsArray } from '../settings/index';\n\nexport interface ExportedDataVersion1 {\n  time: string;\n  version: 1;\n  folders: FolderWithContentArray;\n}\n\nexport interface ExportedDataVersion2 {\n  time: string;\n  version: 2;\n  folders: FolderWithContentArray;\n  settings: SettingsWithOptionsArray;\n}\n\nexport interface ExportedDataVersion3 {\n  time: string;\n  version: 3;\n  folders: FolderWithContentArray;\n  settings: SettingsWithOptionsArray;\n  personal_schedules: PersonalScheduleArray;\n}\n\nexport interface ExportedDataVersion4 {\n  time: string;\n  version: 4;\n  folders: FolderWithContentArray;\n  settings: SettingsWithOptionsArray;\n  personal_schedules: PersonalScheduleArray;\n  recent_views: RecentViewArray;\n}\n\nexport type ExportedData = ExportedDataVersion1 | ExportedDataVersion2 | ExportedDataVersion3 | ExportedDataVersion4;\n\nexport async function exportData(): Promise<string> {\n  const foldersWithContent = await listFoldersWithContent();\n  const settings = listSettingsWithOptions();\n  const personalSchedules = await listPersonalSchedules();\n  const RecentViews = await listRecentViews();\n  let result: ExportedDataVersion4 = {};\n  result.time = new Date().toISOString();\n  result.version = 4;\n  result.folders = foldersWithContent;\n  result.settings = settings;\n  result.personal_schedules = personalSchedules;\n  result.recent_views = RecentViews;\n  return JSON.stringify(result);\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\n// import { generateLabelFromAddresses } from '../../tools/address';\n// import { CardinalDirection, getCardinalDirectionFromVector } from '../../tools/cardinal-direction';\nimport { generateIdentifier, hasOwnProperty } from '../../tools/index';\n// import { generateDirectionLabels, generateLetterLabels } from '../../tools/labels';\n// import { normalizeVector } from '../../tools/math';\nimport { collectBusArrivalTimeData } from '../analytics/bus-arrival-time/index';\nimport { collectUpdateRateData } from '../analytics/update-rate/index';\nimport { EstimateTime, EstimateTimeItem, getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, MergedLocation, MergedLocationItem, SimplifiedLocation } from '../apis/getLocation/index';\nimport { getMaterialSymbolsSearchIndex } from '../apis/getMaterialSymbolsSearchIndex/index';\nimport { getRoute, SimplifiedRoute, SimplifiedRouteItem } from '../apis/getRoute/index';\nimport { getStop, SimplifiedStop } from '../apis/getStop/index';\nimport { EstimateTimeStatus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue, SettingSelectOptionRefreshIntervalValue } from '../settings/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\n\ninterface FolderContentRouteEndPoints {\n  departure: string;\n  destination: string;\n}\n\nexport interface FolderContentStopRoute {\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n  id: number;\n}\n\nexport interface FolderContentStop {\n  type: 'stop';\n  id: number;\n  timestamp: number;\n  name: string;\n  direction: number;\n  route: FolderContentStopRoute;\n}\n\nexport interface FolderContentRoute {\n  type: 'route';\n  id: number;\n  timestamp: number;\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n}\n\nexport interface FolderContentLocation {\n  type: 'location';\n  id: string; // hash\n  timestamp: number;\n  name: string;\n}\n\nexport interface FolderContentBus {\n  type: 'bus';\n  id: number; // CarID\n  timestamp: number;\n  busID: string; // BusID\n}\n\nexport interface FolderContentEmpty {\n  type: 'empty';\n  id: number;\n}\n\nexport type FolderContent = FolderContentStop | FolderContentRoute | FolderContentLocation | FolderContentBus | FolderContentEmpty;\n\nexport interface Folder {\n  name: string;\n  icon: MaterialSymbols;\n  id: string;\n  timestamp: number;\n}\n\nexport type FolderArray = Array<Folder>;\n\nexport interface FolderWithContent extends Folder {\n  content: Array<FolderContent>;\n  contentLength: number;\n}\n\nexport type FolderWithContentArray = Array<FolderWithContent>;\n\nexport interface FolderWithContentLength extends Folder {\n  contentLength: number;\n}\n\nexport type FolderWithContentLengthArray = Array<FolderWithContentLength>;\n\nconst FolderList: { [key: string]: Folder } = {};\n\nexport async function initializeFolderList() {\n  const folderKeys = await lfListItemKeys(11);\n  for (const folderKey of folderKeys) {\n    const thisFolderJSON = await lfGetItem(11, folderKey);\n    if (thisFolderJSON) {\n      const thisFolderObject = JSON.parse(thisFolderJSON) as Folder;\n      if (!hasOwnProperty(FolderList, folderKey)) {\n        FolderList[folderKey] = thisFolderObject;\n      }\n    }\n  }\n}\n\nexport async function createFolder(name: Folder['name'], icon: Folder['icon']): Promise<Folder['id'] | false> {\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!hasOwnProperty(materialSymbolsSearchIndex.symbols, icon)) return false;\n\n  // Check existence\n  const folderID = generateIdentifier();\n  const folderKey = `f_${folderID}`;\n  if (hasOwnProperty(FolderList, folderKey)) {\n    return false;\n  }\n  const existingFolder = await lfGetItem(11, folderKey);\n  if (existingFolder) {\n    return false;\n  }\n\n  // Generate folder\n  const nowTime = new Date().getTime();\n  let newFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: nowTime\n  };\n\n  // Save folder\n  FolderList[folderKey] = newFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(newFolder));\n  await lfSetItem(12, folderKey, JSON.stringify([]));\n  return folderID;\n}\n\nexport async function updateFolder(folderID: Folder['id'], name: Folder['name'], icon: Folder['icon']): Promise<boolean> {\n  const folderKey: string = `f_${folderID}`;\n\n  // Check existence\n  const existingFolderJSON = await lfGetItem(11, folderKey);\n  if (!existingFolderJSON) {\n    return false;\n  }\n  const existingFolderObject = JSON.parse(existingFolderJSON) as Folder;\n\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!hasOwnProperty(materialSymbolsSearchIndex.symbols, icon)) return false;\n\n  // Generate folder\n  const modifiedFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: existingFolderObject.timestamp\n  };\n\n  // Save folder\n  FolderList[folderKey] = modifiedFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(modifiedFolder));\n  return true;\n}\n\nexport function getFolder(folderID: Folder['id']): Folder | false {\n  const folderKey: string = `f_${folderID}`;\n  if (!hasOwnProperty(FolderList, folderKey)) {\n    return false;\n  }\n  const folderObject: Folder = {\n    name: FolderList[folderKey].name,\n    icon: FolderList[folderKey].icon,\n    id: FolderList[folderKey].id,\n    timestamp: FolderList[folderKey].timestamp\n  };\n  return folderObject;\n  // return cloneDeep(Folders[folderKey]);\n}\n\nexport function listFolders(): FolderArray {\n  const result = [];\n  for (const folderKey in FolderList) {\n    const folderObject: Folder = {\n      name: FolderList[folderKey].name,\n      icon: FolderList[folderKey].icon,\n      id: FolderList[folderKey].id,\n      timestamp: FolderList[folderKey].timestamp\n    };\n    result.push(folderObject);\n  }\n  result.sort(function (a, b) {\n    return a.timestamp - b.timestamp;\n  });\n  return result;\n}\n\nexport async function listFolderContent(folderID: Folder['id']): Promise<Array<FolderContent>> {\n  const result: Array<FolderContent> = [];\n\n  const folderKey: string = `f_${folderID}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return result;\n  }\n\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return result;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0) {\n    const emptyItem: FolderContentEmpty = {\n      type: 'empty',\n      id: 0\n    };\n    result.push(emptyItem);\n    return result;\n  }\n\n  for (const thisFolderContentKey of thisFolderContentIndexArray) {\n    const thisContentJSON = await lfGetItem(13, thisFolderContentKey);\n    if (thisContentJSON) {\n      const thisContentObject = JSON.parse(thisContentJSON) as FolderContent;\n      result.push(thisContentObject);\n    }\n  }\n  return result;\n}\n\nasync function getFolderContentLength(folderID: Folder['id']): Promise<number> {\n  const folderKey: string = `f_${folderID}`;\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return 0;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  return thisFolderContentIndexArray.length;\n}\n\nexport async function listFoldersWithContent(): Promise<FolderWithContentArray> {\n  const folders = listFolders();\n  const result: FolderWithContentArray = [];\n  for (const folder of folders) {\n    const folderContent = await listFolderContent(folder.id);\n    const folderContentLength = await getFolderContentLength(folder.id);\n    result.push({\n      name: folder.name,\n      icon: folder.icon,\n      id: folder.id,\n      timestamp: folder.timestamp,\n      content: folderContent,\n      contentLength: folderContentLength\n    });\n  }\n  return result;\n}\n\nexport async function listFoldersWithContentLength(): Promise<FolderWithContentLengthArray> {\n  const folders = listFolders();\n  const result: FolderWithContentLengthArray = [];\n  for (const folder of folders) {\n    const folderContentLength = await getFolderContentLength(folder.id);\n    result.push({\n      name: folder.name,\n      icon: folder.icon,\n      id: folder.id,\n      timestamp: folder.timestamp,\n      contentLength: folderContentLength\n    });\n  }\n  return result;\n}\n\nexport async function listAllFolderContent(types: Array<FolderContent['type']>): Promise<Array<FolderContent>> {\n  let useFilter: boolean = true;\n  if (typeof types !== 'object' || !Array.isArray(types)) {\n    useFilter = false;\n  }\n  const result: Array<FolderContent> = [];\n  const keys = await lfListItemKeys(13);\n  for (const key of keys) {\n    const json = await lfGetItem(13, key);\n    if (json) {\n      const object = JSON.parse(json) as FolderContent;\n      if (useFilter) {\n        if (types.indexOf(object.type) > -1) {\n          result.push(object);\n        }\n      } else {\n        result.push(object);\n      }\n    }\n  }\n  return result;\n}\n\nexport interface integratedFolderContentStopRoute extends FolderContentStopRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentStop extends FolderContentStop {\n  status: EstimateTimeStatus;\n  route: integratedFolderContentStopRoute;\n}\n\nexport interface integratedFolderContentRoute extends FolderContentRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentLocation extends FolderContentLocation {\n  // labels: string;\n}\n\nexport interface integratedFolderContentBus extends FolderContentBus {}\n\nexport interface integratedFolderContentEmpty extends FolderContentEmpty {}\n\nexport type integratedFolderContent = integratedFolderContentStop | integratedFolderContentRoute | integratedFolderContentLocation | integratedFolderContentBus | integratedFolderContentEmpty;\n\nexport interface integratedFolder extends Folder {\n  content: Array<integratedFolderContent>;\n  contentLength: number;\n}\n\nexport interface integratedFolders {\n  folders: Array<integratedFolder>;\n  dataUpdateTime: number;\n}\n\nexport async function integrateFolders(requestID: string): Promise<integratedFolders> {\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n\n  const [foldersWithContent, Route, EstimateTime] = (await Promise.all([listFoldersWithContent(), getRoute(requestID, true), getEstimateTime(requestID)])) as [FolderWithContentArray, SimplifiedRoute, EstimateTime];\n  // const Location = (await getLocation(requestID, 1)) as MergedLocation;\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode') as number;\n  // const location_labels = getSettingOptionValue('location_labels');\n  const power_saving = getSettingOptionValue('power_saving') as boolean;\n  const refresh_interval_setting = getSettingOptionValue('refresh_interval') as SettingSelectOptionRefreshIntervalValue;\n\n  const StopIDs: Array<FolderContentStop['id']> = [];\n  for (const folderWithContent1 of foldersWithContent) {\n    for (let i = 0, l = folderWithContent1.content.length; i < l; i++) {\n      if (folderWithContent1.content[i].type === 'stop') {\n        StopIDs.push(folderWithContent1.content[i].id as FolderContentStop['id']);\n      }\n    }\n  }\n\n  const batchFoundEstimateTime: { [key: string]: EstimateTimeItem } = {};\n  for (const EstimateTimeItem of EstimateTime) {\n    if (StopIDs.indexOf(EstimateTimeItem.StopID) > -1) {\n      const thisStopKey: string = `s_${EstimateTimeItem.StopID}`;\n      batchFoundEstimateTime[thisStopKey] = EstimateTimeItem;\n    }\n  }\n\n  const folders: integratedFolders['folders'] = [];\n\n  for (const folderWithContent2 of foldersWithContent) {\n    // Initialize integratedFolder\n    const integratedFolder: integratedFolder = {\n      name: folderWithContent2.name,\n      icon: folderWithContent2.icon,\n      id: folderWithContent2.id,\n      timestamp: folderWithContent2.timestamp,\n      content: [],\n      contentLength: folderWithContent2.contentLength\n    };\n\n    for (const item of folderWithContent2.content) {\n      const integratedItem = item as integratedFolderContent;\n      switch (integratedItem.type) {\n        case 'stop': {\n          const thisStopKey = `s_${integratedItem.id}`;\n          let thisEstimateTime = {} as EstimateTimeItem;\n          if (hasOwnProperty(batchFoundEstimateTime, thisStopKey)) {\n            thisEstimateTime = batchFoundEstimateTime[thisStopKey];\n          } else {\n            break;\n          }\n          integratedItem.status = parseEstimateTime(thisEstimateTime.EstimateTime, time_formatting_mode);\n          const thisRouteKey = `r_${integratedItem.route.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.route.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'route': {\n          const thisRouteKey = `r_${integratedItem.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'location': {\n          /*\n          const thisLocationKey = `ml_${integratedItem.id}`;\n          const thisLocation = Location[thisLocationKey] as MergedLocationItem;\n          let labels: Array<string> = [];\n          switch (location_labels) {\n            case 'address':\n              labels = generateLabelFromAddresses(thisLocation.a);\n              break;\n            case 'letters':\n              const stopLocationIds = thisLocation.id;\n              const stopLocationQuantity = stopLocationIds.length;\n              labels = generateLetterLabels(stopLocationQuantity);\n              break;\n            case 'directions':\n              const setsOfVectors = thisLocation.v;\n              const cardinalDirections: Array<CardinalDirection> = [];\n              for (const vectorSet of setsOfVectors) {\n                let x: number = 0;\n                let y: number = 0;\n                for (const vector of vectorSet) {\n                  x += vector[0];\n                  y += vector[1];\n                }\n                const meanVector = normalizeVector([x, y]) as [number, number];\n                const cardinalDirection = getCardinalDirectionFromVector(meanVector);\n                cardinalDirections.push(cardinalDirection);\n              }\n\n              labels = generateDirectionLabels(cardinalDirections);\n              break;\n            default:\n              break;\n          }\n          integratedItem.labels = labels.join(' - ');\n          */\n          break;\n        }\n        case 'bus':\n          break;\n        case 'empty':\n          break;\n        default:\n          break;\n      }\n      integratedFolder.content.push(integratedItem);\n    }\n    folders.push(integratedFolder);\n  }\n\n  const result: integratedFolders = {\n    folders: folders,\n    dataUpdateTime: getDataUpdateTime(requestID)\n  };\n\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n\n  if (!power_saving) {\n    if (refresh_interval_setting.dynamic) {\n      await collectUpdateRateData(EstimateTime);\n    }\n    await collectBusArrivalTimeData(EstimateTime);\n  }\n\n  return result;\n}\n\nexport async function saveToFolder(folderID: Folder['id'], content: FolderContent): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const contentKey = `${content.type}_${content.id}`;\n  const thisFolder = getFolder(folderID);\n\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0 || thisFolderContentIndexArray.indexOf(contentKey) < 0) {\n    thisFolderContentIndexArray.push(contentKey);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n    await lfSetItem(13, contentKey, JSON.stringify(content));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport async function isFolderContentSaved(type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderContentKeyToCheck = `${type}_${id}`;\n\n  const keys = await lfListItemKeys(12);\n  for (const key of keys) {\n    const thisFolderContentIndexJSON = (await lfGetItem(12, key)) as string;\n    if (!thisFolderContentIndexJSON) {\n      continue;\n    }\n    const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n    if (thisFolderContentIndexArray.indexOf(folderContentKeyToCheck) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport async function removeFromFolder(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n\n  // Check existence\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  // Remove reference from folder content index\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 0) {\n    thisFolderContentIndexArray.splice(index, 1);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n  }\n\n  // Remove content if there are no other references\n  const isSaved = await isFolderContentSaved(type, id);\n  if (isSaved === false) {\n    await lfRemoveItem(13, thisFolderContentKey);\n  }\n  return true;\n}\n\nexport async function saveStop(folderID: Folder['id'], StopID: number, RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Stop = (await getStop(requestID)) as SimplifiedStop;\n  const Location = (await getLocation(requestID, 0)) as SimplifiedLocation;\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n\n  const thisStop = Stop[`s_${StopID}`];\n  const thisStopDirection: number = parseInt(thisStop.goBack);\n  const thisLocation = Location[`l_${thisStop.stopLocationId}`];\n  const thisStopName: string = thisLocation.n;\n\n  const thisRoute = Route[`r_${RouteID}`];\n  const thisRouteName: string = thisRoute.n;\n  const thisRouteDeparture: string = thisRoute.dep;\n  const thisRouteDestination: string = thisRoute.des;\n\n  const newContent: FolderContentStop = {\n    type: 'stop',\n    id: StopID,\n    timestamp: new Date().getTime(),\n    name: thisStopName,\n    direction: thisStopDirection,\n    route: {\n      name: thisRouteName,\n      endPoints: {\n        departure: thisRouteDeparture,\n        destination: thisRouteDestination\n      },\n      id: RouteID\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveRoute(folderID: Folder['id'], RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisRouteKey = `r_${RouteID}`;\n  let thisRoute = {} as SimplifiedRouteItem;\n  if (hasOwnProperty(Route, thisRouteKey)) {\n    thisRoute = Route[thisRouteKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentRoute = {\n    type: 'route',\n    id: RouteID,\n    timestamp: new Date().getTime(),\n    name: thisRoute.n,\n    endPoints: {\n      departure: thisRoute.dep,\n      destination: thisRoute.des\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveLocation(folderID: Folder['id'], hash: string): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisLocationKey = `ml_${hash}`;\n  let thisLocation = {} as MergedLocationItem;\n  if (hasOwnProperty(Location, thisLocationKey)) {\n    thisLocation = Location[thisLocationKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentLocation = {\n    type: 'location',\n    id: hash,\n    timestamp: new Date().getTime(),\n    name: thisLocation.n\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\n// TODO: Save Bus\n\nexport async function updateFolderContentIndex(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id'], direction: 'up' | 'down'): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 1) {\n    let offset: number = 0;\n    switch (direction) {\n      case 'up':\n        offset = -1;\n        break;\n      case 'down':\n        offset = 1;\n        break;\n      default:\n        offset = 0;\n        break;\n    }\n    thisFolderContentIndexArray.splice(index, 1);\n    thisFolderContentIndexArray.splice(index + offset, 0, thisFolderContentKey);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n    return true;\n  } else {\n    return false;\n  }\n}\n","import { ExportedData } from '../export/index';\nimport { createFolder, FolderWithContentArray, saveToFolder, updateFolder } from '../folder/index';\nimport { createPersonalSchedule, getPersonalSchedule, PersonalScheduleArray, updatePersonalSchedule } from '../personal-schedule/index';\nimport { getRecentView, logRecentView, RecentViewArray } from '../recent-views/index';\nimport { changeSettingOption, getSetting, SettingsWithOptionsArray } from '../settings/index';\nimport { lfGetItem } from '../storage/index';\n\nexport async function importFolders(data: FolderWithContentArray): Promise<boolean> {\n  for (const FolderWithContent of data) {\n    const folder = FolderWithContent;\n    var update = false;\n    var creation = false;\n    const folderKey: string = `f_${folder.id}`;\n    const existingFolder: string = await lfGetItem(11, folderKey);\n    if (existingFolder) {\n      update = await updateFolder(folder.id, folder.name, folder.icon);\n    } else {\n      creation = await createFolder(folder.name, folder.icon);\n    }\n    if (update) {\n      for (const content of FolderWithContent.content) {\n        await saveToFolder(FolderWithContent.id, content);\n      }\n    }\n    if (creation) {\n      for (const content of FolderWithContent.content) {\n        await saveToFolder(creation, content);\n      }\n    }\n  }\n}\n\nexport async function importSettings(data: SettingsWithOptionsArray): Promise<boolean> {\n  for (const SettingWithOption of data) {\n    const existingSetting = getSetting(SettingWithOption.key);\n    if (existingSetting) {\n      if (existingSetting.type === 'select') {\n        await changeSettingOption(SettingWithOption.key, SettingWithOption.option);\n      }\n    }\n  }\n  return true;\n}\n\nexport async function importPersonalSchedules(data: PersonalScheduleArray): Promise<boolean> {\n  for (const PersonalSchedule of data) {\n    const existingPersonalSchedule = await getPersonalSchedule(PersonalSchedule.id);\n    if (existingPersonalSchedule) {\n      await updatePersonalSchedule(PersonalSchedule);\n    } else {\n      await createPersonalSchedule(PersonalSchedule.name, PersonalSchedule.period.start.hours, PersonalSchedule.period.start.minutes, PersonalSchedule.period.end.hours, PersonalSchedule.period.end.minutes, PersonalSchedule.days);\n    }\n  }\n  return true;\n}\n\nexport async function importRecentViews(data: RecentViewArray): Promise<boolean> {\n  for (const RecentView of data) {\n    switch (RecentView.type) {\n      case 'route': {\n        const existingRecentViewRoute = await getRecentView('route', RecentView.id);\n        if (!existingRecentViewRoute) {\n          await logRecentView(RecentView.type, RecentView.id);\n        }\n        break;\n      }\n      case 'location': {\n        const existingRecentViewLocation = await getRecentView('location', RecentView.hash);\n        if (!existingRecentViewLocation) {\n          await logRecentView(RecentView.type, RecentView.hash);\n        }\n        break;\n      }\n      case 'bus': {\n        const existingRecentViewBus = await getRecentView('bus', RecentView.id);\n        if (!existingRecentViewBus) {\n          await logRecentView(RecentView.type, RecentView.id);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  return true;\n}\n\nexport async function importData(data: string): Promise<boolean> {\n  const parsedData: ExportedData = JSON.parse(data);\n  switch (parsedData.version) {\n    case 1:\n      await importFolders(parsedData.folders);\n      return true;\n      break;\n    case 2:\n      await importFolders(parsedData.folders);\n      await importSettings(parsedData.settings);\n      return true;\n      break;\n    case 3:\n      await importFolders(parsedData.folders);\n      await importSettings(parsedData.settings);\n      await importPersonalSchedules(parsedData.personal_schedules);\n      return true;\n      break;\n    case 4:\n      await importFolders(parsedData.folders);\n      await importSettings(parsedData.settings);\n      await importPersonalSchedules(parsedData.personal_schedules);\n      await importRecentViews(parsedData.recent_views);\n      return true;\n      break;\n    default:\n      return false;\n      break;\n  }\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { shareLocationPermalink, showLocationPermalinkQRCode } from '../../interface/location/details/index';\nimport { openSaveToFolder } from '../../interface/save-to-folder/index';\nimport { hasOwnProperty } from '../../tools/index';\nimport { getLocation, MergedLocation, MergedLocationItem } from '../apis/getLocation/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime } from '../apis/loader';\n\nexport interface IntegratedLocationDetailsAction {\n  icon: MaterialSymbols;\n  action: Function;\n  key: string,\n  name: string;\n}\n\nexport type IntegratedLocationDetailsActionArray = Array<IntegratedLocationDetailsAction>;\n\nexport interface IntegratedLocationDetails {\n  actions: IntegratedLocationDetailsActionArray;\n  actionsQuantity: number\n  hash: string;\n}\n\nexport async function integrateLocationDetails(hash: string, requestID: string): Promise<IntegratedLocationDetails> {\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisLocationKey = `ml_${hash}`;\n  let thisLocation = {} as MergedLocationItem;\n  if (hasOwnProperty(Location, thisLocationKey)) {\n    thisLocation = Location[thisLocationKey];\n  } else {\n    return {\n      actions: [],\n      actionsQuantity: 0,\n      hash: hash\n    };\n  }\n  const actions: IntegratedLocationDetailsActionArray = [\n    {\n      icon: 'folder',\n      name: '儲存',\n      key: 'save-to-folder',\n      action: function () {\n        openSaveToFolder('location', [hash], null);\n      }\n    },\n    {\n      icon: 'ios_share',\n      name: '分享',\n      key: 'permalink',\n      action: function () {\n        shareLocationPermalink(hash);\n      }\n    },\n    {\n      icon: 'qr_code_2',\n      name: '二維條碼',\n      key: 'permalink-qr-code',\n      action: function () {\n        showLocationPermalinkQRCode(hash);\n      }\n    }\n  ];\n  const result: IntegratedLocationDetails = {\n    actions: actions,\n    actionsQuantity: actions.length,\n    hash: hash\n  };\n  return result;\n}\n","import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { addressToString, generateLabelFromAddresses } from '../../tools/address';\nimport { CardinalDirection, getCardinalDirectionFromVector } from '../../tools/cardinal-direction';\nimport { hasOwnProperty } from '../../tools/index';\nimport { generateDirectionLabels, generateLetterLabels } from '../../tools/labels';\nimport { normalizeVector } from '../../tools/math';\nimport { BusArrivalTime, getBusArrivalTimes } from '../analytics/bus-arrival-time/index';\nimport { getBusData } from '../apis/getBusData/index';\nimport { getBusEvent } from '../apis/getBusEvent/index';\nimport { EstimateTime, EstimateTimeItem, getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, MergedLocation } from '../apis/getLocation/index';\nimport { getRoute, SimplifiedRoute } from '../apis/getRoute/index';\nimport { getStop, SimplifiedStop } from '../apis/getStop/index';\nimport { batchFindBusesForLocation, EstimateTimeStatus, formatBus, FormattedBus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue } from '../settings/index';\nimport { getUserOrientation } from '../user-orientation/index';\n\ninterface BatchFoundEstimateTimeItem extends EstimateTimeItem {}\n\ntype BatchFoundEstimateTime = {\n  [key: string]: BatchFoundEstimateTimeItem;\n};\n\nfunction batchFindEstimateTime(EstimateTime: EstimateTime, StopIDList: Array<number>): BatchFoundEstimateTime {\n  const result = {};\n  for (const item of EstimateTime) {\n    if (StopIDList.indexOf(item.StopID) > -1) {\n      const thisStopKey: string = `s_${item.StopID}`;\n      result[thisStopKey] = item;\n    }\n  }\n  return result;\n}\n\ntype BatchFoundEstimateTimeRanking = {\n  [key: string]: IntegratedLocationItemRanking;\n};\n\nfunction rankBatchFoundEstimateTime(batchFoundEstimateTime: BatchFoundEstimateTime, StopIDList: Array<number>): BatchFoundEstimateTimeRanking {\n  // StopIDList act as a secondary filter\n  const result: BatchFoundEstimateTimeRanking = {};\n  const rankingArray: Array<[number, number]> = []; // StopID, EstimateTime\n  for (const thisStopKey in batchFoundEstimateTime) {\n    const thisBatchFoundEstimateTimeItem = batchFoundEstimateTime[thisStopKey];\n    const thisStopID = thisBatchFoundEstimateTimeItem.StopID;\n    const thisEstimateTime = parseInt(thisBatchFoundEstimateTimeItem.EstimateTime);\n    if (thisEstimateTime >= 0 && StopIDList.indexOf(thisStopID) > -1) {\n      rankingArray.push([thisStopID, thisEstimateTime]);\n    }\n  }\n  const rankingArrayLength = rankingArray.length;\n  rankingArray.sort(function (a, b) {\n    return a[1] - b[1];\n  });\n  let index = 1;\n  for (const rankingItem of rankingArray) {\n    // Classify into 4 groups and give a code\n    const rankingRatio = index / rankingArrayLength;\n    const rankingCode = (rankingRatio - (rankingRatio % 0.25)) / 0.25;\n    const thisStopID = rankingItem[0];\n    const thisStopKey = `s_${thisStopID}`;\n    result[thisStopKey] = {\n      number: index,\n      text: index.toString(),\n      code: rankingCode\n    };\n    index += 1;\n  }\n  return result;\n}\n\nexport interface LocationGroupProperty {\n  key: string;\n  icon: MaterialSymbols;\n  value: string;\n}\n\nexport interface LocationGroup {\n  name: string;\n  properties: Array<LocationGroupProperty>;\n}\n\nexport interface IntegratedLocationItemRanking {\n  number: number;\n  text: '--' | string;\n  code: -1 | 0 | 1 | 2 | 3 | 4; // -1: not applicable, 0: 0-25%, 1: 25-50%, 2: 50-75%, 3: 75-100%, 4: 100%\n}\n\nexport interface IntegratedLocationItem {\n  route_name: string;\n  route_direction: string;\n  routeId: number;\n  stopId: number;\n  status: EstimateTimeStatus;\n  ranking: IntegratedLocationItemRanking;\n  buses: Array<FormattedBus>;\n  busArrivalTimes: Array<BusArrivalTime>;\n}\n\nexport interface IntegratedLocation {\n  groupedItems: {\n    [g_index: string]: Array<IntegratedLocationItem>;\n  };\n  groups: {\n    [g_index: string]: LocationGroup;\n  };\n  groupQuantity: number;\n  itemQuantity: {\n    [g_index: string]: number;\n  };\n  LocationName: string;\n  dataUpdateTime: number;\n  hash: string;\n}\n\nexport async function integrateLocation(hash: string, chartWidth: number, chartHeight: number, requestID: string): Promise<IntegratedLocation> {\n  setDataReceivingProgress(requestID, 'getLocation_0', 0, false);\n  setDataReceivingProgress(requestID, 'getLocation_1', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_0', 0, false);\n  setDataReceivingProgress(requestID, 'getStop_1', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_0', 0, false);\n  setDataReceivingProgress(requestID, 'getBusEvent_1', 0, false);\n  setDataReceivingProgress(requestID, 'getBusData_0', 0, false);\n  setDataReceivingProgress(requestID, 'getBusData_1', 0, false);\n\n  const [Route, Stop, Location] = (await Promise.all([await getRoute(requestID, true), await getStop(requestID), await getLocation(requestID, 1)])) as [SimplifiedRoute, SimplifiedStop, MergedLocation];\n  const [EstimateTime, BusEvent, BusData, BusArrivalTimes] = await Promise.all([getEstimateTime(requestID), getBusEvent(requestID), getBusData(requestID), getBusArrivalTimes(chartWidth, chartHeight)]);\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode');\n  const location_labels = getSettingOptionValue('location_labels');\n  const display_user_orientation = getSettingOptionValue('display_user_orientation');\n\n  const groupedItems = {} as IntegratedLocation['groupedItems'];\n  const itemQuantity = {} as IntegratedLocation['itemQuantity'];\n  const groups = {} as IntegratedLocation['groups'];\n\n  const userOrientation = getUserOrientation();\n\n  const thisLocationKey = `ml_${hash}`;\n  const thisLocation = Location[thisLocationKey];\n  const thisLocationName = thisLocation.n;\n  const stopLocationIds = thisLocation.id;\n  const setsOfVectors = thisLocation.v;\n\n  const StopIDs: Array<number> = [];\n  const RouteIDs: Array<number> = [];\n  const stopLocationQuantity = stopLocationIds.length;\n\n  for (let i = 0; i < stopLocationQuantity; i++) {\n    for (let j = 0, l = thisLocation.s[i].length; j < l; j++) {\n      StopIDs.push(thisLocation.s[i][j]);\n      RouteIDs.push(thisLocation.r[i][j]);\n    }\n  }\n\n  const batchFoundEstimateTime = batchFindEstimateTime(EstimateTime, StopIDs);\n  const batchFoundBuses = batchFindBusesForLocation(BusEvent, BusData, Route, StopIDs);\n\n  const cardinalDirections: Array<CardinalDirection> = [];\n  for (const vectorSet of setsOfVectors) {\n    let x: number = 0;\n    let y: number = 0;\n    for (const vector of vectorSet) {\n      x += vector[0];\n      y += vector[1];\n    }\n    const meanVector = normalizeVector([x, y]);\n    const cardinalDirection = getCardinalDirectionFromVector(meanVector);\n    cardinalDirections.push(cardinalDirection);\n  }\n\n  let labels: Array<string> = [];\n  switch (location_labels) {\n    case 'address':\n      labels = generateLabelFromAddresses(thisLocation.a);\n      break;\n    case 'letters':\n      labels = generateLetterLabels(stopLocationQuantity);\n      break;\n    case 'directions':\n      labels = generateDirectionLabels(cardinalDirections);\n      break;\n    default:\n      break;\n  }\n\n  for (let i = 0; i < stopLocationQuantity; i++) {\n    const groupKey = `g_${i}`;\n    groupedItems[groupKey] = [];\n    itemQuantity[groupKey] = 0;\n    groups[groupKey] = {\n      name: labels[i],\n      properties: [\n        {\n          key: 'address',\n          icon: 'personal_places',\n          value: addressToString(thisLocation.a[i])\n        },\n        {\n          key: 'exact_position',\n          icon: 'location_on',\n          value: `${thisLocation.la[i].toFixed(5)}, ${thisLocation.lo[i].toFixed(5)}`\n        },\n        {\n          key: 'cardinal_direction',\n          icon: cardinalDirections[i].icon,\n          value: `${cardinalDirections[i].name}${display_user_orientation && userOrientation.cardinalDirection.id !== -1 && userOrientation.cardinalDirection.id === cardinalDirections[i].id ? '（目前指向）' : ''}`\n        }\n      ]\n    };\n\n    const thisGroupStops = thisLocation.s[i];\n    const stopQuantity = thisGroupStops.length;\n    const thisGroupRanking = rankBatchFoundEstimateTime(batchFoundEstimateTime, thisGroupStops);\n\n    for (let o = 0; o < stopQuantity; o++) {\n      const integratedItem = {} as IntegratedLocationItem;\n      // Collect data from 'Stop'\n      const thisStopID = thisLocation.s[i][o];\n      const thisStopKey = `s_${thisStopID}`;\n      let thisStop: SimplifiedStopItem = {};\n      if (hasOwnProperty(Stop, thisStopKey)) {\n        thisStop = Stop[thisStopKey];\n      } else {\n        continue;\n      }\n      integratedItem.stopId = thisStopID;\n\n      // Collect data from 'thisGroupRanking'\n      let thisItemRanking = { number: 0, text: '--', code: -1 } as IntegratedLocationItemRanking;\n      if (hasOwnProperty(thisGroupRanking, thisStopKey)) {\n        thisItemRanking = thisGroupRanking[thisStopKey];\n      }\n      integratedItem.ranking = thisItemRanking;\n\n      // Collect data from 'Route'\n      const thisRouteID: number = thisLocation.r[i][o];\n      const thisRouteKey = `r_${thisRouteID}`;\n      let thisRoute: SimplifiedRouteItem = {};\n      if (hasOwnProperty(Route, thisRouteKey)) {\n        thisRoute = Route[thisRouteKey];\n      } else {\n        continue;\n      }\n      integratedItem.route_name = thisRoute.n;\n      integratedItem.route_direction = `往${[thisRoute.des, thisRoute.dep, ''][parseInt(thisStop.goBack)]}`;\n      integratedItem.routeId = thisRouteID;\n\n      // Collect data from 'batchFoundEstimateTime'\n      let thisEstimateTime = {} as EstimateTimeItem;\n      if (hasOwnProperty(batchFoundEstimateTime, thisStopKey)) {\n        thisEstimateTime = batchFoundEstimateTime[thisStopKey];\n      } else {\n        continue;\n      }\n      const parsedEstimateTime = parseEstimateTime(thisEstimateTime.EstimateTime, time_formatting_mode);\n      integratedItem.status = parsedEstimateTime;\n\n      // Collect data from 'batchFoundBuses'\n      let buses = [];\n      if (hasOwnProperty(batchFoundBuses, thisStopKey)) {\n        buses = batchFoundBuses[thisStopKey].map((e) => formatBus(e));\n      }\n      integratedItem.buses = buses;\n\n      // Collect data from 'BusArrivalTimes'\n      let thisBusArrivalTimes = [];\n      if (hasOwnProperty(BusArrivalTimes, thisStopKey)) {\n        thisBusArrivalTimes = BusArrivalTimes[thisStopKey];\n      }\n      integratedItem.busArrivalTimes = thisBusArrivalTimes;\n\n      groupedItems[groupKey].push(integratedItem);\n      itemQuantity[groupKey] += 1;\n    }\n  }\n\n  for (const key in groupedItems) {\n    groupedItems[key].sort(function (a, b) {\n      return a.routeId - b.routeId;\n    });\n    /*\n      .map((item: IntegratedLocationItem) => {\n        // accessing ranking[key] inside map callback will cause constant violations any way\n        return {\n          route_name: item.route_name,\n          route_direction: item.route_direction,\n          routeId: item.routeId,\n          stopId: item.stopId,\n          status: item.status,\n          rank: {\n            number: thisRankingIndex + 1,\n            code: 0\n          },\n          buses: item.buses,\n          busArrivalTimes: item.busArrivalTimes\n        };\n      })*/\n  }\n  const result: IntegratedLocation = {\n    groupedItems: groupedItems,\n    groups: groups,\n    groupQuantity: stopLocationQuantity,\n    itemQuantity: itemQuantity,\n    LocationName: thisLocationName,\n    hash: hash,\n    dataUpdateTime: getDataUpdateTime(requestID)\n  };\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  //await recordEstimateTimeForUpdateRate(EstimateTime);\n  return result;\n}\n"],"names":["exportData","_exportData","apply","arguments","_asyncToGenerator","foldersWithContent","listFoldersWithContent","settings","listSettingsWithOptions","personalSchedules","listPersonalSchedules","RecentViews","listRecentViews","result","time","Date","toISOString","version","folders","personal_schedules","recent_views","JSON","stringify","FolderList","initializeFolderList","_initializeFolderList","folderKeys","lfListItemKeys","folderKey","thisFolderJSON","lfGetItem","thisFolderObject","parse","hasOwnProperty","createFolder","_x","_x2","_createFolder","name","icon","requestID","generateIdentifier","materialSymbolsSearchIndex","getMaterialSymbolsSearchIndex","deleteDataReceivingProgress","symbols","folderID","newFolder","id","timestamp","getTime","lfSetItem","updateFolder","_x3","_x4","_x5","_updateFolder","existingFolderJSON","existingFolderObject","modifiedFolder","getFolder","listFolders","folderObject","push","sort","a","b","listFolderContent","_x6","_listFolderContent","thisFolder","thisFolderContentIndexJSON","thisFolderContentIndexArray","length","type","thisFolderContentKey","thisContentJSON","thisContentObject","getFolderContentLength","_x7","_getFolderContentLength","_listFoldersWithContent","folder","folderContent","folderContentLength","content","contentLength","listFoldersWithContentLength","_listFoldersWithContentLength","listAllFolderContent","_x8","_listAllFolderContent","types","useFilter","_typeof","Array","isArray","keys","key","json","object","indexOf","integrateFolders","_x9","_integrateFolders","setDataReceivingProgress","_ref","Promise","all","getRoute","getEstimateTime","_ref2","_slicedToArray","Route","EstimateTime","time_formatting_mode","getSettingOptionValue","power_saving","refresh_interval_setting","StopIDs","folderWithContent1","i","l","batchFoundEstimateTime","EstimateTimeItem","StopID","folderWithContent2","integratedFolder","item","integratedItem","thisStopKey","thisEstimateTime","status","parseEstimateTime","thisRoute","route","pathAttributeId","pid","dataUpdateTime","getDataUpdateTime","deleteDataUpdateTime","dynamic","collectUpdateRateData","collectBusArrivalTimeData","saveToFolder","_x0","_x1","_saveToFolder","contentKey","isFolderContentSaved","_x10","_x11","_isFolderContentSaved","folderContentKeyToCheck","removeFromFolder","_x12","_x13","_x14","_removeFromFolder","index","splice","lfRemoveItem","saveStop","_x15","_x16","_x17","_saveStop","RouteID","Stop","getStop","Location","getLocation","thisStop","thisStopDirection","parseInt","goBack","thisStopName","stopLocationId","n","thisRouteName","thisRouteDeparture","dep","thisRouteDestination","des","newContent","direction","endPoints","departure","destination","saveRoute","_x18","_x19","_saveRoute","thisRouteKey","saveLocation","_x20","_x21","_saveLocation","hash","thisLocationKey","thisLocation","updateFolderContentIndex","_x22","_x23","_x24","_x25","_updateFolderContentIndex","offset","importFolders","_importFolders","data","FolderWithContent","update","creation","importSettings","_importSettings","SettingWithOption","existingSetting","getSetting","changeSettingOption","option","importPersonalSchedules","_importPersonalSchedules","PersonalSchedule","getPersonalSchedule","updatePersonalSchedule","createPersonalSchedule","period","start","hours","minutes","end","days","_importRecentViews","RecentView","getRecentView","logRecentView","importData","_importData","parsedData","importRecentViews","integrateLocationDetails","_integrateLocationDetails","actions","actionsQuantity","action","openSaveToFolder","shareLocationPermalink","showLocationPermalinkQRCode","rankBatchFoundEstimateTime","StopIDList","rankingArray","thisBatchFoundEstimateTimeItem","thisStopID","rankingArrayLength","rankingItem","rankingRatio","rankingCode","number","text","toString","code","integrateLocation","_integrateLocation","chartWidth","chartHeight","_yield$Promise$all","getBusEvent","getBusData","getBusArrivalTimes","_yield$Promise$all2","BusEvent","BusData","BusArrivalTimes","location_labels","display_user_orientation","groupedItems","itemQuantity","groups","userOrientation","getUserOrientation","thisLocationName","stopLocationIds","setsOfVectors","v","RouteIDs","stopLocationQuantity","j","s","r","batchFindEstimateTime","batchFoundBuses","batchFindBusesForLocation","cardinalDirections","vectorSet","x","y","vector","meanVector","normalizeVector","cardinalDirection","getCardinalDirectionFromVector","labels","generateLabelFromAddresses","generateLetterLabels","generateDirectionLabels","groupKey","properties","value","addressToString","la","toFixed","lo","thisGroupStops","stopQuantity","thisGroupRanking","o","stopId","thisItemRanking","ranking","thisRouteID","route_name","route_direction","routeId","parsedEstimateTime","buses","map","e","formatBus","thisBusArrivalTimes","busArrivalTimes","groupQuantity","LocationName"],"sourceRoot":""}