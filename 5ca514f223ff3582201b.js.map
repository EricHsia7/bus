{"version":3,"file":"5ca514f223ff3582201b.js","mappings":"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","sources":["webpack://bus/./src/tools/path.ts","webpack://bus/./src/tools/time.ts","webpack://bus/./src/data/storage/index.ts","webpack://bus/./src/data/analytics/data-usage/getDataUsageStats-worker.ts","webpack://bus/./src/tools/math.ts"],"sourcesContent":["export type Segment = [x: number, y: number];\n\nexport type Segments = Array<Segment>;\n\nfunction distanceToSegment(point: Segment, start: Segment, end: Segment): number {\n  let dx = end[0] - start[0];\n  let dy = end[1] - start[1];\n  const d = dx * dx + dy * dy;\n  const t = ((point[0] - start[0]) * dx + (point[1] - start[1]) * dy) / d;\n\n  if (t < 0) {\n    dx = point[0] - start[0];\n    dy = point[1] - start[1];\n  } else if (t > 1) {\n    dx = point[0] - end[0];\n    dy = point[1] - end[1];\n  } else {\n    const closestPoint = [start[0] + t * dx, start[1] + t * dy];\n    dx = point[0] - closestPoint[0];\n    dy = point[1] - closestPoint[1];\n  }\n\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function simplifyPath(points: Segments, tolerance: number): Segments {\n const length1 = points.length - 1;\n  if (length1 < 2) {\n    return points;\n  }\n\n  let dmax = 0;\n  let index = 0;\n\n  // Find the point with the maximum distance\n  for (let i = 1; i < length1; i++) {\n    const d = distanceToSegment(points[i], points[0], points[length1]);\n    if (d > dmax) {\n      index = i;\n      dmax = d;\n    }\n  }\n\n  // If max distance is greater than tolerance, split the curve\n  if (dmax > tolerance) {\n    const leftPoints = points.slice(0, index + 1);\n    const rightPoints = points.slice(index);\n    const simplifiedLeft = simplifyPath(leftPoints, tolerance);\n    const simplifiedRight = simplifyPath(rightPoints, tolerance);\n    simplifiedLeft.pop();\n    return simplifiedLeft.concat(simplifiedRight);\n  } else {\n    return [points[0], points[length1]];\n  }\n}\n\nexport function segmentsToPath(segments: Segments): string {\n  const segmentsLength1 = segments.length - 1;\n  if (segmentsLength1 < 0) {\n    return '';\n  }\n  const pathCommand = [`M${segments[0][0]} ${segments[0][1]}`];\n  for (let i = 1; i < segmentsLength1; i++) {\n    const current = segments[i];\n    const next = segments[i + 1] || current;\n    pathCommand.push(`Q${current[0]} ${current[1]} ${(current[0] + next[0]) / 2} ${(current[1] + next[1]) / 2}`);\n  }\n  const lastPoint = segments[segmentsLength1];\n  pathCommand.push(`L${lastPoint[0]} ${lastPoint[1]}`);\n  return pathCommand.join(' ');\n}\n","export function getThisWeekOrigin(): Date {\n  const today: Date = new Date();\n  const dayOfToday: number = today.getDay();\n  const originDate: number = today.getDate() - dayOfToday;\n  const origin: Date = new Date();\n  origin.setDate(originDate);\n  origin.setHours(0);\n  origin.setMinutes(0);\n  origin.setSeconds(0);\n  origin.setMilliseconds(0);\n  return origin;\n}\n\nexport function offsetDate(origin: Date, date: number, hours: number, minutes: number): Date {\n  const duplicatedOrigin = new Date();\n  duplicatedOrigin.setDate(1);\n  duplicatedOrigin.setMonth(0);\n  duplicatedOrigin.setHours(hours);\n  duplicatedOrigin.setMinutes(minutes);\n  duplicatedOrigin.setSeconds(0);\n  duplicatedOrigin.setMilliseconds(0);\n  duplicatedOrigin.setFullYear(origin.getFullYear());\n  duplicatedOrigin.setMonth(origin.getMonth());\n  duplicatedOrigin.setDate(origin.getDate());\n  duplicatedOrigin.setDate(duplicatedOrigin.getDate() + date);\n  return duplicatedOrigin;\n}\n\nexport function timeStampToNumber(string: string): number {\n  const regex = /[0-9\\.]*/gm;\n  const match = string.match(regex);\n  if (match) {\n    const year = parseInt(match[0]);\n    const month = parseInt(match[2]);\n    const date = parseInt(match[4]);\n    const hours = parseInt(match[6]);\n    const minutes = parseInt(match[8]);\n    const seconds = parseInt(match[10]);\n    const date_object = new Date();\n    date_object.setDate(1);\n    date_object.setMonth(0);\n    date_object.setFullYear(year);\n    date_object.setMonth(month - 1);\n    date_object.setDate(date);\n    date_object.setHours(hours);\n    date_object.setMinutes(minutes);\n    date_object.setSeconds(seconds);\n    return date_object.getTime();\n  }\n  return 0;\n}\n\nexport function dateToString(date: Date, template: string = 'YYYY-MM-DD hh:mm:ss'): string {\n  const result = template\n    .replaceAll(/Y{4,4}/g, date.getFullYear())\n    .replaceAll(/M{2,2}/g, String(date.getMonth() + 1).padStart(2, '0'))\n    .replaceAll(/D{2,2}/g, String(date.getDate()).padStart(2, '0'))\n    .replaceAll(/h{2,2}/g, String(date.getHours()).padStart(2, '0'))\n    .replaceAll(/m{2,2}/g, String(date.getMinutes()).padStart(2, '0'))\n    .replaceAll(/s{2,2}/g, String(date.getSeconds()).padStart(2, '0'));\n  return result;\n}\n\nexport function dateToRelativeTime(date: Date): string {\n  const time = date.getTime();\n  const seconds = Math.floor((new Date().getTime() - time) / 1000);\n  let interval = Math.floor(seconds / 31536000); // seconds in a year\n  if (interval >= 1) {\n    return `${interval}年前`;\n  }\n  interval = Math.floor(seconds / 2592000); // seconds in a month\n  if (interval >= 1) {\n    return `${interval}個月前`;\n  }\n  interval = Math.floor(seconds / 86400); // seconds in a day\n  if (interval >= 1) {\n    return `${interval}天前`;\n  }\n  interval = Math.floor(seconds / 3600); // seconds in an hour\n  if (interval >= 1) {\n    return `${interval}小時前`;\n  }\n  interval = Math.floor(seconds / 60); // seconds in a minute\n  if (interval >= 1) {\n    return `${interval}分鐘前`;\n  }\n  if (seconds > 0) {\n    return `${seconds}秒前`;\n  }\n  return '現在';\n}\n\nexport function formatTime(time: number, mode: number): string {\n  const roundedTime = time | 0;\n  switch (mode) {\n    case 0: {\n      return `${roundedTime}秒`;\n      break;\n    }\n    case 1: {\n      const minutes = String((roundedTime - (roundedTime % 60)) / 60);\n      const seconds = String(roundedTime % 60);\n      return [minutes, seconds].map((u) => u.padStart(2, '0')).join(':');\n      break;\n    }\n    case 2: {\n      const minutes = (roundedTime / 60) | 0;\n      return `${minutes}分`;\n      break;\n    }\n    case 3: {\n      if (roundedTime >= 60 * 60) {\n        const hours = parseFloat((roundedTime / (60 * 60)).toFixed(1));\n        return `${hours}時`;\n      }\n      if (60 <= roundedTime && roundedTime < 60 * 60) {\n        const minutes = (roundedTime / 60) | 0;\n        return `${minutes}分`;\n      }\n      if (roundedTime < 60) {\n        return `${roundedTime}秒`;\n      }\n      break;\n    }\n    default: {\n      return '--';\n      break;\n    }\n  }\n}\n\nexport type WeekDayIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n// 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, 4: Thursday, 5: Friday, 6: Saturday\n\nexport type WeekDayIndexArray = Array<WeekDayIndex>;\n\nexport type WeekDayName = '日' | '一' | '二' | '三' | '四' | '五' | '六';\n\nexport interface WeekDay {\n  name: WeekDayName;\n  day: WeekDayIndex;\n  code: string;\n}\n\nexport function indexToDay(index: WeekDayIndex): WeekDay {\n  const days = [\n    {\n      name: '日',\n      day: 0,\n      code: 'd_0'\n    },\n    {\n      name: '一',\n      day: 1,\n      code: 'd_1'\n    },\n    {\n      name: '二',\n      day: 2,\n      code: 'd_2'\n    },\n    {\n      name: '三',\n      day: 3,\n      code: 'd_3'\n    },\n    {\n      name: '四',\n      day: 4,\n      code: 'd_4'\n    },\n    {\n      name: '五',\n      day: 5,\n      code: 'd_5'\n    },\n    {\n      name: '六',\n      day: 6,\n      code: 'd_6'\n    }\n  ];\n  return days[index];\n}\n\nexport function dateValueToDayOfWeek(dateValue: string): WeekDay {\n  const int = parseInt(dateValue);\n  const index = int - 1;\n  return indexToDay(index);\n}\n\nexport interface TimeObject {\n  hours: number;\n  minutes: number;\n}\n\nexport interface TimePeriod {\n  start: TimeObject;\n  end: TimeObject;\n}\n\nexport interface TimeStampPeriod {\n  start: Date;\n  end: Date;\n}\n\nexport function timeObjectToString(timeObject: TimeObject): string {\n  return `${String(timeObject.hours).padStart(2, '0')}:${String(timeObject.minutes).padStart(2, '0')}`;\n}\n\nexport function createDateObjectFromDate(year: number, month: number, date: number): Date {\n  const dateObject = new Date();\n  dateObject.setDate(1); // Set to the first day of the month to prevent date from being clamped\n  dateObject.setMonth(0);\n  dateObject.setFullYear(year);\n  dateObject.setMonth(month - 1);\n  dateObject.setDate(date);\n  dateObject.setHours(0);\n  dateObject.setMinutes(0);\n  dateObject.setSeconds(0);\n  dateObject.setMilliseconds(0);\n  return dateObject;\n}\n\nexport function maxConcurrency(periods: Array<TimePeriod>): number {\n  let events: Array<[number, 1 | -1]> = [];\n\n  // Convert periods into events\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, 1]); // Start of a period\n    events.push([end.hours * 60 + end.minutes, -1]); // End of a period\n  }\n\n  // Sort events: Primary by time, secondary by type (-1 before +1)\n  events.sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]));\n\n  let maxCount = 0;\n  let currentCount = 0;\n\n  // Sweep through the events\n  for (let [, type] of events) {\n    currentCount += type;\n    maxCount = Math.max(maxCount, currentCount);\n  }\n\n  return maxCount;\n}\n\nexport function assignTracks(periods: Array<TimePeriod>): Array<Array<TimePeriod>> {\n  if (periods.length === 0) return [];\n\n  // Convert periods into events\n  let events: Array<[number, number, number]> = [];\n  let index = 0;\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, end.hours * 60 + end.minutes, index]);\n    index += 1;\n  }\n\n  // Sort intervals by start time\n  events.sort((a, b) => a[0] - b[0]);\n\n  let tracks = [];\n  for (let [start, end, index] of events) {\n    let assigned = false;\n    for (let i = 0; i < tracks.length; i++) {\n      if (tracks[i][tracks[i].length - 1][1] <= start) {\n        tracks[i].push([start, end, index]);\n        assigned = true;\n        break;\n      }\n    }\n    if (!assigned) {\n      tracks.push([[start, end, index]]);\n    }\n  }\n\n  let i = 0;\n  for (const track of tracks) {\n    let j = 0;\n    for (const event of track) {\n      tracks[i][j] = periods[event[2]];\n      j += 1;\n    }\n    i += 1;\n  }\n\n  return tracks;\n}\n","const localforage = require('localforage');\n\nlet storage = {\n  cacheStore: false, // 0\n  settingsStore: false, // 1\n  dataUsageStatsStore: false, // 2\n  updateRateDataStore: false, // 3\n  updateRateDataWriteAheadLogStore: false, // 4\n  busArrivalTimeDataWriteAheadLogStore: false, // 5\n  busArrivalTimeDataStore: false, // 6\n  personalScheduleStore: false, // 7\n  recentViewsStore: false, // 8\n  notificationStore: false, // 9\n  notificationScheduleStore: false, // 10\n  folderListStore: false, // 11\n  folderContentIndexStore: false, // 12\n  folderContentStore: false // 13\n};\n\nconst stores = ['cacheStore', 'settingsStore', 'dataUsageStatsStore', 'updateRateDataStore', 'updateRateDataWriteAheadLogStore', 'busArrivalTimeDataWriteAheadLogStore', 'busArrivalTimeDataStore', 'personalScheduleStore', 'recentViewsStore', 'notificationStore', 'notificationScheduleStore', 'folderListStore', 'folderContentIndexStore', 'folderContentStore'];\n\nasync function dropInstance(store: number): Promise<any> {\n  const storeKey = stores[store];\n  if (storage[storeKey] === false) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n  }\n  const operation = await storage[storeKey].dropInstance();\n  return operation;\n}\n\nexport async function lfSetItem(store: number, key: string, value: any): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].setItem(key, value);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfGetItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].getItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfRemoveItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].removeItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfListItemKeys(store: number): Promise<Array<string>> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const keys = await storage[storeKey].keys();\n    return keys;\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n}\n\nexport function getStoreKey(store: number): string {\n  return stores[store];\n}\n\nexport function getStoresLength(): number {\n  return stores.length;\n}\n\n/*\nexport async function registerStore(id: string): Promise<number> {\n  const storeKey = `F${id}Store`;\n  if (!storage.hasOwnProperty(storeKey) && stores.indexOf(storeKey) < 0) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n    stores.push(storeKey);\n    return stores.length - 1;\n  } else {\n    return stores.indexOf(storeKey);\n  }\n}\n*/\n\nexport async function isStoragePersistent(): Promise<boolean> {\n  // Check if site's storage has been marked as persistent\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persisted();\n      return isPersisted;\n    }\n  }\n  return false;\n}\n\nexport async function askForPersistentStorage(): Promise<'granted' | 'denied' | 'unsupported'> {\n  // Request persistent storage for site\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persist();\n      return isPersisted ? 'granted' : 'denied';\n    }\n  }\n  return 'unsupported';\n}\n","import { findGlobalExtrema } from '../../../tools/math';\nimport { Segments, segmentsToPath, simplifyPath } from '../../../tools/path';\nimport { createDateObjectFromDate } from '../../../tools/time';\nimport { DataUsagePeriod, DataUsageStats, DataUsageStatsChunkArray } from './index';\n\nself.onmessage = function (e) {\n  const result = processWorkerTask(e.data);\n  self.postMessage(result); // Send the result back to the main thread\n};\n\ntype data = [dataUsageStatsChunks: DataUsageStatsChunkArray, width: number, height: number, padding: number];\n\nconst minutesPerDay = 60 * 24;\n\n// Main processing function\nfunction processWorkerTask(data: data): DataUsageStats {\n  const [dataUsageStatsChunks, width, height, padding] = data;\n\n  const dataUsageStatsChunksLength = dataUsageStatsChunks.length;\n\n  const extrema: Array<number> = [];\n  let sum: number = 0;\n  for (const dataUsageStatsChunk of dataUsageStatsChunks) {\n    extrema.push(dataUsageStatsChunk.stats.max, dataUsageStatsChunk.stats.min);\n    sum += dataUsageStatsChunk.stats.sum;\n  }\n\n  const globalExtrema = findGlobalExtrema(extrema);\n  const max = globalExtrema[1];\n  const min = globalExtrema[0];\n\n  const start = dataUsageStatsChunks[0].date;\n  const end = dataUsageStatsChunks[dataUsageStatsChunksLength - 1].date;\n  const startDate = createDateObjectFromDate(start[0], start[1], start[2]);\n  const endDate = createDateObjectFromDate(end[0], end[1], end[2]);\n\n  const points: Segments = [];\n  let cumulative: number = 0;\n  let lastX: number = 0;\n  for (let i = 0; i < dataUsageStatsChunksLength; i++) {\n    const dataUsageStatsChunk = dataUsageStatsChunks[i];\n    if (dataUsageStatsChunk.stats.sum === 0) {\n      const x1 = padding + (i / (DataUsagePeriod + 1)) * width;\n      const x2 = padding + ((i + (minutesPerDay - 1) / minutesPerDay) / (DataUsagePeriod + 1)) * width;\n      const y = padding + height;\n      points.push([x1, y]);\n      points.push([x2, y]);\n      lastX = x2;\n      continue;\n    }\n    const data = dataUsageStatsChunk.data;\n    for (let j = 0; j < minutesPerDay; j++) {\n      cumulative += data[j];\n      const x = padding + ((i + j / minutesPerDay) / (DataUsagePeriod + 1)) * width;\n      const y = padding + (1 - cumulative / sum) * height;\n      points.push([x, y]);\n      lastX = x;\n    }\n  }\n\n  // X-axis (horizontal)\n  const xAxis = `<line x1=\"${padding}\" y1=\"${height + padding}\" x2=\"${padding + width}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Y-axis (vertical)\n  const yAxis = `<line x1=\"${padding}\" y1=\"${padding}\" x2=\"${padding}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Axis Labels\n  const xAxisLabel = `<text x=\"${padding + width / 2}\" y=\"${padding + height + padding}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\">時間</text>`;\n  const yAxisLabel = `<text x=\"${padding / 2}\" y=\"${padding + height / 2}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\" transform=\"rotate(-90, ${padding * 0.7}, ${padding + height / 2})\">累計傳輸量</text>`;\n\n  // Paths\n  const simplifiedPath = simplifyPath(points, 1.1);\n  const pathData = segmentsToPath(simplifiedPath);\n  const fillingPathData = `M${padding},${height + padding} ${pathData} L${lastX},${height + padding} L${padding},${height + padding}`;\n  const path = `<path d=\"${pathData}\" fill=\"none\" stroke=\"var(--b-cssvar-main-color)\" stroke-width=\"0.9\" stroke-linecap=\"round\" stroke-linejoin=\"round\" opacity=\"1\"></path>`;\n  const fillingPath = `<path d=\"${fillingPathData}\" stroke=\"none\" stroke-width=\"0\" fill=\"url(#grad1)\"></path>`;\n  const filling = `<linearGradient id=\"grad1\" x1=\"50%\" y1=\"0%\" x2=\"50%\" y2=\"100%\"><stop offset=\"0%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.3);\" /><stop offset=\"73%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.09);\" /><stop offset=\"100%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0);\" /></linearGradient>`;\n\n  // SVG\n  const chart = /*html*/ `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width + padding * 2} ${height + padding * 2}\"><defs>${filling}</defs>${fillingPath}${path}${xAxis}${yAxis}${xAxisLabel}${yAxisLabel}</svg>`;\n\n  const result: DataUsageStats = {\n    stats: {\n      max,\n      min,\n      sum\n    },\n    period: {\n      start: startDate,\n      end: endDate\n    },\n    chart\n  };\n\n  // Send the result back to the main thread\n  return result;\n}\n","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\n/**\n * get the unit vecotr towards the same direction\n * @param vector [a1, a2, a3, ...]\n * @returns [b1, b2, b3, ...]\n */\n\nexport function normalizeVector(vector: Array<number>): Array<number> {\n  const length = Math.hypot(vector);\n  const componentQuantity = vector.length;\n  const newVector = new Float32Array(componentQuantity);\n  if (length > 0) {\n    const scale = 1 / length;\n    for (let i = componentQuantity; i > 0; i--) {\n      newVector[i] = vector[i] * scale;\n    }\n    return Array.from(newVector);\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function findGlobalExtrema(array: Array<number>): [minimum: number, maximum: number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n"],"names":["distanceToSegment","point","start","end","dx","dy","d","t","closestPoint","Math","sqrt","simplifyPath","points","tolerance","length1","length","dmax","index","i","leftPoints","slice","rightPoints","simplifiedLeft","simplifiedRight","pop","concat","createDateObjectFromDate","year","month","date","dateObject","Date","setDate","setMonth","setFullYear","setHours","setMinutes","setSeconds","setMilliseconds","require","self","onmessage","e","result","data","_step","_data","_slicedToArray","dataUsageStatsChunks","width","height","padding","dataUsageStatsChunksLength","extrema","sum","_iterator","_createForOfIteratorHelper","s","n","done","dataUsageStatsChunk","value","push","stats","max","min","err","f","globalExtrema","array","arrayLength","Infinity","item","findGlobalExtrema","startDate","endDate","cumulative","lastX","j","minutesPerDay","x","y","x1","x2","xAxis","yAxis","xAxisLabel","yAxisLabel","pathData","segments","segmentsLength1","pathCommand","current","next","lastPoint","join","segmentsToPath","period","chart","processWorkerTask","postMessage"],"ignoreList":[],"sourceRoot":""}