{"version":3,"file":"c91d854883b58786a43f.js","mappings":"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","sources":["webpack://bus/./src/data/folder/index.ts"],"sourcesContent":["import { MaterialSymbols } from '../../interface/icons/material-symbols-type';\nimport { generateLabelFromAddresses } from '../../tools/address';\nimport { CardinalDirection, getCardinalDirectionFromVector } from '../../tools/cardinal-direction';\nimport { generateIdentifier } from '../../tools/index';\nimport { generateDirectionLabels, generateLetterLabels } from '../../tools/labels';\nimport { normalizeVector } from '../../tools/math';\nimport { collectBusArrivalTimeData } from '../analytics/bus-arrival-time/index';\nimport { collectUpdateRateData } from '../analytics/update-rate/index';\nimport { EstimateTimeItem, getEstimateTime } from '../apis/getEstimateTime/index';\nimport { getLocation, MergedLocation, MergedLocationItem, SimplifiedLocation } from '../apis/getLocation/index';\nimport { getMaterialSymbolsSearchIndex } from '../apis/getMaterialSymbolsSearchIndex/index';\nimport { getRoute, SimplifiedRoute, SimplifiedRouteItem } from '../apis/getRoute/index';\nimport { getStop, SimplifiedStop } from '../apis/getStop/index';\nimport { EstimateTimeStatus, parseEstimateTime } from '../apis/index';\nimport { deleteDataReceivingProgress, deleteDataUpdateTime, getDataUpdateTime, setDataReceivingProgress } from '../apis/loader';\nimport { getSettingOptionValue, SettingSelectOptionRefreshIntervalValue } from '../settings/index';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\n\ninterface FolderContentRouteEndPoints {\n  departure: string;\n  destination: string;\n}\n\nexport interface FolderContentStopRoute {\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n  id: number;\n}\n\nexport interface FolderContentStop {\n  type: 'stop';\n  id: number;\n  timestamp: number;\n  name: string;\n  direction: number;\n  route: FolderContentStopRoute;\n}\n\nexport interface FolderContentRoute {\n  type: 'route';\n  id: number;\n  timestamp: number;\n  name: string;\n  endPoints: FolderContentRouteEndPoints;\n}\n\nexport interface FolderContentLocation {\n  type: 'location';\n  id: string; // hash\n  timestamp: number;\n  name: string;\n}\n\nexport interface FolderContentBus {\n  type: 'bus';\n  id: number; // CarID\n  timestamp: number;\n  busID: string; // BusID\n}\n\nexport interface FolderContentEmpty {\n  type: 'empty';\n  id: number;\n}\n\nexport type FolderContent = FolderContentStop | FolderContentRoute | FolderContentLocation | FolderContentBus | FolderContentEmpty;\n\nexport interface Folder {\n  name: string;\n  icon: MaterialSymbols;\n  id: string;\n  timestamp: number;\n}\n\nexport type FolderArray = Array<Folder>;\n\nexport interface FolderWithContent extends Folder {\n  content: Array<FolderContent>;\n  contentLength: number;\n}\n\nexport type FolderWithContentArray = Array<FolderWithContent>;\n\nconst FolderList: { [key: string]: Folder } = {};\n\nexport async function initializeFolderList() {\n  const folderKeys = await lfListItemKeys(11);\n  for (const folderKey of folderKeys) {\n    const thisFolderJSON = await lfGetItem(11, folderKey);\n    if (thisFolderJSON) {\n      const thisFolderObject = JSON.parse(thisFolderJSON) as Folder;\n      if (!FolderList.hasOwnProperty(folderKey)) {\n        FolderList[folderKey] = thisFolderObject;\n      }\n    }\n  }\n}\n\nexport async function createFolder(name: Folder['name'], icon: Folder['icon']): Promise<Folder['id'] | false> {\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!materialSymbolsSearchIndex.symbols.hasOwnProperty(icon)) return false;\n\n  // Check existence\n  const folderID = generateIdentifier();\n  const folderKey = `f_${folderID}`;\n  if (FolderList.hasOwnProperty(folderKey)) {\n    return false;\n  }\n  const existingFolder = await lfGetItem(11, folderKey);\n  if (existingFolder) {\n    return false;\n  }\n\n  // Generate folder\n  const nowTime = new Date().getTime();\n  let newFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: nowTime\n  };\n\n  // Save folder\n  FolderList[folderKey] = newFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(newFolder));\n  await lfSetItem(12, folderKey, JSON.stringify([]));\n  return folderID;\n}\n\nexport async function updateFolder(folderID: Folder['id'], name: Folder['name'], icon: Folder['icon']): Promise<boolean> {\n  const folderKey: string = `f_${folderID}`;\n\n  // Check existence\n  const existingFolderJSON = await lfGetItem(11, folderKey);\n  if (!existingFolderJSON) {\n    return false;\n  }\n  const existingFolderObject = JSON.parse(existingFolderJSON) as Folder;\n\n  // Validate icon\n  const requestID = generateIdentifier();\n  const materialSymbolsSearchIndex = await getMaterialSymbolsSearchIndex(requestID);\n  deleteDataReceivingProgress(requestID);\n  if (!materialSymbolsSearchIndex.symbols.hasOwnProperty(icon)) return false;\n\n  // Generate folder\n  const modifiedFolder: Folder = {\n    name: name,\n    icon: icon,\n    id: folderID,\n    timestamp: existingFolderObject.timestamp\n  };\n\n  // Save folder\n  FolderList[folderKey] = modifiedFolder;\n  await lfSetItem(11, folderKey, JSON.stringify(modifiedFolder));\n  return true;\n}\n\nexport function getFolder(folderID: Folder['id']): Folder | false {\n  const folderKey: string = `f_${folderID}`;\n  if (!FolderList.hasOwnProperty(folderKey)) {\n    return false;\n  }\n  const folderObject: Folder = {\n    name: FolderList[folderKey].name,\n    icon: FolderList[folderKey].icon,\n    id: FolderList[folderKey].id,\n    timestamp: FolderList[folderKey].timestamp\n  };\n  return folderObject;\n  // return cloneDeep(Folders[folderKey]);\n}\n\nexport function listFolders(): FolderArray {\n  const result = [];\n  for (const folderKey in FolderList) {\n    const folderObject: Folder = {\n      name: FolderList[folderKey].name,\n      icon: FolderList[folderKey].icon,\n      id: FolderList[folderKey].id,\n      timestamp: FolderList[folderKey].timestamp\n    };\n    result.push(folderObject);\n  }\n  result.sort(function (a, b) {\n    return a.timestamp - b.timestamp;\n  });\n  return result;\n}\n\nexport async function listFolderContent(folderID: Folder['id']): Promise<Array<FolderContent>> {\n  const result: Array<FolderContent> = [];\n\n  const folderKey: string = `f_${folderID}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return result;\n  }\n\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return result;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0) {\n    const emptyItem: FolderContentEmpty = {\n      type: 'empty',\n      id: 0,\n      index: 0\n    };\n    result.push(emptyItem);\n    return result;\n  }\n\n  for (const thisFolderContentKey of thisFolderContentIndexArray) {\n    const thisContentJSON = await lfGetItem(13, thisFolderContentKey);\n    if (thisContentJSON) {\n      const thisContentObject = JSON.parse(thisContentJSON) as FolderContent;\n      result.push(thisContentObject);\n    }\n  }\n  return result;\n}\n\nasync function getFolderContentLength(folderID: Folder['id']): Promise<number> {\n  const folderKey: string = `f_${folderID}`;\n  const thisFolderContentIndexJSON = await lfGetItem(12, folderKey);\n  if (!thisFolderContentIndexJSON) {\n    return 0;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  return thisFolderContentIndexArray.length;\n}\n\nexport async function listFoldersWithContent(): Promise<FolderWithContentArray> {\n  const folders = await listFolders();\n  const result: FolderWithContentArray = [];\n  for (const folder of folders) {\n    const folderContent = await listFolderContent(folder.id);\n    const folderContentLength = await getFolderContentLength(folder.id);\n    result.push({\n      name: folder.name,\n      icon: folder.icon,\n      id: folder.id,\n      timestamp: folder.timestamp,\n      content: folderContent,\n      contentLength: folderContentLength\n    });\n  }\n  return result;\n}\n\nexport async function listAllFolderContent(types: Array<FolderContent['type']>): Promise<Array<FolderContent>> {\n  let useFilter: boolean = true;\n  if (typeof types !== 'object' || !Array.isArray(types)) {\n    useFilter = false;\n  }\n  let result: Array<FolderContent> = [];\n  const keys = await lfListItemKeys(13);\n  for (const key of keys) {\n    const json = await lfGetItem(13, key);\n    if (json) {\n      const object = JSON.parse(json) as FolderContent;\n      if (useFilter) {\n        if (types.indexOf(object.type) > -1) {\n          result.push(object);\n        }\n      } else {\n        result.push(object);\n      }\n    }\n  }\n  return result;\n}\n\nexport interface integratedFolderContentStopRoute extends FolderContentStopRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentStop extends FolderContentStop {\n  status: EstimateTimeStatus;\n  route: integratedFolderContentStopRoute;\n}\n\nexport interface integratedFolderContentRoute extends FolderContentRoute {\n  pathAttributeId: Array<number>;\n}\n\nexport interface integratedFolderContentLocation extends FolderContentLocation {\n  // labels: string;\n}\n\nexport interface integratedFolderContentBus extends FolderContentBus {}\n\nexport interface integratedFolderContentEmpty extends FolderContentEmpty {}\n\nexport type integratedFolderContent = integratedFolderContentStop | integratedFolderContentRoute | integratedFolderContentLocation | integratedFolderContentBus | integratedFolderContentEmpty;\n\nexport interface integratedFolder extends Folder {\n  content: Array<integratedFolderContent>;\n  contentLength: number;\n}\n\nexport interface integratedFolders {\n  folders: Array<integratedFolder>;\n  dataUpdateTime: number;\n}\n\nexport async function integrateFolders(requestID: string): Promise<integratedFolders> {\n  setDataReceivingProgress(requestID, 'getEstimateTime_0', 0, false);\n  setDataReceivingProgress(requestID, 'getEstimateTime_1', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_0', 0, false);\n  setDataReceivingProgress(requestID, 'getRoute_1', 0, false);\n\n  const EstimateTime = await getEstimateTime(requestID);\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  // const Location = (await getLocation(requestID, 1)) as MergedLocation;\n\n  const foldersWithContent = await listFoldersWithContent();\n\n  const time_formatting_mode = getSettingOptionValue('time_formatting_mode') as number;\n  // const location_labels = getSettingOptionValue('location_labels');\n  const power_saving = getSettingOptionValue('power_saving') as boolean;\n  const refresh_interval_setting = getSettingOptionValue('refresh_interval') as SettingSelectOptionRefreshIntervalValue;\n\n  let StopIDs = [] as Array<number>;\n  for (const folderWithContent1 of foldersWithContent) {\n    StopIDs = StopIDs.concat(\n      folderWithContent1.content\n        .filter((m) => {\n          return m.type === 'stop' ? true : false;\n        })\n        .map((e) => e.id)\n    );\n  }\n\n  let batchFoundEstimateTime: { [key: string]: EstimateTimeItem } = {};\n  for (const EstimateTimeItem of EstimateTime) {\n    if (StopIDs.indexOf(EstimateTimeItem.StopID) > -1) {\n      const thisStopKey: string = `s_${EstimateTimeItem.StopID}`;\n      batchFoundEstimateTime[thisStopKey] = EstimateTimeItem;\n    }\n  }\n\n  let folders: integratedFolders['folders'] = [];\n\n  for (const folderWithContent2 of foldersWithContent) {\n    // Initialize integratedFolder\n    const integratedFolder: integratedFolder = {\n      name: folderWithContent2.name,\n      icon: folderWithContent2.icon,\n      id: folderWithContent2.id,\n      timestamp: folderWithContent2.timestamp,\n      content: [],\n      contentLength: folderWithContent2.contentLength\n    };\n\n    for (let item of folderWithContent2.content) {\n      let integratedItem = item as integratedFolderContent;\n      switch (integratedItem.type) {\n        case 'stop': {\n          const thisStopKey = `s_${integratedItem.id}`;\n          let thisEstimateTime = {} as EstimateTimeItem;\n          if (batchFoundEstimateTime.hasOwnProperty(thisStopKey)) {\n            thisEstimateTime = batchFoundEstimateTime[thisStopKey];\n          } else {\n            break;\n          }\n          integratedItem.status = parseEstimateTime(thisEstimateTime.EstimateTime, time_formatting_mode);\n          const thisRouteKey = `r_${integratedItem.route.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.route.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'route': {\n          const thisRouteKey = `r_${integratedItem.id}`;\n          const thisRoute = Route[thisRouteKey] as SimplifiedRouteItem;\n          integratedItem.pathAttributeId = thisRoute.pid;\n          break;\n        }\n        case 'location': {\n          /*\n          const thisLocationKey = `ml_${integratedItem.id}`;\n          const thisLocation = Location[thisLocationKey] as MergedLocationItem;\n          let labels: Array<string> = [];\n          switch (location_labels) {\n            case 'address':\n              labels = generateLabelFromAddresses(thisLocation.a);\n              break;\n            case 'letters':\n              const stopLocationIds = thisLocation.id;\n              const stopLocationQuantity = stopLocationIds.length;\n              labels = generateLetterLabels(stopLocationQuantity);\n              break;\n            case 'directions':\n              const setsOfVectors = thisLocation.v;\n              const cardinalDirections: Array<CardinalDirection> = [];\n              for (const vectorSet of setsOfVectors) {\n                let x: number = 0;\n                let y: number = 0;\n                for (const vector of vectorSet) {\n                  x += vector[0];\n                  y += vector[1];\n                }\n                const meanVector = normalizeVector([x, y]) as [number, number];\n                const cardinalDirection = getCardinalDirectionFromVector(meanVector);\n                cardinalDirections.push(cardinalDirection);\n              }\n\n              labels = generateDirectionLabels(cardinalDirections);\n              break;\n            default:\n              break;\n          }\n          integratedItem.labels = labels.join(' - ');\n          */\n          break;\n        }\n        case 'bus':\n          break;\n        case 'empty':\n          break;\n        default:\n          break;\n      }\n      integratedFolder.content.push(integratedItem);\n    }\n    folders.push(integratedFolder);\n  }\n\n  const result: integratedFolders = {\n    folders: folders,\n    dataUpdateTime: getDataUpdateTime(requestID)\n  };\n\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n\n  if (!power_saving) {\n    if (refresh_interval_setting.dynamic) {\n      await collectUpdateRateData(EstimateTime);\n    }\n    await collectBusArrivalTimeData(EstimateTime);\n  }\n\n  return result;\n}\n\nexport async function saveToFolder(folderID: Folder['id'], content: FolderContent): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const contentKey = `${content.type}_${content.id}`;\n  const thisFolder = getFolder(folderID);\n\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  if (thisFolderContentIndexArray.length === 0 || thisFolderContentIndexArray.indexOf(contentKey) < 0) {\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray.concat(contentKey)));\n    await lfSetItem(13, contentKey, JSON.stringify(content));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport async function isFolderContentSaved(type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderContentKeyToCheck = `${type}_${id}`;\n\n  const keys = await lfListItemKeys(12);\n  for (const key of keys) {\n    const thisFolderContentIndexJSON = (await lfGetItem(12, key)) as string;\n    if (!thisFolderContentIndexJSON) {\n      continue;\n    }\n    const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n    if (thisFolderContentIndexArray.indexOf(folderContentKeyToCheck) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport async function removeFromFolder(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id']): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n\n  // Check existence\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  // Remove reference from folder content index\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 0) {\n    thisFolderContentIndexArray.splice(index, 1);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n  }\n\n  // Remove content if there are no other references\n  const isSaved = await isFolderContentSaved(type, id);\n  if (isSaved === false) {\n    await lfRemoveItem(13, thisFolderContentKey);\n  }\n  return true;\n}\n\nexport async function saveStop(folderID: Folder['id'], StopID: number, RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Stop = (await getStop(requestID)) as SimplifiedStop;\n  const Location = (await getLocation(requestID, 0)) as SimplifiedLocation;\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n\n  const thisStop = Stop[`s_${StopID}`];\n  const thisStopDirection: number = parseInt(thisStop.goBack);\n  const thisLocation = Location[`l_${thisStop.stopLocationId}`];\n  const thisStopName: string = thisLocation.n;\n\n  const thisRoute = Route[`r_${RouteID}`];\n  const thisRouteName: string = thisRoute.n;\n  const thisRouteDeparture: string = thisRoute.dep;\n  const thisRouteDestination: string = thisRoute.des;\n\n  const newContent: FolderContentStop = {\n    type: 'stop',\n    id: StopID,\n    timestamp: new Date().getTime(),\n    name: thisStopName,\n    direction: thisStopDirection,\n    route: {\n      name: thisRouteName,\n      endPoints: {\n        departure: thisRouteDeparture,\n        destination: thisRouteDestination\n      },\n      id: RouteID\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveRoute(folderID: Folder['id'], RouteID: number): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Route = (await getRoute(requestID, true)) as SimplifiedRoute;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisRouteKey = `r_${RouteID}`;\n  let thisRoute = {} as SimplifiedRouteItem;\n  if (Route.hasOwnProperty(thisRouteKey)) {\n    thisRoute = Route[thisRouteKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentRoute = {\n    type: 'route',\n    id: RouteID,\n    timestamp: new Date().getTime(),\n    name: thisRoute.n,\n    endPoints: {\n      departure: thisRoute.dep,\n      destination: thisRoute.des\n    }\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\nexport async function saveLocation(folderID: Folder['id'], hash: string): Promise<boolean> {\n  const requestID = generateIdentifier();\n  const Location = (await getLocation(requestID, 1)) as MergedLocation;\n  deleteDataReceivingProgress(requestID);\n  deleteDataUpdateTime(requestID);\n  const thisLocationKey = `ml_${hash}`;\n  let thisLocation = {} as MergedLocationItem;\n  if (Location.hasOwnProperty(thisLocationKey)) {\n    thisLocation = Location[thisLocationKey];\n  } else {\n    return false;\n  }\n\n  const newContent: FolderContentLocation = {\n    type: 'location',\n    id: hash,\n    timestamp: new Date().getTime(),\n    name: thisLocation.n\n  };\n  const save = await saveToFolder(folderID, newContent);\n  return save;\n}\n\n// TODO: Save Bus\n\nexport async function updateFolderContentIndex(folderID: Folder['id'], type: FolderContent['type'], id: FolderContent['id'], direction: 'up' | 'down'): Promise<boolean> {\n  const folderKey = `f_${folderID}`;\n  const thisFolderContentKey = `${type}_${id}`;\n  const thisFolder = getFolder(folderID);\n  if (typeof thisFolder === 'boolean' && thisFolder === false) {\n    return false;\n  }\n\n  const thisFolderContentIndexJSON = (await lfGetItem(12, folderKey)) as string;\n  if (!thisFolderContentIndexJSON) {\n    return false;\n  }\n  const thisFolderContentIndexArray = JSON.parse(thisFolderContentIndexJSON) as Array<string>;\n\n  const index = thisFolderContentIndexArray.indexOf(thisFolderContentKey);\n  if (index > -1 && thisFolderContentIndexArray.length > 1) {\n    let offset: number = 0;\n    switch (direction) {\n      case 'up':\n        offset = -1;\n        break;\n      case 'down':\n        offset = 1;\n        break;\n      default:\n        offset = 0;\n        break;\n    }\n    thisFolderContentIndexArray.splice(index, 1);\n    thisFolderContentIndexArray.splice(index + offset, 0, thisFolderContentKey);\n    await lfSetItem(12, folderKey, JSON.stringify(thisFolderContentIndexArray));\n    return true;\n  } else {\n    return false;\n  }\n}\n"],"names":["FolderList","initializeFolderList","_initializeFolderList","apply","arguments","_asyncToGenerator","_step","_iterator","_createForOfIteratorHelper","lfListItemKeys","s","n","done","folderKey","value","thisFolderJSON","lfGetItem","thisFolderObject","JSON","parse","hasOwnProperty","err","e","f","createFolder","_x","_x2","_createFolder","name","icon","requestID","generateIdentifier","materialSymbolsSearchIndex","getMaterialSymbolsSearchIndex","deleteDataReceivingProgress","symbols","folderID","newFolder","id","timestamp","Date","getTime","lfSetItem","stringify","updateFolder","_x3","_x4","_x5","_updateFolder","existingFolderJSON","existingFolderObject","modifiedFolder","getFolder","listFolderContent","_x6","_listFolderContent","result","thisFolder","thisFolderContentIndexJSON","thisFolderContentIndexArray","length","push","type","index","_step2","_iterator2","thisFolderContentKey","thisContentJSON","thisContentObject","getFolderContentLength","_x7","_getFolderContentLength","listFoldersWithContent","_listFoldersWithContent","_step3","folders","folderObject","sort","a","b","listFolders","_iterator3","folder","folderContent","folderContentLength","content","contentLength","listAllFolderContent","_x8","_listAllFolderContent","types","useFilter","_typeof","Array","isArray","_step4","_iterator4","key","json","object","indexOf","integrateFolders","_x9","_integrateFolders","setDataReceivingProgress","_step5","EstimateTime","getEstimateTime","Route","getRoute","foldersWithContent","time_formatting_mode","getSettingOptionValue","power_saving","refresh_interval_setting","StopIDs","_iterator5","folderWithContent1","concat","filter","m","map","_step6","batchFoundEstimateTime","_iterator6","EstimateTimeItem","StopID","_step7","_iterator7","_step8","folderWithContent2","integratedFolder","_iterator8","integratedItem","thisStopKey","thisEstimateTime","status","parseEstimateTime","thisRoute","route","pathAttributeId","pid","dataUpdateTime","getDataUpdateTime","deleteDataUpdateTime","dynamic","collectUpdateRateData","collectBusArrivalTimeData","saveToFolder","_x0","_x1","_saveToFolder","contentKey","isFolderContentSaved","_x10","_x11","_isFolderContentSaved","_step9","folderContentKeyToCheck","_iterator9","removeFromFolder","_x12","_x13","_x14","_removeFromFolder","splice","lfRemoveItem","saveStop","_x15","_x16","_x17","_saveStop","RouteID","Stop","getStop","Location","getLocation","thisStop","thisStopDirection","parseInt","goBack","thisStopName","stopLocationId","thisRouteName","thisRouteDeparture","dep","thisRouteDestination","des","newContent","direction","endPoints","departure","destination","saveRoute","_x18","_x19","_saveRoute","thisRouteKey","saveLocation","_x20","_x21","_saveLocation","hash","thisLocationKey","thisLocation","updateFolderContentIndex","_x22","_x23","_x24","_x25","_updateFolderContentIndex","offset"],"ignoreList":[],"sourceRoot":""}