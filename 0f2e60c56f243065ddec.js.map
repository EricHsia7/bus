{"version":3,"file":"0f2e60c56f243065ddec.js","mappings":"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","sources":["webpack://bus/./src/tools/array.ts","webpack://bus/./src/tools/labels.ts","webpack://bus/./src/tools/address.ts","webpack://bus/./src/tools/math.ts","webpack://bus/./src/tools/convert.ts","webpack://bus/./src/tools/graphic.ts","webpack://bus/./src/tools/index.ts"],"sourcesContent":["// Function to split data based on delta\n\n/**\n * Splits data into groups based on delta between consecutive elements.\n *\n * @param {Array<[number, number]>} data - Array of tuples where each tuple contains two numbers.\n * @returns {Array<Array<[number, number]>>} - Array of groups, each containing arrays of tuples.\n */\n\nexport function splitDataByDelta(data: Array<[number, number]>): Array<Array<[number, number]>> {\n  const result: Array<Array<[number, number]>> = [];\n  let currentGroup: Array<[number, number]> = [];\n\n  for (let i = 0; i < data.length; i++) {\n    if (i === 0 || data[i][0] - data[i - 1][0] > 0) {\n      if (currentGroup.length > 0) {\n        result.push(currentGroup);\n      }\n      currentGroup = [data[i]];\n    } else {\n      currentGroup.push(data[i]);\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    result.push(currentGroup);\n  }\n\n  return result;\n}\n\nexport function areItemsDifferent(arr: Array): boolean {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j]) {\n        return false; // Found a duplicate\n      }\n    }\n  }\n  return true; // No duplicates found\n}\n\n/**\n * Get common items from the two arrays\n * @param arrayA - The first array\n * @param arrayB - The second array\n * @returns An array of the common items\n */\n\nexport function getIntersection(arrayA: Array, arrayB: Array): Array {\n  let result = [];\n  if (arrayA.length <= arrayB.length) {\n    for (const item of arrayA) {\n      if (arrayB.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  } else {\n    for (const item of arrayB) {\n      if (arrayA.indexOf(item) > -1) {\n        result.push(item);\n      }\n    }\n  }\n  return result;\n}\n","import { convertNumberToLetters } from './convert';\nimport { convertToUnitVector } from './math';\n\nexport function generateLetterLabels(quantity: number): Array<string> {\n  let result = [];\n  for (let i = 0; i < quantity; i++) {\n    result.push(`地點${convertNumberToLetters(i + 1)}`);\n  }\n  return result;\n}\n\nexport function generateDirectionLabels(setsOfVectors: Array<Array<[number, number]>>): Array<string> {\n  let result = [];\n  const unknownVector = [0, 0];\n  // cardinal directions\n  const NorthVector = [0, 1];\n  const EastVector = [1, 0];\n  const WestVector = [-1, 0];\n  const SouthVector = [0, -1];\n  // intercardinal directions\n  const NorthEastVector = [Math.sqrt(2) / 2, Math.sqrt(2) / 2]; // 45 degrees\n  const SouthEastVector = [Math.sqrt(2) / 2, -Math.sqrt(2) / 2]; // 135 degrees\n  const SouthWestVector = [-Math.sqrt(2) / 2, -Math.sqrt(2) / 2]; // 225 degrees\n  const NorthWestVector = [-Math.sqrt(2) / 2, Math.sqrt(2) / 2]; // 315 degrees\n\n  const directions = [\n    {\n      vector: unknownVector,\n      label: '未知'\n    },\n    {\n      vector: NorthVector,\n      label: '北'\n    },\n    {\n      vector: EastVector,\n      label: '東'\n    },\n    {\n      vector: SouthVector,\n      label: '南'\n    },\n    {\n      vector: WestVector,\n      label: '西'\n    },\n    {\n      vector: NorthEastVector,\n      label: '東北'\n    },\n    {\n      vector: SouthEastVector,\n      label: '東南'\n    },\n    {\n      vector: SouthWestVector,\n      label: '西南'\n    },\n    {\n      vector: NorthWestVector,\n      label: '西北'\n    }\n  ];\n\n  for (const vectorSet of setsOfVectors) {\n    let x = 0;\n    let y = 0;\n    for (const vector of vectorSet) {\n      x += vector[0];\n      y += vector[1];\n    }\n    const meanVector = convertToUnitVector([x, y]);\n    let result2 = [];\n    for (const direction of directions) {\n      const dotProduct = direction.vector[0] * meanVector[0] + direction.vector[1] * meanVector[1];\n      result2.push({ label: direction.label, dotProduct: dotProduct });\n    }\n    result2 = result2.sort(function (a, b) {\n      return b.dotProduct - a.dotProduct;\n    });\n    const bestMatch = result2[0];\n    result.push(bestMatch.label);\n  }\n  return result;\n}\n","import { generateLetterLabels } from './labels';\nimport { areItemsDifferent } from './array';\n\ninterface AddressPart {\n  suffixes?: string;\n  key: keyof ParsedAddress;\n  process: (e: string[] | null) => string[] | number[] | null;\n  type: number;\n}\n\nexport interface ParsedAddress {\n  city: string[];\n  district: string[];\n  area: string[];\n  road: string[];\n  road_section: number[];\n  alley: number[];\n  alley_branch: number[];\n  doorplate: number[];\n  floornumber: string[];\n  exit: string[];\n  direction: string[];\n  [key: string]: string[] | number[] | null;\n}\n\ninterface FeatureCounts {\n  [key: string]: { count: number; chars: string; index: number };\n}\n\nexport function mergeAddressesIntoOne(addresses: Array<string>): ParsedAddress | string {\n  const parts: Array<AddressPart> = [\n    {\n      suffixes: '市',\n      key: 'city',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '區',\n      key: 'district',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '鄉鎮村里',\n      key: 'area',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '路街道',\n      key: 'road',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.replaceAll(/[\\(\\)\\（\\）]/gim, '').trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '段',\n      key: 'road_section',\n      process: function (e) {\n        var toNumber = function (char) {\n          switch (char) {\n            case '一':\n              return 1;\n              break;\n            case '二':\n              return 2;\n              break;\n            case '三':\n              return 3;\n              break;\n            case '四':\n              return 4;\n              break;\n            case '五':\n              return 5;\n              break;\n            case '六':\n              return 6;\n              break;\n            case '七':\n              return 7;\n              break;\n            case '八':\n              return 8;\n              break;\n            case '九':\n              return 9;\n              break;\n            case '十':\n              return 10;\n              break;\n          }\n          if (!isNaN(parseInt(char))) {\n            return parseInt(char);\n          }\n          return 0;\n        };\n        var len = String(e).length;\n        var numbers = [];\n        for (let i = 0; i < len; i++) {\n          var p = toNumber(String(e).charAt(i));\n          if (p === 10) {\n            if (numbers.length > 0) {\n              numbers = [numbers.reduce((a, b) => a + b, 0) * 10];\n            }\n          } else {\n            numbers = [numbers.reduce((a, b) => a + b, 0) + p];\n          }\n        }\n        return numbers;\n      },\n      type: 0\n    },\n    {\n      suffixes: '巷',\n      key: 'alley',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return parseInt(t.trim().replaceAll(/[巷]/gim));\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '弄',\n      key: 'alley_branch',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return parseInt(t.trim().replaceAll(/[弄]/gim));\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      suffixes: '號',\n      key: 'doorplate',\n      process: function (e) {\n        var numbers = String(e).match(/[0-9]+/gim);\n        numbers =\n          numbers?.map((n) => {\n            if (n === null) {\n              return null;\n            } else {\n              return parseInt(n);\n            }\n          }) || null;\n        return numbers;\n      },\n      type: 0\n    },\n    {\n      suffixes: '樓',\n      key: 'floornumber',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 0\n    },\n    {\n      key: 'exit',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim();\n          });\n        }\n      },\n      type: 2\n    },\n    {\n      key: 'direction',\n      process: function (e) {\n        if (e === null) {\n          return null;\n        } else {\n          return e.map((t) => {\n            return t.trim().replace(/[往向]/gim, '');\n          });\n        }\n      },\n      type: 1\n    }\n  ];\n\n  function parseAddress(address: string): object {\n    function regex(suffixes, type) {\n      if (type === 0) {\n        return new RegExp(`([^市區鄉鎮村里路段街道巷弄號樓與]+[${suffixes}])`, 'gmi');\n      }\n      if (type === 1) {\n        return new RegExp(`([往向]+[東南西北])`, 'gmi');\n      }\n      if (type === 2) {\n        return new RegExp(`([0-9]+[號]出口)`, 'gmi');\n      }\n    }\n    var result = {};\n    for (var part of parts) {\n      var r = regex(part?.suffixes, part.type);\n      result[part.key] = part.process(String(address).match(r));\n    }\n    return result;\n  }\n\n  function mergeAddresses(addresses: Array<string>): object {\n    var result = {};\n    for (var address of addresses) {\n      var parsedAddress = parseAddress(address);\n      for (var part of parts) {\n        if (!result.hasOwnProperty(part.key)) {\n          result[part.key] = [];\n        }\n        result[part.key] = result[part.key].concat(parsedAddress[part.key]);\n      }\n    }\n    for (var key in result) {\n      result[key] = Array.from(new Set(result[key]))\n        .filter((e) => (e ? true : false))\n        .sort(function (a, b) {\n          if (typeof a === 'number' && typeof b === 'number') {\n            return a - b;\n          } else {\n            return String(a).charCodeAt(0) - String(b).charCodeAt(0);\n          }\n        });\n    }\n    return result;\n  }\n  return mergeAddresses(addresses);\n}\n\nexport function addressToString(address: ParsedAddress): string {\n  return `${address.city.join('')}${address.district.join('')}${address.road.join('、')}${\n    address.road_section.sort(function (a, b) {\n      return a - b;\n    }).length > 0\n      ? address.road_section.join('、') + '段'\n      : ''\n  }${\n    address.alley.length > 0\n      ? address.alley\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '巷'\n      : ''\n  }${\n    address.alley_branch.length > 0\n      ? address.alley_branch\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '弄'\n      : ''\n  }${\n    address.doorplate.length > 0\n      ? address.doorplate\n          .sort(function (a, b) {\n            return a - b;\n          })\n          .join('、') + '號'\n      : ''\n  }${address.floornumber.length > 0 ? address.floornumber.join('、') + '樓' : ''}${address.direction.length > 0 ? '（朝' + address.direction.join('、') + '）' : ''}`;\n}\n\nexport function extractCommonFeaturesFromAddresses(addresses: Array<string>): string {\n  // Create an object to store feature occurrences\n  const featureCounts: { [key: string]: { count: number; chars: string; index: number } } = {};\n\n  // Create a set to store unique simplified addresses\n  const simplifiedSet = new Set<string>();\n\n  // Iterate through each address\n  for (const address of addresses) {\n    // Extract common features by splitting the address\n    const features = String(address)\n      .split('')\n      .filter((feature) => feature.trim() !== '');\n\n    // Join the extracted features to create a simplified address\n    const simplifiedAddress = features.join('');\n\n    // Add the simplified address to the set\n    simplifiedSet.add(simplifiedAddress);\n\n    // Count occurrences of each feature\n    let index = 0;\n    for (const feature of features) {\n      // Check if the feature is a digit\n      if (!isNaN(parseInt(feature))) {\n        // Create a key for the digit feature\n        const digitKey = `digit_${index}_${feature.charCodeAt(0)}`;\n        featureCounts[digitKey] = {\n          count: (featureCounts[digitKey]?.count || 0) + 1,\n          chars: feature,\n          index: index\n        };\n      } else {\n        // Create a key for non-digit features\n        const featureKey = `chars_${index}_${feature.charCodeAt(0)}`;\n        featureCounts[featureKey] = {\n          count: (featureCounts[featureKey]?.count || 0) + 1,\n          chars: feature,\n          index: index\n        };\n      }\n      index += 1;\n    }\n  }\n\n  // Set threshold and limit for filtering features\n  const threshold = addresses.length * 0.6;\n  const limit = addresses.length * 1;\n\n  // Convert the feature counts object to an array of [feature, count] pairs\n  const sortedFeatures = Object.entries(featureCounts)\n    .filter((pair) => threshold <= pair[1].count && pair[1].count <= limit)\n    .sort((a, b) => a[1].index - b[1].index);\n\n  // Extract the features from the sorted array\n  const commonFeatures = sortedFeatures.map((pair) => pair[1].chars);\n\n  return commonFeatures.join('');\n}\n\nexport function generateLabelFromAddresses(addresses: Array<ParsedAddress>): Array<string> {\n  let result = [];\n  let filledProperties = {};\n  for (const address of addresses) {\n    for (const key in address) {\n      if (!filledProperties.hasOwnProperty(key)) {\n        filledProperties[key] = 0;\n      }\n      if (address[key].length > 0) {\n        filledProperties[key] = filledProperties[key] + 1;\n      }\n    }\n  }\n  let commonProperties = Object.entries(filledProperties)\n    .map((property) => {\n      return { key: property[0], value: property[1] };\n    })\n    .filter((e) => {\n      return e.value === addresses.length ? true : false;\n    })\n    .sort(function (a, b) {\n      return a.value - b.value;\n    });\n  if (commonProperties.length > 0) {\n    for (const commonProperty of commonProperties) {\n      let components = [];\n      for (const address of addresses) {\n        components.push(address[commonProperty.key].join(''));\n      }\n      if (areItemsDifferent(components)) {\n        result.push({ components: components, len: Math.max(...components.map((e) => e.length)) });\n      }\n    }\n  }\n\n  if (result.length > 0) {\n    result = result.sort(function (a, b) {\n      return a.len - b.len;\n    });\n    return result[0].components;\n  } else {\n    const addressesLength = addresses.length;\n    return generateLetterLabels(addressesLength);\n  }\n}\n","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\nexport function convertToUnitVector(vector: Array<number>): Array<number> {\n  let length = Math.hypot(vector);\n  let newVector = [];\n  if (length > 0) {\n    let scale = 1 / length;\n    for (const x of vector) {\n      newVector.push(x * scale);\n    }\n    return newVector;\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  let result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function aggregateNumbers(array: Array<number>, exponent: number): Array<number> {\n  const arrLength = array.length;\n\n  if (arrLength < 3) {\n    return array;\n  }\n\n  let sum: number = 0;\n  for (let i = 0; i < arrLength; i++) {\n    sum += array[i];\n  }\n  let average = sum / arrLength;\n\n  let SquaredDeviationSum: number = 0;\n  for (let j = 0; j < arrLength; j++) {\n    SquaredDeviationSum += Math.pow(array[j] - average, 2);\n  }\n  const standardDeviation = Math.sqrt(SquaredDeviationSum / arrLength);\n\n  let exponentials = [];\n  let exponentialSum = 0;\n  for (let k = 0; k < arrLength; k++) {\n    const exponential = Math.exp(array[k] / standardDeviation);\n    exponentialSum += exponential;\n    exponentials.push(exponential);\n  }\n\n  let P = Math.pow(arrLength, exponent);\n  let groupedNumbers = {};\n  for (let l = 0; l < arrLength; l++) {\n    const key = `k_${Math.floor((exponentials[l] / exponentialSum) * P)}`;\n    if (!groupedNumbers.hasOwnProperty(key)) {\n      groupedNumbers[key] = {\n        sum: 0,\n        len: 0\n      };\n    }\n    groupedNumbers[key].sum += array[l];\n    groupedNumbers[key].len += 1;\n  }\n\n  let result = [];\n  for (const key in groupedNumbers) {\n    const thisGroup = groupedNumbers[key];\n    result.push(Math.floor(thisGroup.sum / thisGroup.len));\n  }\n\n  result.sort((a, b) => a - b);\n  return result;\n}\n\nexport function findExtremum(array: Array<number>): [number, number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n","export function convertPositionsToDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6378.137;\n  const dLat = (lat2 * Math.PI) / 180 - (lat1 * Math.PI) / 180;\n  const dLon = (lon2 * Math.PI) / 180 - (lon1 * Math.PI) / 180;\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const d = R * c;\n  return d * 1000; // measured in meters\n}\n\nexport function convertBytes(contentLength: number): string {\n  const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  let i = 0;\n\n  while (contentLength >= 1024 && i < units.length - 1) {\n    contentLength /= 1024;\n    i++;\n  }\n\n  return `${contentLength.toFixed(2)} ${units[i]}`;\n}\n\nexport function convertNumberToLetters(number: number): string {\n  let result = '';\n  while (number > 0) {\n    let remainder = (number - 1) % 26; // Adjust for 1-based indexing\n    let letter = String.fromCharCode(remainder + 65); // A=65 in ASCII\n    result = letter + result;\n    number = Math.floor((number - 1) / 26); // Update number for next iteration\n  }\n  return result;\n}","export function getTextWidth(text: string, weight: number, size: string, fontFamily: string): number {\n  const canvas: HTMLCanvasElement = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  const font: string = `${weight} ${size} ${fontFamily}`;\n  context.font = font;\n  return context.measureText(text).width;\n}\n\nexport function getTextHeight(text: string, weight: number, size: string, fontFamily: string): number {\n  const canvas: HTMLCanvasElement = getTextHeight.canvas || (getTextHeight.canvas = document.createElement('canvas'));\n  const context = canvas.getContext('2d');\n  const font: string = `${weight} ${size} ${fontFamily}`;\n  context.font = font;\n  context.textBaseline = 'top';\n  return context.measureText(text).actualBoundingBoxDescent;\n}\n\ninterface BorderRadius {\n  tl: number;\n  tr: number;\n  br: number;\n  bl: number;\n}\n\nexport function drawRoundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | BorderRadius, fill: string): void {\n  // If radius is a single value, treat it as the same for all corners\n  if (typeof radius === 'number') {\n    radius = { tl: radius, tr: radius, br: radius, bl: radius };\n  } else {\n    // Set defaults if individual radii are not provided\n    radius = {\n      tl: radius.tl || 0,\n      tr: radius.tr || 0,\n      br: radius.br || 0,\n      bl: radius.bl || 0\n    };\n  }\n\n  // Start path\n  ctx.beginPath();\n  // Move to the top-left corner, accounting for the top-left radius\n  ctx.moveTo(x + radius.tl, y);\n  // Draw the top line, rounding the top-right corner\n  ctx.lineTo(x + width - radius.tr, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n  // Draw the right side, rounding the bottom-right corner\n  ctx.lineTo(x + width, y + height - radius.br);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n  // Draw the bottom side, rounding the bottom-left corner\n  ctx.lineTo(x + radius.bl, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n  // Draw the left side, rounding the top-left corner\n  ctx.lineTo(x, y + radius.tl);\n  ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n  // Complete the path\n  ctx.closePath();\n\n  ctx.fillStyle = fill;\n  ctx.fill(); // To fill the shape\n}\n","export const md5 = require('md5');\nexport const sha256 = require('sha256');\n\nexport function compareThings(a: any, b: any): boolean {\n  function anyToString(any: any): string {\n    return JSON.stringify({ e: any });\n  }\n  const ax = anyToString(a);\n  const bx = anyToString(b);\n  const length: number = 32;\n  const axLength: number = ax.length;\n  const bxLength: number = bx.length;\n  if (axLength === bxLength) {\n    if (axLength > length || bxLength > length) {\n      const hash_a: string = md5(ax);\n      const hash_b: string = md5(bx);\n\n      let equal: boolean = true;\n      for (let i = 0; i < 8; i++) {\n        const a_i: string = hash_a.charAt(i);\n        const b_i: string = hash_b.charAt(i);\n        if (a_i === b_i) {\n          continue;\n        } else {\n          equal = false;\n          break;\n        }\n      }\n      return equal;\n    } else {\n      if (ax === bx) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function generateIdentifier(prefix: string = ''): string {\n  /*\n  const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n  let result = `${prefix}_`;\n  const length: number = 16;\n  for (let i = 0; i < length; i++) {\n    const randomNumber = Math.floor(Math.random() * characterSet.length);\n    result += characterSet.substring(randomNumber, randomNumber + 1);\n  }\n  return result;\n  */\n  const randomNumber = Math.random();\n  return prefix.concat(randomNumber.toString(36).substring(2));\n}\n\nexport function getNoCacheParameter(interval: number): string {\n  const time = new Date().getTime();\n  const number = (time / interval).toFixed(0) * interval;\n  const string = number.toString(36);\n  return string;\n}\n\nexport function releaseFile(content: string, type: string = 'application/json', fileName: string): void {\n  const blob = new Blob([content], { type: type });\n  const fileObj = new File([blob], fileName, { type: type });\n  if (navigator.canShare && navigator.canShare({ files: [fileObj] })) {\n    navigator\n      .share({\n        files: [fileObj]\n      })\n      .catch((error) => {});\n  } else {\n    const blobURL = URL.createObjectURL(blob);\n    const downloadLink = document.createElement('a');\n    downloadLink.href = blobURL;\n    downloadLink.download = fileName;\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    downloadLink.remove();\n    setTimeout(() => {\n      URL.revokeObjectURL(blobURL);\n    }, 10 * 1000);\n  }\n}\n\nexport function isRunningStandalone(): boolean {\n  return window.matchMedia('(display-mode: standalone)').matches;\n}\n\nexport function supportTouch(): boolean {\n  if ('ontouchstart' in window || navigator.maxTouchPoints) {\n    // Touch events are supported\n    return true;\n  } else {\n    // Touch events are not supported\n    return false;\n  }\n}\n\nexport function booleanToString(x: boolean): 'true' | 'false' {\n  if (typeof x === 'boolean') {\n    if (x) {\n      return 'true';\n    } else {\n      return 'false';\n    }\n  }\n}\n\nexport function isValidURL(string: string): boolean {\n  try {\n    new URL(string);\n    return true; // If no error is thrown, it's a valid URL\n  } catch (_) {\n    return false; // Invalid URL\n  }\n}\n\nexport function nearestPowerOf2(x: number): number {\n  return 1 << (31 - Math.clz32(x));\n}\n"],"names":["areItemsDifferent","arr","i","length","j","getIntersection","arrayA","arrayB","result","_step","_iterator","_createForOfIteratorHelper","s","n","done","item","value","indexOf","push","err","e","f","_step2","_iterator2","generateLetterLabels","quantity","concat","convertNumberToLetters","generateDirectionLabels","setsOfVectors","directions","vector","label","Math","sqrt","vectorSet","x","y","_step3","meanVector","convertToUnitVector","result2","_iterator3","direction","dotProduct","bestMatch","sort","a","b","addressToString","address","city","join","district","road","road_section","alley","alley_branch","doorplate","floornumber","generateLabelFromAddresses","addresses","_step4","filledProperties","_iterator4","key","hasOwnProperty","commonProperties","Object","entries","map","property","filter","_step5","_iterator5","_step6","commonProperty","components","_iterator6","len","max","apply","_toConsumableArray","addressesLength","mergeStandardDeviation","targetAverage","targetSTDEV","targetDataLength","sourceAverage","sourceSTDEV","sourceDataLength","mergedDataLength","mergedAverage","mergedVariance","pow","mergePearsonCorrelation","targetXAverage","targetYAverage","targetXSTDEV","targetYSTDEV","targetCorrelation","sourceXAverage","sourceYAverage","sourceXSTDEV","sourceYSTDEV","sourceCorrelation","hypot","newVector","scale","findExtremum","array","arrayLength","min","Infinity","convertPositionsToDistance","lat1","lon1","lat2","lon2","dLat","PI","dLon","sin","cos","atan2","convertBytes","contentLength","units","toFixed","number","remainder","String","fromCharCode","floor","getTextWidth","text","weight","size","fontFamily","context","canvas","document","createElement","getContext","font","measureText","width","drawRoundedRect","ctx","height","radius","fill","tl","tr","br","bl","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fillStyle","md5","require","sha256","compareThings","anyToString","any","JSON","stringify","ax","bx","axLength","bxLength","hash_a","hash_b","equal","charAt","generateIdentifier","prefix","arguments","undefined","randomNumber","random","toString","substring","getNoCacheParameter","interval","Date","getTime","releaseFile","content","type","fileName","blob","Blob","fileObj","File","navigator","canShare","files","share","error","blobURL","URL","createObjectURL","downloadLink","href","download","body","appendChild","click","remove","setTimeout","revokeObjectURL","isRunningStandalone","window","matchMedia","matches","supportTouch","maxTouchPoints","booleanToString","isValidURL","string","_"],"sourceRoot":""}