{"version":3,"file":"448934bc5de4e34b1f21.js","mappings":"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","sources":["webpack://bus/webpack/universalModuleDefinition","webpack://bus/./node_modules/ngeohash/main.js","webpack://bus/webpack/bootstrap","webpack://bus/./src/tools/geohash.ts","webpack://bus/./src/tools/math.ts","webpack://bus/./src/data/apis/getLocation/simplifyLocation-worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"bus\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bus\"] = factory();\n\telse\n\t\troot[\"bus\"] = factory();\n})(self, () => {\nreturn ","/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const { encode } = require('ngeohash');\n\nexport function geohashEncode(latitude: number, longitude: number, numberOfChars: number): string {\n  return encode(latitude, longitude, numberOfChars);\n}\n","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\n/**\n * get the unit vecotr towards the same direction\n * @param vector [a1, a2, a3, ...]\n * @returns [b1, b2, b3, ...]\n */\n\nexport function normalizeVector(vector: Array<number>): Array<number> {\n  let length = Math.hypot(vector);\n  let newVector = [];\n  if (length > 0) {\n    let scale = 1 / length;\n    for (const x of vector) {\n      newVector.push(x * scale);\n    }\n    return newVector;\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  let result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function findExtremum(array: Array<number>): [number, number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n","import { geohashEncode } from '../../../tools/geohash';\nimport { normalizeVector } from '../../../tools/math';\nimport { Location, SimplifiedLocation, SimplifiedLocationItem } from './index';\n\nself.onmessage = function (e) {\n  const result = processWorkerTask(e.data);\n  self.postMessage(result); // Send the result back to the main thread\n};\n\nfunction processWorkerTask(Location: Location): SimplifiedLocation {\n  let locationsByRoute = {};\n  for (const item of Location) {\n    const thisRouteID = item.routeId;\n    const thisRouteKey = `r_${thisRouteID}`;\n    if (!locationsByRoute.hasOwnProperty(thisRouteKey)) {\n      locationsByRoute[thisRouteKey] = [];\n    }\n    locationsByRoute[thisRouteKey].push(item);\n  }\n  for (const key in locationsByRoute) {\n    locationsByRoute[key] = locationsByRoute[key].sort(function (a, b) {\n      return a.seqNo - b.seqNo;\n    });\n  }\n  let result: SimplifiedLocation = {};\n  for (const item of Location) {\n    const thisRouteID = item.routeId;\n    const thisRouteKey = `r_${thisRouteID}`;\n    const thisItemLongitude = parseFloat(item.longitude);\n    const thisItemLatitude = parseFloat(item.latitude);\n\n    let vector = [0, 0];\n    const locationsOnThisRoute = locationsByRoute[thisRouteKey];\n    const locationsOnThisRouteLength = locationsOnThisRoute.length;\n    let nextLocation = null;\n    for (let i = 0; i < locationsOnThisRouteLength; i++) {\n      if (locationsOnThisRoute[i].Id === item.Id) {\n        let nextIndex = 0;\n        if (i < locationsOnThisRouteLength - 1) {\n          nextIndex = i + 1;\n        }\n        nextLocation = locationsOnThisRoute[nextIndex];\n      }\n    }\n    if (nextLocation) {\n      const x = parseFloat(nextLocation.longitude) - thisItemLongitude;\n      const y = parseFloat(nextLocation.latitude) - thisItemLatitude;\n      vector = normalizeVector([x, y]);\n    }\n\n    const key = `l_${item.stopLocationId}`;\n    if (!result.hasOwnProperty(key)) {\n      const simplifiedItem = {} as SimplifiedLocationItem;\n      simplifiedItem.n = item.nameZh;\n      simplifiedItem.lo = thisItemLongitude;\n      simplifiedItem.la = thisItemLatitude;\n      simplifiedItem.g = geohashEncode(thisItemLatitude, thisItemLongitude, 6);\n      simplifiedItem.r = [item.routeId];\n      simplifiedItem.s = [item.Id];\n      simplifiedItem.v = [vector];\n      simplifiedItem.a = [item.address];\n      simplifiedItem.id = item.stopLocationId;\n      result[key] = simplifiedItem;\n    } else {\n      if (result[key].r.indexOf(item.routeId) < 0) {\n        result[key].r.push(item.routeId);\n      }\n      if (result[key].s.indexOf(item.Id) < 0) {\n        result[key].s.push(item.Id);\n        result[key].v.push(vector);\n      }\n      result[key].a.push(item.address);\n    }\n  }\n  return result;\n}\n"],"names":["root","factory","exports","module","define","amd","self","BASE32_CODES","BASE32_CODES_DICT","i","charAt","ENCODE_AUTO","MIN_LAT","MAX_LAT","MIN_LON","MAX_LON","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","length","decSigFigsLong","numberOfSigFigs","Math","max","undefined","mid","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","l","toLowerCase","bit","decode_bbox_int","hashInt","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","ensure_valid_lon","ensure_valid_lat","neighbor_int","lonlat","neighbor_lat","neighbor_lon","geohash","hashstringLength","latErr","lonErr","encodeNeighbor","neighborLatDir","neighborLonDir","encodeNeighbor_int","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","latlon","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","require","geohashEncode","normalizeVector","vector","hypot","newVector","_step","scale","_iterator","_createForOfIteratorHelper","s","n","done","x","value","err","e","f","onmessage","result","Location","locationsByRoute","item","thisRouteKey","routeId","hasOwnProperty","key","sort","a","b","seqNo","_step2","_iterator2","thisItemLongitude","parseFloat","thisItemLatitude","locationsOnThisRoute","locationsOnThisRouteLength","nextLocation","Id","nextIndex","stopLocationId","r","indexOf","v","address","simplifiedItem","nameZh","lo","la","g","id","processWorkerTask","data","postMessage"],"sourceRoot":""}