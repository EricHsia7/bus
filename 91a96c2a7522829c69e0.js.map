{"version":3,"file":"91a96c2a7522829c69e0.js","mappings":"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","sources":["webpack://bus/./src/tools/path.ts","webpack://bus/./src/tools/time.ts","webpack://bus/./src/tools/index.ts","webpack://bus/./src/data/storage/index.ts","webpack://bus/./src/data/analytics/data-usage/index.ts","webpack://bus/./src/data/analytics/data-usage/worker.ts","webpack://bus/./src/tools/math.ts"],"sourcesContent":["export interface Segment {\n  x: number;\n  y: number;\n}\n\nexport type Segments = Array<Segment>;\n\nfunction distanceToSegment(point: Segment, start: Segment, end: Segment): number {\n  let dx = end.x - start.x;\n  let dy = end.y - start.y;\n  const d = dx * dx + dy * dy;\n  const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;\n\n  if (t < 0) {\n    dx = point.x - start.x;\n    dy = point.y - start.y;\n  } else if (t > 1) {\n    dx = point.x - end.x;\n    dy = point.y - end.y;\n  } else {\n    const closestPoint = { x: start.x + t * dx, y: start.y + t * dy };\n    dx = point.x - closestPoint.x;\n    dy = point.y - closestPoint.y;\n  }\n\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function simplifyPath(points: Segments, tolerance: number): Segments {\n  if (points.length < 3) {\n    return points;\n  }\n\n  let dmax = 0;\n  let index = 0;\n\n  // Find the point with the maximum distance\n  for (let i = 1; i < points.length - 1; i++) {\n    const d = distanceToSegment(points[i], points[0], points[points.length - 1]);\n    if (d > dmax) {\n      index = i;\n      dmax = d;\n    }\n  }\n\n  // If max distance is greater than tolerance, split the curve\n  if (dmax > tolerance) {\n    const leftPoints = points.slice(0, index + 1);\n    const rightPoints = points.slice(index);\n    const simplifiedLeft = simplifyPath(leftPoints, tolerance);\n    const simplifiedRight = simplifyPath(rightPoints, tolerance);\n    return simplifiedLeft.slice(0, simplifiedLeft.length - 1).concat(simplifiedRight);\n  } else {\n    return [points[0], points[points.length - 1]];\n  }\n}\n\nexport function segmentsToPath(segments: Segments, scale: number): string {\n  if (segments.length < 1) {\n    return '';\n  }\n  let pathCommand = `M${segments[0].x * scale},${segments[0].y * scale}`;\n  for (let i = 1; i < segments.length - 1; i++) {\n    const current = segments[i];\n    const next = segments[i + 1] || current;\n\n    pathCommand += `Q${current.x * scale},${current.y * scale},${(current.x * scale + next.x * scale) / 2},${(current.y * scale + next.y * scale) / 2}`;\n  }\n  const lastPoint = segments[segments.length - 1];\n  pathCommand += `L${lastPoint.x * scale},${lastPoint.y * scale}`;\n  return pathCommand;\n}\n","export function getThisWeekOrigin(): Date {\n  var today: Date = new Date();\n  var dayOfToday: number = today.getDay();\n  var originDate: number = today.getDate() - dayOfToday;\n  var origin: Date = new Date();\n  origin.setDate(originDate);\n  origin.setHours(0);\n  origin.setMinutes(0);\n  origin.setSeconds(0);\n  origin.setMilliseconds(0);\n  return origin;\n}\n\nexport function offsetDate(origin: Date, date: number, hours: number, minutes: number): Date {\n  var duplicatedOrigin = new Date();\n  duplicatedOrigin.setDate(1);\n  duplicatedOrigin.setMonth(0);\n  duplicatedOrigin.setHours(hours);\n  duplicatedOrigin.setMinutes(minutes);\n  duplicatedOrigin.setSeconds(0);\n  duplicatedOrigin.setMilliseconds(0);\n  duplicatedOrigin.setFullYear(origin.getFullYear());\n  duplicatedOrigin.setMonth(origin.getMonth());\n  duplicatedOrigin.setDate(origin.getDate());\n  duplicatedOrigin.setDate(duplicatedOrigin.getDate() + date);\n  return duplicatedOrigin;\n}\n\nexport function timeStampToNumber(string: string): number {\n  var regex = /[0-9\\.]*/gm;\n  var match = string.match(regex);\n  if (match) {\n    var year = parseInt(match[0]);\n    var month = parseInt(match[2]);\n    var date = parseInt(match[4]);\n    var hours = parseInt(match[6]);\n    var minutes = parseInt(match[8]);\n    var seconds = parseInt(match[10]);\n    var date_object = new Date();\n    date_object.setDate(1);\n    date_object.setMonth(0);\n    date_object.setFullYear(year);\n    date_object.setMonth(month - 1);\n    date_object.setDate(date);\n    date_object.setHours(hours);\n    date_object.setMinutes(minutes);\n    date_object.setSeconds(seconds);\n    return date_object.getTime();\n  }\n  return 0;\n}\n\nexport function dateToString(date: Date, template: string = 'YYYY-MM-DD hh:mm:ss'): string {\n  const result = template\n    .replaceAll(/Y{4,4}/g, date.getFullYear())\n    .replaceAll(/M{2,2}/g, String(date.getMonth() + 1).padStart(2, '0'))\n    .replaceAll(/D{2,2}/g, String(date.getDate()).padStart(2, '0'))\n    .replaceAll(/h{2,2}/g, String(date.getHours()).padStart(2, '0'))\n    .replaceAll(/m{2,2}/g, String(date.getMinutes()).padStart(2, '0'))\n    .replaceAll(/s{2,2}/g, String(date.getSeconds()).padStart(2, '0'));\n  return result;\n}\n\nexport function dateToRelativeTime(date: Date): string {\n  const time = date.getTime();\n  const seconds = Math.floor((new Date().getTime() - time) / 1000);\n  let interval = Math.floor(seconds / 31536000); // seconds in a year\n  if (interval >= 1) {\n    return `${interval}年前`;\n  }\n  interval = Math.floor(seconds / 2592000); // seconds in a month\n  if (interval >= 1) {\n    return `${interval}個月前`;\n  }\n  interval = Math.floor(seconds / 86400); // seconds in a day\n  if (interval >= 1) {\n    return `${interval}天前`;\n  }\n  interval = Math.floor(seconds / 3600); // seconds in an hour\n  if (interval >= 1) {\n    return `${interval}小時前`;\n  }\n  interval = Math.floor(seconds / 60); // seconds in a minute\n  if (interval >= 1) {\n    return `${interval}分鐘前`;\n  }\n  if (seconds > 0) {\n    return `${seconds}秒前`;\n  }\n  return '現在';\n}\n\nexport function formatTime(time: number, mode: number): string {\n  const roundedTime = time | 0;\n  switch (mode) {\n    case 0: {\n      return `${roundedTime}秒`;\n      break;\n    }\n    case 1: {\n      const minutes = String((roundedTime - (roundedTime % 60)) / 60);\n      const seconds = String(roundedTime % 60);\n      return [minutes, seconds].map((u) => u.padStart(2, '0')).join(':');\n      break;\n    }\n    case 2: {\n      const minutes = (roundedTime / 60) | 0;\n      return `${minutes}分`;\n      break;\n    }\n    case 3: {\n      if (roundedTime >= 60 * 60) {\n        const hours = parseFloat((roundedTime / (60 * 60)).toFixed(1));\n        return `${hours}時`;\n      }\n      if (60 <= roundedTime && roundedTime < 60 * 60) {\n        const minutes = (roundedTime / 60) | 0;\n        return `${minutes}分`;\n      }\n      if (roundedTime < 60) {\n        return `${roundedTime}秒`;\n      }\n      break;\n    }\n    default: {\n      return '--';\n      break;\n    }\n  }\n}\n\nexport type WeekDayIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n// 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, 4: Thursday, 5: Friday, 6: Saturday\n\nexport type WeekDayIndexArray = Array<WeekDayIndex>;\n\nexport type WeekDayName = '日' | '一' | '二' | '三' | '四' | '五' | '六';\n\nexport interface WeekDay {\n  name: WeekDayName;\n  day: WeekDayIndex;\n  code: string;\n}\n\nexport function indexToDay(index: WeekDayIndex): WeekDay {\n  const days = [\n    {\n      name: '日',\n      day: 0,\n      code: 'd_0'\n    },\n    {\n      name: '一',\n      day: 1,\n      code: 'd_1'\n    },\n    {\n      name: '二',\n      day: 2,\n      code: 'd_2'\n    },\n    {\n      name: '三',\n      day: 3,\n      code: 'd_3'\n    },\n    {\n      name: '四',\n      day: 4,\n      code: 'd_4'\n    },\n    {\n      name: '五',\n      day: 5,\n      code: 'd_5'\n    },\n    {\n      name: '六',\n      day: 6,\n      code: 'd_6'\n    }\n  ];\n  return days[index];\n}\n\nexport function dateValueToDayOfWeek(dateValue: string): WeekDay {\n  var int = parseInt(dateValue);\n  var index = int - 1;\n  return indexToDay(index);\n}\n\nexport interface TimeObject {\n  hours: number;\n  minutes: number;\n}\n\nexport interface TimePeriod {\n  start: TimeObject;\n  end: TimeObject;\n}\n\nexport interface TimeStampPeriod {\n  start: Date;\n  end: Date;\n}\n\nexport function timeObjectToString(timeObject: TimeObject): string {\n  return `${String(timeObject.hours).padStart(2, '0')}:${String(timeObject.minutes).padStart(2, '0')}`;\n}\n\nexport function createDateObjectFromDate(year: number, month: number, date: number): Date {\n  var dateObject = new Date();\n  dateObject.setDate(1); // Set to the first day of the month to prevent date from being clamped\n  dateObject.setMonth(0);\n  dateObject.setFullYear(year);\n  dateObject.setMonth(month - 1);\n  dateObject.setDate(date);\n  dateObject.setHours(0);\n  dateObject.setMinutes(0);\n  dateObject.setSeconds(0);\n  dateObject.setMilliseconds(0);\n  return dateObject;\n}\n\nexport function maxConcurrency(periods: Array<TimePeriod>): number {\n  let events: Array<[number, 1 | -1]> = [];\n\n  // Convert periods into events\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, 1]); // Start of a period\n    events.push([end.hours * 60 + end.minutes, -1]); // End of a period\n  }\n\n  // Sort events: Primary by time, secondary by type (-1 before +1)\n  events.sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]));\n\n  let maxCount = 0;\n  let currentCount = 0;\n\n  // Sweep through the events\n  for (let [, type] of events) {\n    currentCount += type;\n    maxCount = Math.max(maxCount, currentCount);\n  }\n\n  return maxCount;\n}\n\nexport function assignTracks(periods: Array<TimePeriod>): Array<Array<TimePeriod>> {\n  if (periods.length === 0) return [];\n\n  // Convert periods into events\n  let events: Array<[number, number, number]> = [];\n  let index = 0;\n  for (let { start, end } of periods) {\n    events.push([start.hours * 60 + start.minutes, end.hours * 60 + end.minutes, index]);\n    index += 1;\n  }\n\n  // Sort intervals by start time\n  events.sort((a, b) => a[0] - b[0]);\n\n  let tracks = [];\n  for (let [start, end, index] of events) {\n    let assigned = false;\n    for (let i = 0; i < tracks.length; i++) {\n      if (tracks[i][tracks[i].length - 1][1] <= start) {\n        tracks[i].push([start, end, index]);\n        assigned = true;\n        break;\n      }\n    }\n    if (!assigned) {\n      tracks.push([[start, end, index]]);\n    }\n  }\n\n  let i = 0;\n  for (const track of tracks) {\n    let j = 0;\n    for (const event of track) {\n      tracks[i][j] = periods[event[2]];\n      j += 1;\n    }\n    i += 1;\n  }\n\n  return tracks;\n}\n","export const md5 = require('md5');\nexport const sha256 = require('sha256');\n\nexport function compareThings(a: any, b: any): boolean {\n  function anyToString(any: any): string {\n    return JSON.stringify({ e: any });\n  }\n  const ax = anyToString(a);\n  const bx = anyToString(b);\n  const length: number = 32;\n  const axLength: number = ax.length;\n  const bxLength: number = bx.length;\n  if (axLength === bxLength) {\n    if (axLength > length || bxLength > length) {\n      const hash_a: string = md5(ax);\n      const hash_b: string = md5(bx);\n\n      let equal: boolean = true;\n      for (let i = 0; i < 8; i++) {\n        const a_i: string = hash_a.charAt(i);\n        const b_i: string = hash_b.charAt(i);\n        if (a_i === b_i) {\n          continue;\n        } else {\n          equal = false;\n          break;\n        }\n      }\n      return equal;\n    } else {\n      if (ax === bx) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function generateIdentifier(prefix: string = ''): string {\n  /*\n  const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n  let result = `${prefix}_`;\n  const length: number = 16;\n  for (let i = 0; i < length; i++) {\n    const randomNumber = Math.floor(Math.random() * characterSet.length);\n    result += characterSet.substring(randomNumber, randomNumber + 1);\n  }\n  return result;\n  */\n  const randomNumber = Math.random();\n  return prefix.concat(randomNumber.toString(36).substring(2));\n}\n\nexport function getNoCacheParameter(interval: number): string {\n  const time = new Date().getTime();\n  const number = (time / interval).toFixed(0) * interval;\n  const string = number.toString(36);\n  return string;\n}\n\nexport function releaseFile(content: string, type: string = 'application/json', fileName: string): void {\n  const blob = new Blob([content], { type: type });\n  const fileObj = new File([blob], fileName, { type: type });\n  if (navigator.canShare && navigator.canShare({ files: [fileObj] })) {\n    navigator\n      .share({\n        files: [fileObj]\n      })\n      .catch((error) => {});\n  } else {\n    const blobURL = URL.createObjectURL(blob);\n    const downloadLink = document.createElement('a');\n    downloadLink.href = blobURL;\n    downloadLink.download = fileName;\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    downloadLink.remove();\n    setTimeout(() => {\n      URL.revokeObjectURL(blobURL);\n    }, 10 * 1000);\n  }\n}\n\nexport function isRunningStandalone(): boolean {\n  return window.matchMedia('(display-mode: standalone)').matches;\n}\n\nexport function supportTouch(): boolean {\n  if ('ontouchstart' in window || navigator.maxTouchPoints) {\n    // Touch events are supported\n    return true;\n  } else {\n    // Touch events are not supported\n    return false;\n  }\n}\n\nexport function booleanToString(x: boolean): 'true' | 'false' {\n  if (typeof x === 'boolean') {\n    if (x) {\n      return 'true';\n    } else {\n      return 'false';\n    }\n  }\n}\n\nexport function isValidURL(string: string): boolean {\n  try {\n    new URL(string);\n    return true; // If no error is thrown, it's a valid URL\n  } catch (_) {\n    return false; // Invalid URL\n  }\n}\n\nexport function nearestPowerOf2(x: number): number {\n  return 1 << (31 - Math.clz32(x));\n}\n","const localforage = require('localforage');\n\nlet storage = {\n  cacheStore: false, // 0\n  settingsStore: false, // 1\n  dataUsageStatsStore: false, // 2\n  updateRateDataStore: false, // 3\n  updateRateDataWriteAheadLogStore: false, // 4\n  busArrivalTimeDataWriteAheadLogStore: false, // 5\n  busArrivalTimeDataStore: false, // 6\n  personalScheduleStore: false, // 7\n  recentViewsStore: false, // 8\n  notificationStore: false, // 9\n  notificationScheduleStore: false, // 10\n  folderListStore: false, // 11\n  folderContentIndexStore: false, // 12\n  folderContentStore: false // 13\n};\n\nconst stores = ['cacheStore', 'settingsStore', 'dataUsageStatsStore', 'updateRateDataStore', 'updateRateDataWriteAheadLogStore', 'busArrivalTimeDataWriteAheadLogStore', 'busArrivalTimeDataStore', 'personalScheduleStore', 'recentViewsStore', 'notificationStore', 'notificationScheduleStore', 'folderListStore', 'folderContentIndexStore', 'folderContentStore'];\n\nasync function dropInstance(store: number): Promise<any> {\n  const storeKey = stores[store];\n  if (storage[storeKey] === false) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n  }\n  const operation = await storage[storeKey].dropInstance();\n  return operation;\n}\n\nexport async function lfSetItem(store: number, key: string, value: any): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].setItem(key, value);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfGetItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].getItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfRemoveItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].removeItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    // await dropInstance(store);\n    return null;\n  }\n}\n\nexport async function lfListItemKeys(store: number): Promise<Array<string>> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const keys = await storage[storeKey].keys();\n    return keys;\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n}\n\nexport function getStoreKey(store: number): string {\n  return stores[store];\n}\n\nexport function getStoresLength(): number {\n  return stores.length;\n}\n\n/*\nexport async function registerStore(id: string): Promise<number> {\n  const storeKey = `F${id}Store`;\n  if (!storage.hasOwnProperty(storeKey) && stores.indexOf(storeKey) < 0) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n    stores.push(storeKey);\n    return stores.length - 1;\n  } else {\n    return stores.indexOf(storeKey);\n  }\n}\n*/\n\nexport async function isStoragePersistent(): Promise<boolean> {\n  // Check if site's storage has been marked as persistent\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persisted();\n      return isPersisted;\n    }\n  }\n  return false;\n}\n\nexport async function askForPersistentStorage(): Promise<'granted' | 'denied' | 'unsupported'> {\n  // Request persistent storage for site\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persist();\n      return isPersisted ? 'granted' : 'denied';\n    }\n  }\n  return 'unsupported';\n}\n","import { generateIdentifier } from '../../../tools/index';\nimport { createDateObjectFromDate, dateToString, offsetDate, TimeStampPeriod } from '../../../tools/time';\nimport { lfSetItem, lfGetItem, lfListItemKeys, lfRemoveItem } from '../../storage/index';\n\nexport interface DataUsageStatsChunk {\n  date: [year: number, month: number, day: number];\n  data: Array<number>;\n  stats: {\n    sum: number;\n    max: number;\n    min: number;\n  };\n}\n\nexport type DataUsageStatsChunkArray = Array<DataUsageStatsChunk>;\n\nexport interface DataUsageStats {\n  stats: {\n    sum: number;\n    max: number;\n    min: number;\n  };\n  period: TimeStampPeriod;\n  chart: string;\n}\n\nexport const DataUsagePeriod = 7; // days\n\nexport async function recordDataUsage(contentLength: number, date: Date) {\n  const key = `d_${dateToString(date, 'YYYY_MM_DD')}`;\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const index = hours * 60 + minutes;\n  const existingDataUsageStatsChunkJSON = await lfGetItem(2, key);\n  if (existingDataUsageStatsChunkJSON) {\n    const existingDataUsageStatsChunkObject = JSON.parse(existingDataUsageStatsChunkJSON) as DataUsageStatsChunk;\n    existingDataUsageStatsChunkObject.stats.sum += contentLength;\n    existingDataUsageStatsChunkObject.data[index] += contentLength;\n    const changedData = existingDataUsageStatsChunkObject.data[index];\n    if (changedData > existingDataUsageStatsChunkObject.stats.max) {\n      existingDataUsageStatsChunkObject.stats.max = changedData;\n    }\n    if (changedData < existingDataUsageStatsChunkObject.stats.min) {\n      existingDataUsageStatsChunkObject.stats.min = changedData;\n    }\n    await lfSetItem(2, key, JSON.stringify(existingDataUsageStatsChunkObject));\n  } else {\n    const newDataUsageStatsChunk = {} as DataUsageStatsChunk;\n    const data = new Uint32Array(60 * 24);\n    data[index] += contentLength;\n    newDataUsageStatsChunk.data = Array.from(data);\n    newDataUsageStatsChunk.stats = {\n      sum: contentLength,\n      max: contentLength,\n      min: 0\n    };\n    newDataUsageStatsChunk.date = [date.getFullYear(), date.getMonth() + 1, date.getDate()];\n    await lfSetItem(2, key, JSON.stringify(newDataUsageStatsChunk));\n  }\n}\n\nexport async function listDataUsageStatsChunks(): Promise<DataUsageStatsChunkArray> {\n  const endDate = new Date();\n  endDate.setHours(0);\n  endDate.setMinutes(0);\n  endDate.setSeconds(0);\n  endDate.setMilliseconds(0);\n  const startDate = offsetDate(endDate, -1 * DataUsagePeriod, 0, 0);\n  const result: DataUsageStatsChunkArray = [];\n  for (let i = 0; i < DataUsagePeriod; i++) {\n    const date = offsetDate(startDate, i, 0, 0);\n    const key = `d_${dateToString(date, 'YYYY_MM_DD')}`;\n    const existingDataUsageStatsChunkJSON = await lfGetItem(2, key);\n    if (existingDataUsageStatsChunkJSON) {\n      const existingDataUsageStatsChunkObject = JSON.parse(existingDataUsageStatsChunkJSON) as DataUsageStatsChunk;\n      result.push(existingDataUsageStatsChunkObject);\n    } else {\n      const blankDataUsageStatsChunk = {} as DataUsageStatsChunk;\n      const data = new Uint32Array(60 * 24);\n      blankDataUsageStatsChunk.data = Array.from(data);\n      blankDataUsageStatsChunk.stats = {\n        sum: 0,\n        max: 0,\n        min: 0\n      };\n      blankDataUsageStatsChunk.date = [date.getFullYear(), date.getMonth() + 1, date.getDate()];\n      result.push(blankDataUsageStatsChunk);\n    }\n  }\n  return result;\n}\n\nexport async function discardExpiredDataUsageRecords() {\n  const millisecondsPerDay = 60 * 60 * 24 * 1000;\n  const expirationPeriod = millisecondsPerDay * DataUsagePeriod;\n  const now = new Date().getTime();\n  const keys = await lfListItemKeys(2);\n  for (const key of keys) {\n    const json = await lfGetItem(2, key);\n    const object = JSON.parse(json) as DataUsageStatsChunk;\n    const date = createDateObjectFromDate(object.date[0], object.date[1], object.date[2]);\n    if (now - date.getTime() > expirationPeriod) {\n      await lfRemoveItem(2, key);\n    }\n  }\n}\n\nlet workerResponses: {\n  [key: string]: Function;\n} = {};\nvar port;\n\n// Check if SharedWorker is supported, and fall back to Worker if not\nif (typeof SharedWorker !== 'undefined') {\n  const getDataUsageStatsSharedWorker = new SharedWorker(new URL('./worker.ts', import.meta.url)); // Reusable shared worker\n  port = getDataUsageStatsSharedWorker.port; // Access the port for communication\n  port.start(); // Start the port (required by some browsers)\n} else {\n  const getDataUsageStatsWorker = new Worker(new URL('./worker.ts', import.meta.url)); // Fallback to standard worker\n  port = getDataUsageStatsWorker; // Use Worker directly for communication\n}\n\n// Handle messages from the worker\nport.onmessage = function (e) {\n  if (e.data.length === 1) {\n    console.log(e.data[0]);\n    return;\n  }\n  const [result, taskID] = e.data;\n  if (workerResponses[taskID]) {\n    workerResponses[taskID](result); // Resolve the correct promise\n    delete workerResponses[taskID]; // Clean up the response handler\n  }\n};\n\n// Handle errors\nport.onerror = function (e) {\n  console.error(e.message);\n};\n\nexport async function getDataUsageStats(width: number, height: number, padding: number): Promise<DataUsageStats> {\n  const taskID = generateIdentifier('t');\n  const dataUsageStatsChunks = await listDataUsageStatsChunks();\n  const result = await new Promise((resolve, reject) => {\n    workerResponses[taskID] = resolve; // Store the resolve function for this taskID\n    port.onerror = function (e) {\n      reject(e.message);\n    };\n    port.postMessage([dataUsageStatsChunks, width, height, padding, taskID]); // Send the task to the worker\n  });\n  return result;\n}\n","import { findExtremum } from '../../../tools/math';\nimport { Segments, segmentsToPath, simplifyPath } from '../../../tools/path';\nimport { createDateObjectFromDate } from '../../../tools/time';\nimport { DataUsagePeriod, DataUsageStats, DataUsageStatsChunkArray } from './index';\n\ninterface task {\n  dataUsageStatsChunks: DataUsageStatsChunkArray;\n  width: number;\n  height: number;\n  padding: number;\n  taskID: string;\n  port: any;\n}\n\nlet taskQueue: Array<task> = [];\nlet isProcessing: boolean = false;\n\n// Setup message handling (works for dedicated or shared workers)\nif ('onconnect' in self) {\n  self.onconnect = function (e) {\n    const port = e.ports[0];\n    port.onmessage = function (event) {\n      port.postMessage([-1]);\n      const [dataUsageStatsChunks, width, height, padding, taskID] = event.data;\n      taskQueue.push({ dataUsageStatsChunks, width, height, padding, taskID, port });\n      processWorkerTask();\n    };\n  };\n} else {\n  const port = self;\n  self.onmessage = function (event) {\n    port.postMessage([-1]);\n    const [dataUsageStatsChunks, width, height, padding, taskID] = event.data;\n    taskQueue.push({ dataUsageStatsChunks, width, height, padding, taskID, port });\n    processWorkerTask();\n  };\n}\n\nconst minutesPerDay = 60 * 24;\n\n// Main processing function\nfunction processWorkerTask(): void {\n  if (isProcessing || taskQueue.length === 0) return;\n  isProcessing = true;\n\n  // Dequeue the next task\n  const { dataUsageStatsChunks, width, height, padding, taskID, port }: task = taskQueue.shift();\n\n  const dataUsageStatsChunksLength = dataUsageStatsChunks.length;\n\n  let extremum: Array<number> = [];\n  let sum: number = 0;\n  for (const dataUsageStatsChunk of dataUsageStatsChunks) {\n    extremum.push(dataUsageStatsChunk.stats.max);\n    extremum.push(dataUsageStatsChunk.stats.min);\n    sum += dataUsageStatsChunk.stats.sum;\n  }\n\n  const globalExtremum = findExtremum(extremum);\n  const max = globalExtremum[1] === 0 ? 1 : globalExtremum[1]; // prevent division by zero\n  const min = globalExtremum[0] === 0 ? 1 : globalExtremum[0]; // prevent division by zero\n\n  const start = dataUsageStatsChunks[0].date;\n  const end = dataUsageStatsChunks[dataUsageStatsChunksLength - 1].date;\n  const startDate = createDateObjectFromDate(start[0], start[1], start[2]);\n  const endDate = createDateObjectFromDate(end[0], end[1], end[2]);\n\n  const points: Segments = [];\n  for (let i = 0; i < dataUsageStatsChunksLength; i++) {\n    const dataUsageStatsChunk = dataUsageStatsChunks[i];\n    const data = dataUsageStatsChunk.data;\n    for (let j = 0; j < minutesPerDay; j++) {\n      const x = padding + (i / DataUsagePeriod + j / minutesPerDay) * width;\n      const y = padding + (1 - data[j] / max) * height;\n      points.push({ x, y });\n    }\n  }\n\n  // X-axis (horizontal)\n  const xAxis = `<line x1=\"${padding}\" y1=\"${height + padding}\" x2=\"${padding + width}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Y-axis (vertical)\n  const yAxis = `<line x1=\"${padding}\" y1=\"${padding}\" x2=\"${padding}\" y2=\"${height + padding}\" stroke=\"var(--b-cssvar-333333)\" stroke-width=\"1\" />`;\n\n  // Axis Labels\n  const xAxisLabel = `<text x=\"${padding + width / 2}\" y=\"${padding + height + padding}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\">時間</text>`;\n  const yAxisLabel = `<text x=\"${padding / 2}\" y=\"${padding + height / 2}\" text-anchor=\"middle\" font-size=\"12\" fill=\"var(--b-cssvar-333333)\" transform=\"rotate(-90, ${padding * 0.7}, ${padding + height / 2})\">傳輸量</text>`;\n\n  // Paths\n  const simplifiedPath = simplifyPath(points, 1.1);\n  const pathData = segmentsToPath(simplifiedPath, 1);\n  const fillingPathData = `M${padding},${height + padding}${pathData}L${padding + width},${height + padding}L${padding},${height + padding}`;\n  const path = `<path d=\"${pathData}\" fill=\"none\" stroke=\"var(--b-cssvar-main-color)\" stroke-width=\"0.9\" stroke-linecap=\"round\" stroke-linejoin=\"round\" opacity=\"1\"></path>`;\n  const fillingPath = `<path d=\"${fillingPathData}\" stroke=\"none\" stroke-width=\"0\" fill=\"url(#grad1)\"></path>`;\n  const filling = `<linearGradient id=\"grad1\" x1=\"50%\" y1=\"0%\" x2=\"50%\" y2=\"100%\"><stop offset=\"0%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.3);\" /><stop offset=\"73%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0.09);\" /><stop offset=\"100%\" style=\"stop-color:rgba(var(--b-cssvar-main-color-r), var(--b-cssvar-main-color-g), var(--b-cssvar-main-color-b), 0);\" /></linearGradient>`;\n\n  // SVG\n  const chart = /*html*/ `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width + padding * 2}px\" height=\"${height + padding * 2}px\" viewBox=\"0 0 ${width + padding * 2} ${height + padding * 2}\"><defs>${filling}</defs>${fillingPath}${path}${xAxis}${yAxis}${xAxisLabel}${yAxisLabel}</svg>`;\n\n  const result: DataUsageStats = {\n    stats: {\n      max,\n      min,\n      sum\n    },\n    period: {\n      start: startDate,\n      end: endDate\n    },\n    chart\n  };\n\n  // Send the result back to the main thread\n  port.postMessage([result, taskID]);\n\n  isProcessing = false;\n  processWorkerTask(); // Process next task in the queue if any\n}\n","export function calculateStandardDeviation(arr: Array<number>): number {\n  // Step 1: Calculate the mean\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 2: Calculate the squared difference between each element and the mean\n  const squaredDifferences = arr.map((val) => Math.pow(val - mean, 2));\n  // Step 3: Find the mean of those squared differences\n  const meanOfSquaredDifferences = squaredDifferences.reduce((acc, val) => acc + val, 0) / arr.length;\n  // Step 4: Take the square root of that mean\n  const standardDeviation = Math.sqrt(meanOfSquaredDifferences);\n  return standardDeviation;\n}\n\nexport function standardizeArray(array: Array<number>): Array<number> {\n  // Calculate the mean of the array\n  const mean = array.reduce((acc, val) => acc + val, 0) / array.length;\n\n  // Calculate the standard deviation\n  const stdDev = calculateStandardDeviation(array);\n\n  // Standardize the array\n  return array.map((val) => (val - mean) / stdDev);\n}\n\n// Function to calculate Pearson correlation coefficient\nexport function pearsonCorrelation(x: Array<number>, y: Array<number>): number {\n  const n = x.length;\n  if (n !== y.length) {\n    throw new Error('Arrays must have the same length');\n  }\n\n  let sumX = 0,\n    sumY = 0,\n    sumXY = 0,\n    sumXSquared = 0,\n    sumYSquared = 0;\n\n  for (let i = 0; i < n; i++) {\n    sumX += x[i];\n    sumY += y[i];\n    sumXY += x[i] * y[i];\n    sumXSquared += x[i] ** 2;\n    sumYSquared += y[i] ** 2;\n  }\n\n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumXSquared - sumX ** 2) * (n * sumYSquared - sumY ** 2));\n\n  if (denominator === 0) {\n    return 0; // Correlation is undefined in this case\n  }\n\n  return numerator / denominator;\n}\n\nexport function mergeStandardDeviation(targetAverage: number, targetSTDEV: number, targetDataLength: number, sourceAverage: number, sourceSTDEV: number, sourceDataLength: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedAverage = (targetDataLength * targetAverage + sourceDataLength * sourceAverage) / mergedDataLength;\n\n  const mergedVariance = (targetDataLength * (Math.pow(targetSTDEV, 2) + Math.pow(targetAverage, 2)) + sourceDataLength * (Math.pow(sourceSTDEV, 2) + Math.pow(sourceAverage, 2))) / mergedDataLength - Math.pow(mergedAverage, 2);\n\n  const mergedSTDEV = Math.sqrt(mergedVariance);\n  return mergedSTDEV;\n}\n\nexport function mergePearsonCorrelation(targetXAverage: number, targetYAverage: number, targetXSTDEV: number, targetYSTDEV: number, targetDataLength: number, targetCorrelation: number, sourceXAverage: number, sourceYAverage: number, sourceXSTDEV: number, sourceYSTDEV: number, sourceDataLength: number, sourceCorrelation: number): number {\n  const mergedDataLength = targetDataLength + sourceDataLength;\n\n  const mergedXAverage = (targetDataLength * targetXAverage + sourceDataLength * sourceXAverage) / mergedDataLength;\n  const mergedYAverage = (targetDataLength * targetYAverage + sourceDataLength * sourceYAverage) / mergedDataLength;\n\n  const mergedXSTDEV = mergeStandardDeviation(targetXAverage, targetXSTDEV, targetDataLength, sourceXAverage, sourceXSTDEV, sourceDataLength);\n  const mergedYSTDEV = mergeStandardDeviation(targetYAverage, targetYSTDEV, targetDataLength, sourceYAverage, sourceYSTDEV, sourceDataLength);\n\n  const mergedCorrelation = (targetDataLength * (targetXSTDEV * targetYSTDEV * targetCorrelation + targetXAverage * targetYAverage) + sourceDataLength * (sourceXSTDEV * sourceYSTDEV * sourceCorrelation + sourceXAverage * sourceYAverage) - mergedDataLength * mergedXAverage * mergedYAverage) / (mergedDataLength * mergedXSTDEV * mergedYSTDEV);\n  return mergedCorrelation;\n}\n\nexport function convertToUnitVector(vector: Array<number>): Array<number> {\n  let length = Math.hypot(vector);\n  let newVector = [];\n  if (length > 0) {\n    let scale = 1 / length;\n    for (const x of vector) {\n      newVector.push(x * scale);\n    }\n    return newVector;\n  } else {\n    return vector;\n  }\n}\n\nexport function smoothArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  let result = [];\n  for (let i = 1; i < arrayLength; i += 3) {\n    const currentItem = array[i];\n    const previousItem = array[i - 1] || currentItem;\n    const nextItem = array[i + 1] || currentItem;\n    result.push((previousItem + currentItem + nextItem) / 3);\n  }\n  return result;\n}\n\nexport function softmaxArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n\n  // Return an empty array if the input is empty\n  if (arrayLength === 0) {\n    return [];\n  }\n\n  // Find the global maximum\n  let max = -Infinity;\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n  }\n\n  // Exponentiate each element (for numerical stability, subtract the max value)\n  // Sum all the exponentiated values\n  const expArray = new Float32Array(arrayLength);\n  let sumExp = 0;\n  for (let j = arrayLength - 1; j >= 0; j--) {\n    const exp = Math.exp(array[j] - max);\n    expArray[j] = exp;\n    sumExp += exp;\n  }\n\n  // Normalize each value\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let k = arrayLength - 1; k >= 0; k--) {\n    const normalizedValue = expArray[k] / sumExp;\n    normalizedArray[k] = normalizedValue;\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function sigmoidArray(array: Array<number>): Array<number> {\n  const arrayLength = array.length;\n  const normalizedArray = new Float32Array(arrayLength);\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    normalizedArray[i] = 1 / (1 + Math.exp(-1 * array[i]));\n  }\n  return Array.from(normalizedArray);\n}\n\nexport function calculateAverage(array: Array<number>): number {\n  if (array.length === 0) {\n    return 0;\n  } else {\n    const sum = array.reduce((acc, curr) => acc + curr, 0);\n    return sum / array.length;\n  }\n}\n\nexport function findExtremum(array: Array<number>): [number, number] {\n  const arrayLength = array.length;\n  if (arrayLength === 0) {\n    return [0, 0];\n  }\n\n  let min = Infinity;\n  let max = -Infinity;\n\n  for (let i = arrayLength - 1; i >= 0; i--) {\n    const item = array[i];\n    if (item > max) {\n      max = item;\n    }\n    if (item < min) {\n      min = item;\n    }\n  }\n  return [min, max];\n}\n"],"names":["distanceToSegment","point","start","end","dx","x","dy","y","d","t","closestPoint","Math","sqrt","simplifyPath","points","tolerance","length","dmax","index","i","leftPoints","slice","rightPoints","simplifiedLeft","simplifiedRight","concat","createDateObjectFromDate","year","month","date","dateObject","Date","setDate","setMonth","setFullYear","setHours","setMinutes","setSeconds","setMilliseconds","require","port","workerResponses","SharedWorker","getDataUsageStatsSharedWorker","URL","getDataUsageStatsWorker","Worker","onmessage","e","data","_e$data","_slicedToArray","result","taskID","console","log","onerror","error","message","taskQueue","isProcessing","self","onconnect","ports","event","postMessage","_event$data","dataUsageStatsChunks","width","height","padding","push","processWorkerTask","_event$data2","minutesPerDay","_step","_taskQueue$shift","shift","dataUsageStatsChunksLength","extremum","sum","_iterator","_createForOfIteratorHelper","s","n","done","dataUsageStatsChunk","value","stats","max","min","err","f","globalExtremum","array","arrayLength","Infinity","item","findExtremum","startDate","endDate","j","xAxis","yAxis","xAxisLabel","yAxisLabel","pathData","segments","scale","pathCommand","current","next","lastPoint","segmentsToPath","fillingPathData","path","fillingPath","period","chart"],"sourceRoot":""}